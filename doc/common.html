<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Common Utilities</title>
<link type="text/css" rel="stylesheet" href="style.css"/>
</head>
<body>
<h1 id="common-utilities">Common Utilities</h1>
<p>By Ross Smith</p>
<ul>
<li><code>#include "rs-core/common.hpp"</code></li>
</ul>
<h2 id="contents">Contents</h2>
<div class="toc">
<ul>
<li><a href="#common-utilities">Common Utilities</a><ul>
<li><a href="#contents">Contents</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#preprocessor-macros">Preprocessor macros</a><ul>
<li><a href="#compilation-environment-properties">Compilation environment properties</a></li>
<li><a href="#type-generation-macros">Type generation macros</a></li>
</ul>
</li>
<li><a href="#types">Types</a><ul>
<li><a href="#basic-types">Basic types</a></li>
<li><a href="#integer-types">Integer types</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#mixins">Mixins</a></li>
<li><a href="#range-types">Range types</a></li>
<li><a href="#smart-pointers">Smart pointers</a></li>
<li><a href="#type-adapters">Type adapters</a></li>
<li><a href="#type-names">Type names</a></li>
<li><a href="#type-related-functions">Type related functions</a></li>
<li><a href="#type-traits">Type traits</a></li>
</ul>
</li>
<li><a href="#constants-and-literals">Constants and literals</a><ul>
<li><a href="#general-constants">General constants</a></li>
<li><a href="#arithmetic-constants">Arithmetic constants</a></li>
<li><a href="#arithmetic-literals">Arithmetic literals</a></li>
</ul>
</li>
<li><a href="#algorithms-and-ranges">Algorithms and ranges</a><ul>
<li><a href="#generic-algorithms">Generic algorithms</a></li>
<li><a href="#integer-sequences">Integer sequences</a></li>
<li><a href="#memory-algorithms">Memory algorithms</a></li>
</ul>
</li>
<li><a href="#arithmetic-functions">Arithmetic functions</a><ul>
<li><a href="#generic-arithmetic-functions">Generic arithmetic functions</a></li>
<li><a href="#integer-arithmetic-functions">Integer arithmetic functions</a></li>
</ul>
</li>
<li><a href="#date-and-time-functions">Date and time functions</a><ul>
<li><a href="#constants">Constants</a></li>
<li><a href="#conversion-functions">Conversion functions</a></li>
<li><a href="#formatting-functions">Formatting functions</a></li>
</ul>
</li>
<li><a href="#error-handling">Error handling</a><ul>
<li><a href="#assertion-functions">Assertion functions</a></li>
</ul>
</li>
<li><a href="#functional-utilities">Functional utilities</a><ul>
<li><a href="#function-traits">Function traits</a></li>
<li><a href="#function-operations">Function operations</a></li>
<li><a href="#generic-function-objects">Generic function objects</a></li>
<li><a href="#hash-functions">Hash functions</a></li>
<li><a href="#scope-guards">Scope guards</a></li>
</ul>
</li>
<li><a href="#io-utilities">I/O utilities</a><ul>
<li><a href="#logging">Logging</a></li>
</ul>
</li>
<li><a href="#keyword-arguments">Keyword arguments</a><ul>
<li><a href="#keyword-arguments_1">Keyword arguments</a></li>
</ul>
</li>
<li><a href="#multithreading">Multithreading</a><ul>
<li><a href="#thread-class">Thread class</a></li>
</ul>
</li>
<li><a href="#string-functions">String functions</a><ul>
<li><a href="#general-string-functions">General string functions</a></li>
<li><a href="#case-conversion-functions">Case conversion functions</a></li>
<li><a href="#character-functions">Character functions</a></li>
<li><a href="#string-conversion-functions">String conversion functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="introduction">Introduction</h2>
<p>The <code>"unicorn/utility.hpp"</code> header from the Unicorn library is included in
this header. For convenient reference, all of the relevant contents of that
header are documented again here, marked with <code><span class="unicorn">[unicorn]</span></code>.</p>
<h2 id="preprocessor-macros">Preprocessor macros</h2>
<h3 id="compilation-environment-properties">Compilation environment properties</h3>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>RS_NATIVE_WCHAR</code></strong> <code>1</code> <em>- defined if the system API uses wide characters</em></li>
<li><code>#define</code> <strong><code>RS_WCHAR_UTF16</code></strong> <code>1</code> <em>- defined if wchar_t and wstring are UTF-16</em></li>
<li><code>#define</code> <strong><code>RS_WCHAR_UTF32</code></strong> <code>1</code> <em>- defined if wchar_t and wstring are UTF-32</em></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> These are defined to reflect the encoding represented by <code>wchar_t</code>
and <code>std::wstring</code>. Systems where wide strings are neither UTF-16 nor UTF-32
are not supported.</p>
</div>
<h3 id="type-generation-macros">Type generation macros</h3>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>RS_BITMASK_OPERATORS</code></strong><code>(EnumType)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Defines bit manipulation and related operators for an <code>enum class</code>
(unary <code>!</code>, <code>~</code>; binary <code>&amp;</code>, <code>&amp;=</code>, <code>|</code>, <code>|=</code>, <code>^</code>, <code>^=</code>). The type can be
defined the conventional way or through the <code>RS_ENUM_CLASS()</code> macro.</p>
</div>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>RS_ENUM</code></strong><code>(EnumType, IntType, first_value, first_name, ...)</code></li>
<li><code>#define</code> <strong><code>RS_ENUM_CLASS</code></strong><code>(EnumType, IntType, first_value, first_name, ...)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> These define an enumeration, given the name of the enumeration
type, the underlying integer type, the integer value of the first entry, and a
list of value names. They will also define the following functions:</p>
<ul>
<li><code>constexpr bool</code> <strong><code>enum_is_valid</code></strong><code>(EnumType t) noexcept</code></li>
<li><code>std::vector&lt;EnumType&gt;</code> <strong><code>enum_values&lt;EnumType&gt;</code></strong><code>()</code></li>
<li><code>bool</code> <strong><code>str_to_enum</code></strong><code>(std::string_view s, EnumType&amp; t) noexcept</code></li>
<li><code>std::string</code> <strong><code>to_str</code></strong><code>(EnumType t)</code></li>
<li><code>std::ostream&amp;</code> <strong><code>operator&lt;&lt;</code></strong><code>(std::ostream&amp; out, EnumType t)</code></li>
</ul>
<p>The <code>enum_is_valid()</code> function reports whether or not the argument is a named
value of the enumeration. The <code>enum_values&lt;T&gt;()</code> function returns a vector
containing all of the enumeration values. The <code>str_to_enum()</code> function
converts the name of an enumeration value (case sensitive; possibly qualified
with the class name) to the corresponding value; if the string does not match
any value, it leaves the reference argument unchanged and returns false. The
<code>to_str()</code> function and the output operator print the name of an enumeration
constant (qualified with the class name if this is an <code>enum class</code>), or the
integer value if the argument is not a named value.</p>
<p>Example:</p>
<pre><code>RS_ENUM(Foo, 1, alpha, bravo, charlie)
RS_ENUM_CLASS(Bar, 1, delta, echo, foxtrot)
</code></pre>
<p>Equivalent code:</p>
<pre><code>enum Foo { alpha = 1, bravo, charlie };
constexpr bool enum_is_valid(Foo t) noexcept { ... }
std::string to_str(Foo t) { ... }
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Foo t) { ... }

enum class Bar { delta = 1, echo, foxtrot };
constexpr bool enum_is_valid(Bar t) noexcept { ... }
std::string to_str(Bar t) { ... }
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Bar t) { ... }
</code></pre>
<p>The macros can be used in any namespace, and the functions that take an enum
value as an argument will be in that namespace, but <code>enum_values()</code> is a
single function template in <code>namespace RS</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>RS_MOVE_ONLY</code></strong><code>(T)</code><ul>
<li><code>T(const T&amp;) = delete;</code></li>
<li><code>T(T&amp;&amp;) = default;</code></li>
<li><code>T&amp; operator=(const T&amp;) = delete;</code></li>
<li><code>T&amp; operator=(T&amp;&amp;) = default;</code></li>
</ul>
</li>
<li><code>#define</code> <strong><code>RS_NO_COPY_MOVE</code></strong><code>(T)</code><ul>
<li><code>T(const T&amp;) = delete;</code></li>
<li><code>T(T&amp;&amp;) = delete;</code></li>
<li><code>T&amp; operator=(const T&amp;) = delete;</code></li>
<li><code>T&amp; operator=(T&amp;&amp;) = delete;</code></li>
</ul>
</li>
<li><code>#define</code> <strong><code>RS_NO_INSTANCE</code></strong><code>(T)</code><ul>
<li><code>T() = delete;</code></li>
<li><code>T(const T&amp;) = delete;</code></li>
<li><code>T(T&amp;&amp;) = delete;</code></li>
<li><code>~T() = delete;</code></li>
<li><code>T&amp; operator=(const T&amp;) = delete;</code></li>
<li><code>T&amp; operator=(T&amp;&amp;) = delete;</code></li>
</ul>
</li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Convenience macros for defaulted or deleted life cycle operations.</p>
</div>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>RS_OVERLOAD</code></strong><code>(f) [] (auto&amp;&amp;... args) { return f(std::forward&lt;decltype(args)&gt;(args)...); }</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Creates a function object wrapping a set of overloaded functions,
that can be passed to a context expecting a function (such as an STL
algorithm) without having to explicitly resolve the overload at the call site.
(From an idea by Arthur O'Dwyer on the C++ standard proposals mailing list, 14
Sep 2015.)</p>
</div>
<h2 id="types">Types</h2>
<h3 id="basic-types">Basic types</h3>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>Ustring</code></strong> <code>= std::string</code></li>
<li><code>using</code> <strong><code>Uview</code></strong> <code>= std::string_view</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Use <code>Ustring</code> or <code>Uview</code> for strings that are expected to be in
UTF-8 (or ASCII, since any ASCII string is also valid UTF-8), while plain
<code>std::string</code> or <code>std::string_view</code> is used where the string is expected to be
in some other Unicode encoding, or where the string is being used simply as an
array of bytes rather than encoded text.</p>
</div>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>Strings</code></strong> <code>= std::vector&lt;std::string&gt;</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Commonly used type defined for convenience.</p>
</div>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>NativeCharacter</code></strong> <code>= [char on Unix, wchar_t on Windows]</code></li>
<li><code>using</code> <strong><code>NativeString</code></strong> <code>= [std::string on Unix, std::wstring on Windows]</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> These are defined to reflect the character types used in the
operating system's native API.</p>
</div>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>WcharEquivalent</code></strong> <code>= [char16_t or char32_t]</code></li>
<li><code>using</code> <strong><code>WstringEquivalent</code></strong> <code>= [std::u16string or std::u32string]</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> These are defined to reflect the encoding represented by <code>wchar_t</code>
and <code>std::wstring</code>. Systems where wide strings are neither UTF-16 nor UTF-32
are not supported.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;auto&gt; class</code> <strong><code>IncompleteTemplate</code></strong></li>
<li><code>class</code> <strong><code>IncompleteType</code></strong></li>
<li><code>template &lt;auto&gt; class</code> <strong><code>CompleteTemplate</code></strong></li>
<li><code>class</code> <strong><code>CompleteType</code></strong></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Dummy types used in metaprogramming. The <code>Complete</code> types are
complete but cannot be instantiated.</p>
</div>
<h3 id="integer-types">Integer types</h3>
<div class="defns">
<ul>
<li><code>enum</code> <strong><code>ByteOrder</code></strong><ul>
<li><strong><code>big_endian</code></strong></li>
<li><strong><code>little_endian</code></strong></li>
<li><strong><code>native_endian</code></strong> <code>= [big_endian or little_endian]</code></li>
</ul>
</li>
<li><code>template &lt;typename T, ByteOrder B&gt; class</code> <strong><code>Endian</code></strong><ul>
<li><code>using Endian::</code><strong><code>value_type</code></strong> <code>= T</code></li>
<li><code>static constexpr ByteOrder Endian::</code><strong><code>byte_order</code></strong> <code>= B</code></li>
<li><code>constexpr Endian::</code><strong><code>Endian</code></strong><code>() noexcept</code></li>
<li><code>constexpr Endian::</code><strong><code>~Endian</code></strong><code>() noexcept</code></li>
<li><code>constexpr Endian::</code><strong><code>Endian</code></strong><code>(const Endian&amp; e) noexcept</code></li>
<li><code>constexpr Endian::</code><strong><code>Endian</code></strong><code>(Endian&amp;&amp; e) noexcept</code></li>
<li><code>constexpr Endian&amp; Endian::</code><strong><code>operator=</code></strong><code>(const Endian&amp; e) noexcept</code></li>
<li><code>constexpr Endian&amp; Endian::</code><strong><code>operator=</code></strong><code>(Endian&amp;&amp; e) noexcept</code></li>
<li><code>constexpr Endian::</code><strong><code>Endian</code></strong><code>(T t) noexcept</code></li>
<li><code>explicit Endian::</code><strong><code>Endian</code></strong><code>(const void* p) noexcept</code></li>
<li><code>constexpr Endian::</code><strong><code>operator T</code></strong><code>() const noexcept</code></li>
<li><code>constexpr T Endian::</code><strong><code>get</code></strong><code>() const noexcept</code></li>
<li><code>constexpr const T* Endian::</code><strong><code>ptr</code></strong><code>() const noexcept</code></li>
<li><code>T* Endian::</code><strong><code>ptr</code></strong><code>() noexcept</code></li>
<li><code>constexpr T Endian::</code><strong><code>rep</code></strong><code>() const noexcept</code></li>
<li><code>T&amp; Endian::</code><strong><code>rep</code></strong><code>() noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T&gt; using</code> <strong><code>BigEndian</code></strong> <code>= Endian&lt;T, big_endian&gt;</code></li>
<li><code>template &lt;typename T&gt; using</code> <strong><code>LittleEndian</code></strong> <code>= Endian&lt;T, little_endian&gt;</code></li>
<li><code>template &lt;typename T, ByteOrder B&gt; std::ostream&amp;</code> <strong><code>operator&lt;&lt;</code></strong><code>(std::ostream&amp; out, Endian&lt;T, B&gt; t)</code></li>
<li><code>template &lt;typename T, ByteOrder B&gt; class std::</code><strong><code>hash</code></strong><code>&lt;Endian&lt;T, B&gt;&gt;</code></li>
<li><em>comparison operators between all combinations of <code>Endian</code> and <code>T</code></em></li>
</ul>
<p>An <code>Endian</code> object holds an integer in a defined byte order. This is a literal
type and can be used in <code>constexpr</code> expressions.</p>
<p>Assignment to or from an endian integer performs any necessary reordering
transparently. The default constructor sets the value to zero; the constructor
from a pointer copies <code>sizeof(T)</code> bytes into the object. The <code>ptr()</code> and
<code>rep()</code> functions give access to the internal, byte ordered form. The hash
function gives the same result as the underlying integer type's hash.</p>
</div>
<h3 id="exceptions">Exceptions</h3>
<div class="defns">
<ul>
<li><code>void</code> <strong><code>rethrow</code></strong><code>(std::exception_ptr p)</code></li>
</ul>
<p>Rethrows the exception, if one is present. This is the same as
<code>std::rethrow_exception()</code>, except that it does nothing if the exception
pointer is null.</p>
</div>
<h3 id="mixins">Mixins</h3>
<div class="defns">
<!-- DEFN -->

<p><code><span class="unicorn">[unicorn]</span></code> These are convenience base classes that define
members and operators that would normally just be repetitive boilerplate
(similar to the ones in Boost). They all use the CRTP idiom; a class <code>T</code>
should derive from <code>Mixin&lt;T&gt;</code> to automatically generate the desired
boilerplate code. The table below shows which operations the user is required
to define, and which ones the mixin will automatically define. (Here, <code>t</code> and
<code>u</code> are objects of type <code>T</code>, <code>v</code> is an object of <code>T</code>'s value type, and <code>n</code> is
an integer.)</p>
<table>
<thead>
<tr>
<th>Mixin</th>
<th>Requires</th>
<th>Defines</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>EqualityComparable</code></strong><code>&lt;T&gt;</code></td>
<td><code>t==u</code></td>
<td><code>t!=u</code></td>
</tr>
<tr>
<td><strong><code>LessThanComparable</code></strong><code>&lt;T&gt;</code></td>
<td><code>t==u, t&lt;u</code></td>
<td><code>t!=u, t&gt;u, t&lt;=u, t&gt;=u</code></td>
</tr>
<tr>
<td><strong><code>InputIterator</code></strong><code>&lt;T,CV&gt;</code></td>
<td><code>*t, ++t, t==u</code></td>
<td><code>t-&gt;, t++, t!=u</code></td>
</tr>
<tr>
<td><strong><code>OutputIterator</code></strong><code>&lt;T&gt;</code></td>
<td><code>t=v</code></td>
<td><code>*t, ++t, t++</code></td>
</tr>
<tr>
<td><strong><code>ForwardIterator</code></strong><code>&lt;T,CV&gt;</code></td>
<td><code>*t, ++t, t==u</code></td>
<td><code>t-&gt;, t++, t!=u</code></td>
</tr>
<tr>
<td><strong><code>BidirectionalIterator</code></strong><code>&lt;T,CV&gt;</code></td>
<td><code>*t, ++t, --t, t==u</code></td>
<td><code>t-&gt;, t++, t--, t!=u</code></td>
</tr>
<tr>
<td><strong><code>RandomAccessIterator</code></strong><code>&lt;T,CV&gt;</code></td>
<td><code>*t, t+=n, t-u</code></td>
<td><code>t-&gt;, t[n], ++t, t++, --t, t--, t-=n, t+n, n+t, t-n,</code><br><code>t==u, t!=u, t&lt;u, t&gt;u, t&lt;=u, t&gt;=u</code></td>
</tr>
<tr>
<td><strong><code>FlexibleRandomAccessIterator</code></strong><code>&lt;T,CV&gt;</code></td>
<td><code>*t, ++t, --t, t+=n, t-u, t==u</code></td>
<td><code>t-&gt;, t[n], t++, t--, t-=n, t+n, n+t, t-n,</code><br><code>t!=u, t&lt;u, t&gt;u, t&lt;=u, t&gt;=u</code></td>
</tr>
</tbody>
</table>
<p>In the iterator mixins, <code>CV</code> is either <code>V</code> or <code>const V</code>, where <code>V</code> is the
iterator's value type, depending on whether a mutable or const iterator is
required.</p>
<p>The first version of <code>RandomAccessIterator</code> uses the minimal set of user
supplied operations to generate all of those required;
<code>FlexibleRandomAccessIterator</code> requires more user supplied operations, but
will decay safely to one of the simpler iterator types if an underlying type
does not supply all of the corresponding operations.</p>
<p>In addition to the operators listed in the table above, all iterator mixins
supply the standard member types:</p>
<ul>
<li><code>using</code> <strong><code>difference_type</code></strong> <code>= ptrdiff_t</code></li>
<li><code>using</code> <strong><code>iterator_category</code></strong> <code>= [standard iterator tag type]</code></li>
<li><code>using</code> <strong><code>pointer</code></strong> <code>= CV*</code></li>
<li><code>using</code> <strong><code>reference</code></strong> <code>= CV&amp;</code></li>
<li><code>using</code> <strong><code>value_type</code></strong> <code>= std::remove_const_t&lt;CV&gt;</code></li>
</ul>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>NumericLimitsBase</code></strong><ul>
<li><em>Universal properties</em><ul>
<li><code>static constexpr bool is_specialized = true                                   // Always true</code></li>
<li><code>static constexpr bool is_bounded = false                                      // Finite set of values</code></li>
<li><code>static constexpr bool is_exact = false                                        // Exact representation</code></li>
<li><code>static constexpr bool is_integer = false                                      // Integer type</code></li>
<li><code>static constexpr bool is_modulo = false                                       // Modulo arithmetic</code></li>
<li><code>static constexpr bool is_signed = false                                       // Signed type</code></li>
<li><code>static constexpr bool traps = false                                           // Trap values exist</code></li>
<li><code>static constexpr int radix = 0                                                // Basis of representation</code></li>
</ul>
</li>
<li><em>Bounded type properties</em><ul>
<li><code>static constexpr int digits = 0                                               // Radix digits in significand</code></li>
<li><code>static constexpr int digits10 = 0                                             // Decimals represented without loss</code></li>
<li><code>static constexpr T lowest() noexcept { return T(); }                          // Minimum finite value</code></li>
<li><code>static constexpr T max() noexcept { return T(); }                             // Maximum finite value</code></li>
<li><code>static constexpr T min() noexcept { return T(); }                             // Minimum finite integer or positive float</code></li>
</ul>
</li>
<li><em>Floating point properties</em><ul>
<li><code>static constexpr bool has_denorm_loss = false                                 // Loss of accuracy as denormalization</code></li>
<li><code>static constexpr bool has_infinity = false                                    // Has positive infinity</code></li>
<li><code>static constexpr bool has_quiet_NaN = false                                   // Has quiet NaN</code></li>
<li><code>static constexpr bool has_signaling_NaN = false                               // Has signalling NaN</code></li>
<li><code>static constexpr bool is_iec559 = false                                       // IEC 559 standard</code></li>
<li><code>static constexpr bool tinyness_before = false                                 // Tinyness is detected before rounding</code></li>
<li><code>static constexpr int max_digits10 = 0                                         // Decimals required for different values</code></li>
<li><code>static constexpr int max_exponent = 0                                         // Maximum exponent</code></li>
<li><code>static constexpr int max_exponent10 = 0                                       // Maximum decimal exponent</code></li>
<li><code>static constexpr int min_exponent = 0                                         // Minimum exponent</code></li>
<li><code>static constexpr int min_exponent10 = 0                                       // Minimum decimal exponent</code></li>
<li><code>static constexpr std::float_denorm_style has_denorm = std::denorm_absent      // Has denormalized values</code></li>
<li><code>static constexpr std::float_round_style round_style = std::round_toward_zero  // Rounding style</code></li>
<li><code>static constexpr T denorm_min() noexcept { return T(); }                      // Minimum positive subnormal value</code></li>
<li><code>static constexpr T epsilon() noexcept { return T(); }                         // Difference between 1 and next value</code></li>
<li><code>static constexpr T infinity() noexcept { return T(); }                        // Positive infinity</code></li>
<li><code>static constexpr T quiet_NaN() noexcept { return T(); }                       // Quiet NaN</code></li>
<li><code>static constexpr T round_error() noexcept { return T(); }                     // Maximum rounding error</code></li>
<li><code>static constexpr T signaling_NaN() noexcept { return T(); }                   // Signalling NaN</code></li>
</ul>
</li>
<li><em>Helper functions</em><ul>
<li><code>protected static constexpr int digits2_to_10(size_t bits) noexcept            // Convert bit count to decimal digits</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>A convenience class to help define specializations of <code>std::numeric_limits</code>
for new arithmetic types.</p>
</div>
<h3 id="range-types">Range types</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename Iterator&gt; struct</code> <strong><code>Irange</code></strong><ul>
<li><code>using Irange::</code><strong><code>iterator</code></strong> <code>= Iterator</code></li>
<li><code>using Irange::</code><strong><code>value_type</code></strong> <code>= [Iterator's value type]</code></li>
<li><code>Iterator Irange::</code><strong><code>first</code></strong></li>
<li><code>Iterator Irange::</code><strong><code>second</code></strong></li>
<li><code>constexpr Iterator Irange::</code><strong><code>begin</code></strong><code>() const { return first; }</code></li>
<li><code>constexpr Iterator Irange::</code><strong><code>end</code></strong><code>() const { return second; }</code></li>
<li><code>constexpr bool Irange::</code><strong><code>empty</code></strong><code>() const { return first == second; }</code></li>
<li><code>constexpr size_t Irange::</code><strong><code>size</code></strong><code>() const { return std::distance(first, second); }</code></li>
</ul>
</li>
<li><code>template &lt;typename Iterator&gt; constexpr Irange&lt;Iterator&gt;</code> <strong><code>irange</code></strong><code>(const Iterator&amp; i, const Iterator&amp; j)</code></li>
<li><code>template &lt;typename Iterator&gt; constexpr Irange&lt;Iterator&gt;</code> <strong><code>irange</code></strong><code>(const pair&lt;Iterator, Iterator&gt;&amp; p)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> A wrapper for a pair of iterators, usable as a range in standard
algorithms.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename InputRange&gt; size_t</code> <strong><code>range_count</code></strong><code>(const InputRange&amp; r)</code></li>
<li><code>template &lt;typename InputRange&gt; bool</code> <strong><code>range_empty</code></strong><code>(const InputRange&amp; r)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Return the length of a range. The <code>range_count()</code> function is just
shorthand for <code>std::distance(begin(r),end(r))</code>, and <code>range_empty()</code> has the
obvious meaning.</p>
</div>
<h3 id="smart-pointers">Smart pointers</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>CopyPtr</code></strong><ul>
<li><code>using CopyPtr::</code><strong><code>element_type</code></strong> <code>= T</code></li>
<li><code>CopyPtr::</code><strong><code>CopyPtr</code></strong><code>() noexcept</code></li>
<li><code>CopyPtr::</code><strong><code>CopyPtr</code></strong><code>(T* p) noexcept</code></li>
<li><code>CopyPtr::</code><strong><code>CopyPtr</code></strong><code>(std::nullptr_t) noexcept</code></li>
<li><code>CopyPtr::</code><strong><code>CopyPtr</code></strong><code>(const CopyPtr&amp; cp)</code></li>
<li><code>CopyPtr::</code><strong><code>CopyPtr</code></strong><code>(CopyPtr&amp;&amp; cp) noexcept</code></li>
<li><code>CopyPtr::</code><strong><code>~CopyPtr</code></strong><code>() noexcept</code></li>
<li><code>CopyPtr&amp; CopyPtr::</code><strong><code>operator=</code></strong><code>(T* p) noexcept</code></li>
<li><code>CopyPtr&amp; CopyPtr::</code><strong><code>operator=</code></strong><code>(std::nullptr_t) noexcept</code></li>
<li><code>CopyPtr&amp; CopyPtr::</code><strong><code>operator=</code></strong><code>(const CopyPtr&amp; cp)</code></li>
<li><code>CopyPtr&amp; CopyPtr::</code><strong><code>operator=</code></strong><code>(CopyPtr&amp;&amp; cp) noexcept</code></li>
<li><code>T&amp; CopyPtr::</code><strong><code>operator*</code></strong><code>() const noexcept</code></li>
<li><code>T* CopyPtr::</code><strong><code>operator-&gt;</code></strong><code>() const noexcept</code></li>
<li><code>explicit CopyPtr::</code><strong><code>operator bool</code></strong><code>() const noexcept</code></li>
<li><code>T* CopyPtr::</code><strong><code>get</code></strong><code>() const noexcept</code></li>
<li><code>T* CopyPtr::</code><strong><code>release</code></strong><code>() noexcept</code></li>
<li><code>void CopyPtr::</code><strong><code>reset</code></strong><code>(T* p = nullptr) noexcept</code></li>
</ul>
</li>
<li><code>void</code> <strong><code>swap</code></strong><code>(CopyPtr&lt;T&gt;&amp; a, CopyPtr&lt;T&gt;&amp; b) noexcept</code></li>
<li><code>template &lt;typename T, typename... Args&gt; CopyPtr&lt;T&gt;</code> <strong><code>make_copy_ptr</code></strong><code>(Args&amp;&amp;... args)</code></li>
<li><code>template &lt;typename T&gt; class</code> <strong><code>ClonePtr</code></strong><ul>
<li><code>using ClonePtr::</code><strong><code>element_type</code></strong> <code>= T</code></li>
<li><code>ClonePtr::</code><strong><code>ClonePtr</code></strong><code>() noexcept</code></li>
<li><code>ClonePtr::</code><strong><code>ClonePtr</code></strong><code>(T* p) noexcept</code></li>
<li><code>ClonePtr::</code><strong><code>ClonePtr</code></strong><code>(std::nullptr_t) noexcept</code></li>
<li><code>ClonePtr::</code><strong><code>ClonePtr</code></strong><code>(const ClonePtr&amp; cp)</code></li>
<li><code>ClonePtr::</code><strong><code>ClonePtr</code></strong><code>(ClonePtr&amp;&amp; cp) noexcept</code></li>
<li><code>ClonePtr::</code><strong><code>~ClonePtr</code></strong><code>() noexcept</code></li>
<li><code>ClonePtr&amp; ClonePtr::</code><strong><code>operator=</code></strong><code>(T* p) noexcept</code></li>
<li><code>ClonePtr&amp; ClonePtr::</code><strong><code>operator=</code></strong><code>(std::nullptr_t) noexcept</code></li>
<li><code>ClonePtr&amp; ClonePtr::</code><strong><code>operator=</code></strong><code>(const ClonePtr&amp; cp)</code></li>
<li><code>ClonePtr&amp; ClonePtr::</code><strong><code>operator=</code></strong><code>(ClonePtr&amp;&amp; cp) noexcept</code></li>
<li><code>T&amp; ClonePtr::</code><strong><code>operator*</code></strong><code>() const noexcept</code></li>
<li><code>T* ClonePtr::</code><strong><code>operator-&gt;</code></strong><code>() const noexcept</code></li>
<li><code>explicit ClonePtr::</code><strong><code>operator bool</code></strong><code>() const noexcept</code></li>
<li><code>T* ClonePtr::</code><strong><code>get</code></strong><code>() const noexcept</code></li>
<li><code>T* ClonePtr::</code><strong><code>release</code></strong><code>() noexcept</code></li>
<li><code>void ClonePtr::</code><strong><code>reset</code></strong><code>(T* p = nullptr) noexcept</code></li>
</ul>
</li>
<li><code>void</code> <strong><code>swap</code></strong><code>(ClonePtr&lt;T&gt;&amp; a, ClonePtr&lt;T&gt;&amp; b) noexcept</code></li>
<li><code>template &lt;typename T, typename... Args&gt; ClonePtr&lt;T&gt;</code> <strong><code>make_clone_ptr</code></strong><code>(Args&amp;&amp;... args)</code></li>
</ul>
<p>Pointers that automatically copy their target object when the pointer is
copied, if the pointer is not null. <code>CopyPtr</code> calls <code>T</code>'s copy constructor,
while <code>ClonePtr</code> expects <code>T</code> to have a <code>clone()</code> member function that returns
a raw pointer to a newly created object. Moving a <code>CopyPtr</code> or <code>ClonePtr</code>
always leaves the moved-from pointer null.</p>
</div>
<h3 id="type-adapters">Type adapters</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T, int Def = 0&gt; struct</code> <strong><code>AutoMove</code></strong><ul>
<li><code>using AutoMove::</code><strong><code>value_type</code></strong> <code>= T</code></li>
<li><code>T AutoMove::</code><strong><code>value</code></strong></li>
<li><code>AutoMove::</code><strong><code>AutoMove</code></strong><code>()</code></li>
<li><code>AutoMove::</code><strong><code>AutoMove</code></strong><code>(const T&amp; t)</code></li>
<li><code>AutoMove::</code><strong><code>AutoMove</code></strong><code>(T&amp;&amp; t)</code></li>
<li><code>AutoMove::</code><strong><code>~AutoMove</code></strong><code>()</code></li>
<li><code>AutoMove::</code><strong><code>AutoMove</code></strong><code>(const AutoMove&amp; x)</code></li>
<li><code>AutoMove::</code><strong><code>AutoMove</code></strong><code>(AutoMove&amp;&amp; x)</code></li>
<li><code>AutoMove&amp; AutoMove::</code><strong><code>operator=</code></strong><code>(const AutoMove&amp; x)</code></li>
<li><code>AutoMove&amp; AutoMove::</code><strong><code>operator=</code></strong><code>(AutoMove&amp;&amp; x)</code></li>
</ul>
</li>
</ul>
<p>This wraps a <code>T</code> object and provides reset-on-move behaviour: <code>AutoMove&lt;T&gt;</code>'s
move constructor and move assignment operator set the value in the moved-from
object to <code>T</code>'s default value. If <code>T</code> is explicitly convertible from an <code>int</code>,
a default value other than zero can be provided. <code>AutoMove&lt;T&gt;</code> will be
copyable if <code>T</code> is copyable. (This is basically a simplified version of the
<code>Resource</code> scope guard template.)</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, int Def = 0&gt; struct</code> <strong><code>NoTransfer</code></strong><ul>
<li><code>using NoTransfer::</code><strong><code>value_type</code></strong> <code>= T</code></li>
<li><code>T NoTransfer::</code><strong><code>value</code></strong></li>
<li><code>NoTransfer::</code><strong><code>NoTransfer</code></strong><code>()</code></li>
<li><code>NoTransfer::</code><strong><code>NoTransfer</code></strong><code>(const T&amp; t)</code></li>
<li><code>NoTransfer::</code><strong><code>NoTransfer</code></strong><code>(T&amp;&amp; t)</code></li>
<li><code>NoTransfer::</code><strong><code>~NoTransfer</code></strong><code>()</code></li>
<li><code>NoTransfer::</code><strong><code>NoTransfer</code></strong><code>(const NoTransfer&amp; x)</code></li>
<li><code>NoTransfer::</code><strong><code>NoTransfer</code></strong><code>(NoTransfer&amp;&amp; x)</code></li>
<li><code>NoTransfer&amp; NoTransfer::</code><strong><code>operator=</code></strong><code>(const NoTransfer&amp; x)</code></li>
<li><code>NoTransfer&amp; NoTransfer::</code><strong><code>operator=</code></strong><code>(NoTransfer&amp;&amp; x)</code></li>
</ul>
</li>
</ul>
<p>This is more or less the reverse of <code>AutoMove</code>: the embedded value always
stays with its original <code>NoTransfer</code> object and is not moved or copied;
instead, moving or copying a <code>NoTransfer</code> sets the value of the destination
object to its default value. This is intended for data members that need to
remain associated with object identity rather than object value.</p>
</div>
<h3 id="type-names">Type names</h3>
<div class="defns">
<ul>
<li><code>std::string</code> <strong><code>demangle</code></strong><code>(const std::string&amp; name)</code></li>
<li><code>std::string</code> <strong><code>type_name</code></strong><code>(const std::type_info&amp; t)</code></li>
<li><code>std::string</code> <strong><code>type_name</code></strong><code>(const std::type_index&amp; t)</code></li>
<li><code>template &lt;typename T&gt; std::string</code> <strong><code>type_name</code></strong><code>()</code></li>
<li><code>template &lt;typename T&gt; std::string</code> <strong><code>type_name</code></strong><code>(const T&amp; t)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Demangle a type name. The original mangled name can be supplied as
an explicit string, as a <code>std::type_info</code> or <code>std:type_index</code> object, as a
type argument to a template function (e.g. <code>type_name&lt;int&gt;()</code>), or as an
object whose type is to be named (e.g. <code>type_name(42)</code>). The last version will
report the dynamic type of the referenced object.</p>
</div>
<h3 id="type-related-functions">Type related functions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T2, typename T1&gt; bool</code> <strong><code>is</code></strong><code>(const T1&amp; ref) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; bool</code> <strong><code>is</code></strong><code>(const T1* ptr) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; bool</code> <strong><code>is</code></strong><code>(const unique_ptr&lt;T1&gt;&amp; ptr) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; bool</code> <strong><code>is</code></strong><code>(const shared_ptr&lt;T1&gt;&amp; ptr) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(T1&amp; ref)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; const T2&amp;</code> <strong><code>as</code></strong><code>(const T1&amp; ref)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(T1* ptr)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; const T2&amp;</code> <strong><code>as</code></strong><code>(const T1* ptr)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(unique_ptr&lt;T1&gt;&amp; ptr)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(const unique_ptr&lt;T1&gt;&amp; ptr)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(shared_ptr&lt;T1&gt;&amp; ptr)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(const shared_ptr&lt;T1&gt;&amp; ptr)</code></li>
</ul>
<p>These are simple wrappers around <code>dynamic_cast</code>. The <code>is()</code> function returns
true if the pointer or reference's target has the requested dynamic type;
<code>as()</code> returns a reference to the object converted to the requested dynamic
type, or throws <code>std::bad_cast</code> if the <code>dynamic_cast</code> fails.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T2, typename T1&gt; T2</code> <strong><code>binary_cast</code></strong><code>(const T1&amp; t) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2</code> <strong><code>implicit_cast</code></strong><code>(const T1&amp; t)</code></li>
</ul>
<p>Type conversions. The <code>binary_cast()</code> operation does a simple bitwise copy
from one type to another; it will fail to compile if the two types have
different sizes, but does no other safety checks. The <code>implicit_cast()</code>
operation performs the conversion only if it would be allowed as an implicit
conversion.</p>
</div>
<h3 id="type-traits">Type traits</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; using</code> <strong><code>BinaryType</code></strong> <code>= [unsigned integer type]</code></li>
</ul>
<p>Yields an unsigned integer type the same size as <code>T</code>. This will fail to
compile if no such type exists.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T1, typename T2&gt; using</code> <strong><code>CopyConst</code></strong> <code>= ...</code></li>
</ul>
<p>Yields a type created by transferring the <code>const</code> qualification (or lack of
it) from <code>T1</code> to the unqualified type of <code>T2</code>. For example, <code>CopyConst&lt;int,
const string&gt;</code> yields <code>string</code>, while <code>CopyConst&lt;const int, string&gt;</code> yields
<code>const string</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;size_t Bits&gt; using</code> <strong><code>SignedInteger</code></strong> <code>= [signed integer type]</code></li>
<li><code>template &lt;size_t Bits&gt; using</code> <strong><code>UnsignedInteger</code></strong> <code>= [unsigned integer type]</code></li>
</ul>
<p>Signed and unsigned integer types with the specified number of bits (the same
types as <code>int8_t</code>, <code>int16_t</code>, etc). These will fail to compile if <code>Bits</code> is
not a power of 2 in the supported range (8-64).</p>
</div>
<h2 id="constants-and-literals">Constants and literals</h2>
<h3 id="general-constants">General constants</h3>
<div class="defns">
<ul>
<li><code>constexpr const char*</code> <strong><code>ascii_whitespace</code></strong> <code>= "\t\n\v\f\r "</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> ASCII whitespace characters.</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr bool</code> <strong><code>big_endian_target</code></strong></li>
<li><code>constexpr bool</code> <strong><code>little_endian_target</code></strong></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> One of these will be true and the other false, reflecting the
target system's byte order.</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr size_t</code> <strong><code>npos</code></strong> <code>= std::string::npos</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Defined for convenience. Following the conventions established by
the standard library, this value is often used as a function argument to mean
"as large as possible" or "no limit", or as a return value to mean "not
found".</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr bool</code> <strong><code>dependent_false</code></strong> <code>= false</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Conventional workaround for an always-false <code>static_assert()</code> in
the final <code>else</code> clause of an <code>if constexpr</code> statement.</p>
</div>
<h3 id="arithmetic-constants">Arithmetic constants</h3>
<div class="defns">
<ul>
<li><code>constexpr unsigned</code> <strong><code>KB</code></strong> <code>= 1024</code></li>
<li><code>constexpr unsigned long</code> <strong><code>MB</code></strong> <code>= 1 048 576</code></li>
<li><code>constexpr unsigned long</code> <strong><code>GB</code></strong> <code>= 1 073 741 824</code></li>
<li><code>constexpr unsigned long long</code> <strong><code>TB</code></strong> <code>= 1 099 511 627 776</code></li>
</ul>
<p>Powers of 2<sup>10</sup>.</p>
</div>
<h3 id="arithmetic-literals">Arithmetic literals</h3>
<div class="defns">
<ul>
<li><code>namespace RS::</code><strong><code>Literals</code></strong><ul>
<li><code>constexpr int8_t</code> <strong><code>operator""_s8</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr uint8_t</code> <strong><code>operator""_u8</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr int16_t</code> <strong><code>operator""_s16</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr uint16_t</code> <strong><code>operator""_u16</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr int32_t</code> <strong><code>operator""_s32</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr uint32_t</code> <strong><code>operator""_u32</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr int64_t</code> <strong><code>operator""_s64</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr uint64_t</code> <strong><code>operator""_u64</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr ptrdiff_t</code> <strong><code>operator""_pt</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr size_t</code> <strong><code>operator""_sz</code></strong><code>(unsigned long long n) noexcept</code></li>
</ul>
</li>
</ul>
<p>Integer literals.</p>
</div>
<h2 id="algorithms-and-ranges">Algorithms and ranges</h2>
<h3 id="generic-algorithms">Generic algorithms</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename Iterator&gt; void</code> <strong><code>advance_by</code></strong><code>(Iterator&amp; i, ptrdiff_t n, Iterator end)</code></li>
</ul>
<p>Advances an iterator by the given number of steps, or until it reaches <code>end</code>,
whichever comes first. This will take <code>O(1)</code> time if the iterator is random
access, otherwise <code>O(n)</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Container&gt; [output iterator]</code> <strong><code>append</code></strong><code>(Container&amp; con)</code></li>
<li><code>template &lt;typename Container&gt; [output iterator]</code> <strong><code>overwrite</code></strong><code>(Container&amp; con)</code></li>
<li><code>template &lt;typename Range, typename Container&gt; const Range&amp;</code> <strong><code>operator&gt;&gt;</code></strong><code>(const Range&amp; lhs, [append iterator] rhs)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> The <code>append()</code> and <code>overwrite()</code> functions create output iterators
that will append elements to a standard container (see <code>append_to()</code> below).
The <code>append()</code> function is similar to <code>std::back_inserter()</code> (but supports
containers without <code>push_back()</code>), while <code>overwrite()</code> will first clear the
container and then return the append iterator. There is also an operator that
can be used to copy any range into a container (e.g. <code>range &gt;&gt; append(con)</code>).</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Container, typename T&gt; void</code> <strong><code>append_to</code></strong><code>(Container&amp; con, const T&amp; t)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Appends an item to a container; used by <code>append()</code> and
<code>overwrite()</code>. The generic version calls <code>con.insert(con.end(), t)</code>; overloads
(found by argument dependent lookup) can be used for container-like types that
do not have a suitable <code>insert()</code> method.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr Irange&lt;T*&gt;</code> <strong><code>array_range</code></strong><code>(T* ptr, size_t len)</code></li>
</ul>
<p>Returns <code>irange(ptr,ptr+len)</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, size_t N&gt; constexpr std::tuple&lt;T,...&gt;</code> <strong><code>array_to_tuple</code></strong><code>(const T (&amp;array)[N])</code></li>
<li><code>template &lt;typename T, size_t N&gt; constexpr std::tuple&lt;T,...&gt;</code> <strong><code>array_to_tuple</code></strong><code>(const std::array&lt;T, N&gt; &amp;array)</code></li>
<li><code>template &lt;typename... TS&gt; std::array&lt;CT, N&gt;</code> <strong><code>tuple_to_array</code></strong><code>(const std::tuple&lt;TS...&gt;&amp; t)</code></li>
<li><code>template &lt;typename T1, typename T2&gt; std::array&lt;CT, 2&gt;</code> <strong><code>tuple_to_array</code></strong><code>(const std::pair&lt;T1, T2&gt;&amp; t)</code></li>
</ul>
<p>The <code>array_to_tuple()</code> functions convert a C-style array or a <code>std::array</code> to
a tuple containing the same values. The <code>tuple_to_array()</code> functions convert a
tuple or pair to an array containing the same values. The element type of the
resulting array is the common type of the tuple elements; <code>tuple_to_array()</code>
will fail to compile if this type does not exist.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Range&gt; [value type]</code> <strong><code>at_index</code></strong><code>(const Range&amp; r, size_t index)</code></li>
<li><code>template &lt;typename Range, typename T&gt; [value type]</code> <strong><code>at_index</code></strong><code>(const Range&amp; r, size_t index, const T&amp; def)</code></li>
</ul>
<p>Safe array access, returning the element at the given index, or the default
value (implicitly converted to the range's value type) if the index is out of
bounds. If no default value is supplied, a default constructed object of the
value type is returned. The array type can be any range with random access
iterators.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Range1, typename Range2&gt; int</code> <strong><code>compare_3way</code></strong><code>(const Range1&amp; r1, const Range2&amp; r2)</code></li>
<li><code>template &lt;typename Range1, typename Range2, typename Compare&gt; int</code> <strong><code>compare_3way</code></strong><code>(const Range1&amp; r1, const Range2&amp; r2, Compare cmp)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Compare two ranges, returning -1 if the first range is less than
the second, zero if they are equal, and +1 if the first range is greater.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename R, typename Container&gt; void</code> <strong><code>con_append</code></strong><code>(const R&amp; src, Container&amp; dst)</code></li>
<li><code>template &lt;typename R, typename Container&gt; void</code> <strong><code>con_overwrite</code></strong><code>(const R&amp; src, Container&amp; dst)</code></li>
</ul>
<p>These are just shorthand for a <code>std::copy()</code> from a range to an append or
overwrite iterator.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Container, typename T&gt; void</code> <strong><code>con_remove</code></strong><code>(Container&amp; con, const T&amp; t)</code></li>
<li><code>template &lt;typename Container, typename Predicate&gt; void</code> <strong><code>con_remove_if</code></strong><code>(Container&amp; con, Predicate p)</code></li>
<li><code>template &lt;typename Container, typename Predicate&gt; void</code> <strong><code>con_remove_if_not</code></strong><code>(Container&amp; con, Predicate p)</code></li>
<li><code>template &lt;typename Container&gt; void</code> <strong><code>con_unique</code></strong><code>(Container&amp; con)</code></li>
<li><code>template &lt;typename Container, typename BinaryPredicate&gt; void</code> <strong><code>con_unique</code></strong><code>(Container&amp; con, BinaryPredicate p)</code></li>
<li><code>template &lt;typename Container&gt; void</code> <strong><code>con_sort_unique</code></strong><code>(Container&amp; con)</code></li>
<li><code>template &lt;typename Container, typename Compare&gt; void</code> <strong><code>con_sort_unique</code></strong><code>(Container&amp; con, Compare cmp)</code></li>
<li><code>template &lt;typename Container, typename T&gt; void</code> <strong><code>con_trim</code></strong><code>(Container&amp; con, const T&amp; t)</code></li>
<li><code>template &lt;typename Container, typename Predicate&gt; void</code> <strong><code>con_trim_if</code></strong><code>(Container&amp; con, Predicate p)</code></li>
<li><code>template &lt;typename Container, typename T&gt; void</code> <strong><code>con_trim_left</code></strong><code>(Container&amp; con, const T&amp; t)</code></li>
<li><code>template &lt;typename Container, typename Predicate&gt; void</code> <strong><code>con_trim_left_if</code></strong><code>(Container&amp; con, Predicate p)</code></li>
<li><code>template &lt;typename Container, typename T&gt; void</code> <strong><code>con_trim_right</code></strong><code>(Container&amp; con, const T&amp; t)</code></li>
<li><code>template &lt;typename Container, typename Predicate&gt; void</code> <strong><code>con_trim_right_if</code></strong><code>(Container&amp; con, Predicate p)</code></li>
</ul>
<p>These carry out the same algorithms as the similarly named STL functions,
except that unwanted elements are removed from the container rather than
shuffled to the end. The <code>con_sort_unique()</code> functions perform a sort followed
by removing equivalent elements from the container; like <code>std::sort()</code>, its
predicate has less-than semantics (whereas that of <code>con_unique()</code>, like that
of <code>std::unique()</code>, has equality semantics). The <code>con_trim_*()</code> functions
remove matching elements from either or both ends of the container.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename InputRange, typename... Ranges&gt; std::vector&lt;[value type]&gt;</code> <strong><code>concatenate</code></strong><code>(const InputRange&amp; range, const Ranges&amp;... ranges)</code></li>
</ul>
<p>Returns a vector composed by concatenating all of the argument ranges. The
value type is that of the first argument range. If any subsequent argument has
a different value type, it must be assignment compatible with the first.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, typename F&gt; void</code> <strong><code>do_n</code></strong><code>(T n, F f)</code></li>
<li><code>template &lt;typename T, typename F&gt; void</code> <strong><code>for_n</code></strong><code>(T n, F f)</code></li>
</ul>
<p>These simply call the function <code>n</code> times. <code>T</code> must be an integer. The <code>do_n()</code>
loop expects a function that takes no arguments, while <code>for_n()</code> passes the
iteration count (zero to <code>n-1</code>) as an argument.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Container&gt; void</code> <strong><code>ensure_min</code></strong><code>(Container&amp; con, size_t n)</code></li>
<li><code>template &lt;typename Container, typename T&gt; void</code> <strong><code>ensure_min</code></strong><code>(Container&amp; con, size_t n, const T&amp; t)</code></li>
<li><code>template &lt;typename Container&gt; void</code> <strong><code>ensure_max</code></strong><code>(Container&amp; con, size_t n)</code></li>
</ul>
<p>If <code>con.size()&lt;n</code>, <code>ensure_min()</code> calls <code>con.resize(n[,t])</code>; otherwise, it
does nothing. If <code>con.size()&gt;n</code>, <code>ensure_max()</code> calls <code>con.resize(n)</code>;
otherwise, it does nothing.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename M, typename K&gt; const M::mapped_type&amp;</code> <strong><code>find_in_map</code></strong><code>(const M&amp; map, const K&amp; key)</code></li>
<li><code>template &lt;typename M, typename K&gt; const M::mapped_type&amp;</code> <strong><code>find_in_map</code></strong><code>(const M&amp; map, const K&amp; key, const M::mapped_type&amp; def)</code></li>
</ul>
<p>Find a key in a map, returning the corresponding value, or the supplied
default value (or a default constructed <code>mapped_type</code>) if the key is not
found.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename M, typename K&gt; M::iterator</code> <strong><code>find_key_range</code></strong><code>(M&amp; map, const K&amp; key)</code></li>
<li><code>template &lt;typename M, typename K&gt; M::const_iterator</code> <strong><code>find_key_range</code></strong><code>(const M&amp; map, const K&amp; key)</code></li>
</ul>
<p>Find the map entry matching a key, assuming the key represents the minimum
value of a range. This will return the exact matching key if there is one,
otherwise it will return the last key that is less than the target key, or
<code>map.end()</code> if there is no such key.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename BidirectionalIterator, typename T&gt; BidirectionalIterator</code> <strong><code>find_last</code></strong><code>(BidirectionalIterator i, BidirectionalIterator j, const T&amp; t)</code><ul>
<li><em>Find the last element equal to the given value</em></li>
</ul>
</li>
<li><code>template &lt;typename BidirectionalIterator, typename T&gt; BidirectionalIterator</code> <strong><code>find_last_not</code></strong><code>(BidirectionalIterator i, BidirectionalIterator j, const T&amp; t)</code><ul>
<li><em>Find the last element not equal to the given value</em></li>
</ul>
</li>
<li><code>template &lt;typename BidirectionalIterator, typename UnaryPredicate&gt; BidirectionalIterator</code> <strong><code>find_last_if</code></strong><code>(BidirectionalIterator i, BidirectionalIterator j, UnaryPredicate p)</code><ul>
<li><em>Find the last element that matches the predicate</em></li>
</ul>
</li>
<li><code>template &lt;typename BidirectionalIterator, typename UnaryPredicate&gt; BidirectionalIterator</code> <strong><code>find_last_if_not</code></strong><code>(BidirectionalIterator i, BidirectionalIterator j, UnaryPredicate p)</code><ul>
<li><em>Find the last element that does not match the predicate</em></li>
</ul>
</li>
<li><code>template &lt;typename InputIterator, typename T&gt; InputIterator</code> <strong><code>find_not</code></strong><code>(InputIterator i, InputIterator j, const T&amp; t)</code><ul>
<li><em>Find the first element not equal to the given value</em></li>
</ul>
</li>
</ul>
<p>Additional find algorithms. All of these return the end iterator if the search
fails.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Range1, typename Range2&gt; bool</code> <strong><code>sets_intersect</code></strong><code>(const Range1&amp; r1, const Range2&amp; r2)</code></li>
<li><code>template &lt;typename Range1, typename Range2, typename Compare&gt; bool</code> <strong><code>sets_intersect</code></strong><code>(const Range1&amp; r1, const Range2&amp; r2, Compare c)</code></li>
</ul>
<p>Test whether two ordered ranges (sets) have any elements in common. The ranges
are assumed to be ordered in accordance with the comparison predicate.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename... Args&gt; void</code> <strong><code>sort_list</code></strong><code>(Args&amp;... args)</code></li>
<li><code>template &lt;typename Compare, typename... Args&gt; void</code> <strong><code>sort_list_by</code></strong><code>(Compare c, Args&amp;... args)</code></li>
</ul>
<p>Sort an explicit list of variables.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename InputRange&gt; [value type]</code> <strong><code>sum_of</code></strong><code>(const InputRange&amp; r)</code></li>
<li><code>template &lt;typename InputRange&gt; [value type]</code> <strong><code>product_of</code></strong><code>(const InputRange&amp; r)</code></li>
</ul>
<p>Simple range sum and product functions, to save the trouble of calling
<code>std::accumulate()</code> in trivial cases. Calling <code>sum_of()</code> on an empty range
will return a default constructed value. The value type of <code>product_of()</code> must
be constructible by a <code>static_cast</code> from <code>int</code>; an empty range will return 1.</p>
</div>
<h3 id="integer-sequences">Integer sequences</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>iseq</code></strong><code>(T stop) noexcept</code></li>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>iseq</code></strong><code>(T init, T stop) noexcept</code></li>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>iseq</code></strong><code>(T init, T stop, T delta) noexcept</code></li>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>xseq</code></strong><code>(T stop) noexcept</code></li>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>xseq</code></strong><code>(T init, T stop) noexcept</code></li>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>xseq</code></strong><code>(T init, T stop, T delta) noexcept</code></li>
</ul>
<p>Linear sequences of integers (<code>T</code> must be an integer type). The generated
range starts with <code>init</code> (defaulting to zero) and runs to <code>stop</code>, in steps of
<code>delta</code> (defaulting to 1). The <code>iseq()</code> function produces an inclusive
(closed) sequence that includes <code>stop</code>, while <code>xseq()</code> is an exclusive (half
open) sequence that excludes it (if the exact value <code>stop</code> would never be
generated, because <code>stop-init</code> is not a multiple of <code>delta</code>, there is no
difference between the two).</p>
<p>If <code>stop=init</code>, or if <code>delta=0</code>, the <code>iseq()</code> sequence contains a single
value, while the <code>xseq()</code> sequence is empty. Both sequences will be empty if
<code>stop-init</code> and <code>delta</code> have opposite signs.</p>
<p>The iterators must be able to generate a value beyond the end of the sequence
in order to check for an end iterator; for <code>iseq()</code>, this means that
<code>stop+delta</code> must be in range for <code>T</code>.</p>
</div>
<h3 id="memory-algorithms">Memory algorithms</h3>
<div class="defns">
<ul>
<li><code>int</code> <strong><code>mem_compare</code></strong><code>(const void* lhs, size_t n1, const void* rhs, size_t n2) noexcept</code></li>
</ul>
<p>This returns -1 if the first block is less than the second (by a
lexicographical bytewise comparison), 0 if they are equal, 1 if the first is
greater than the second. If the two blocks are equal up to the length of the
shorter one, the shorter is considered less than the longer. This is similar
to <code>memcmp()</code>, except that the memory blocks being compared may have different
lengths. A null pointer is treated as less than any non-null pointer; the
length accompanying a null pointer is ignored.</p>
</div>
<div class="defns">
<ul>
<li><code>size_t</code> <strong><code>mem_match</code></strong><code>(const void* lhs, const void* rhs, size_t n) noexcept</code></li>
</ul>
<p>Returns the number of leading bytes the two blocks have in common. This will
return zero if either pointer is null.</p>
</div>
<div class="defns">
<ul>
<li><code>void</code> <strong><code>mem_swap</code></strong><code>(void* ptr1, void* ptr2, size_t n) noexcept</code></li>
</ul>
<p>Swap two blocks of memory. This will work if the two ranges overlap or are the
same, but behaviour is undefined if either pointer is null.</p>
</div>
<h2 id="arithmetic-functions">Arithmetic functions</h2>
<h3 id="generic-arithmetic-functions">Generic arithmetic functions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; pair&lt;T, T&gt;</code> <strong><code>divide</code></strong><code>(T x, T y) noexcept</code></li>
<li><code>template &lt;typename T&gt; T</code> <strong><code>quo</code></strong><code>(T x, T y) noexcept</code></li>
<li><code>template &lt;typename T&gt; T</code> <strong><code>rem</code></strong><code>(T x, T y) noexcept</code></li>
</ul>
<p>These perform Euclidean division: if the division is not exact, the remainder
is always positive (regardless of the signs of the arguments), and the
quotient is the integer that satisfies <code>x=q*y+r</code> (apart from rounding errors).
The pair returned by <code>divide()</code> contains the quotient and remainder. For all
three functions, behaviour is undefined if <code>y=0</code> or the quotient is out of
<code>T</code>'s representable range.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; std::pair&lt;T, T&gt;</code> <strong><code>symmetric_divide</code></strong><code>(T x, T y) noexcept</code></li>
<li><code>template &lt;typename T&gt; T</code> <strong><code>symmetric_quotient</code></strong><code>(T x, T y) noexcept</code></li>
<li><code>template &lt;typename T&gt; T</code> <strong><code>symmetric_remainder</code></strong><code>(T x, T y) noexcept</code></li>
</ul>
<p>These perform the same operations as the division functions above, except that
the remainder is constrained to <code>(-|y|/2,|y|/2]</code> instead of <code>[0,|y|)</code>.
Behaviour is undefined if <code>y=0</code> or the quotient is out of <code>T</code>'s representable
range. These functions do not make sense (and will not compile) if <code>T</code> is
unsigned.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; T</code> <strong><code>shift_left</code></strong><code>(T t, int n) noexcept</code></li>
<li><code>template &lt;typename T&gt; T</code> <strong><code>shift_right</code></strong><code>(T t, int n) noexcept</code></li>
</ul>
<p>Multiply or divide <code>t</code> by <code>2<sup>n</sup></code>. <code>T</code> may be an integer or
floating point type. Results are unspecified if the correct result would be
out of <code>T</code>'s representable range.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; int</code> <strong><code>sign_of</code></strong><code>(T t) noexcept</code></li>
</ul>
<p>Returns 1 if the argument is positive, 0 if zero, and -1 if negative.</p>
</div>
<h3 id="integer-arithmetic-functions">Integer arithmetic functions</h3>
<p>For the bit manipulation functions (<code>ibits()</code>, <code>ifloor2()</code>, <code>iceil2()</code>,
<code>ilog2p1()</code>, <code>ispow2()</code>, <code>rotl()</code>, and <code>rotr()</code>), behaviour is undefined if
<code>T</code> is not an integer, or if <code>T</code> is signed and the argument is negative.</p>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr std::make_signed_t&lt;T&gt;</code> <strong><code>as_signed</code></strong><code>(T t) noexcept</code></li>
<li><code>template &lt;typename T&gt; constexpr std::make_unsigned_t&lt;T&gt;</code> <strong><code>as_unsigned</code></strong><code>(T t) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> These return their argument converted to a signed or unsigned
value of the same size (the argument is returned unchanged if <code>T</code> already had
the desired signedness). Behaviour is undefined if <code>T</code> is not an integer or
enumeration type.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>binomial</code></strong><code>(T a, T b) noexcept</code></li>
<li><code>double</code> <strong><code>xbinomial</code></strong><code>(int a, int b) noexcept</code></li>
</ul>
<p>These return the binomial coefficient (<code>a!/b!(a-b)!</code> if <code>0&lt;=b&lt;=a</code>, otherwise
zero). <code>T</code> must be an integer type. Behaviour is undefined if the correct
result would be out of range for the return type.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>gcd</code></strong><code>(T a, T b) noexcept</code></li>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>lcm</code></strong><code>(T a, T b) noexcept</code></li>
</ul>
<p>Return the greatest common divisor or lowest common multiple of two numbers.
These give the same results as <code>std::gcd/lcm()</code>, but without checking that <code>T</code>
is a primitive integral type, so these will work with user defined integer
types.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr int</code> <strong><code>ibits</code></strong><code>(T t) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Returns the number of 1 bits in the argument.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>ifloor2</code></strong><code>(T t) noexcept</code></li>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>iceil2</code></strong><code>(T t) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Return the argument rounded down or up to a power of 2. For
<code>iceil2()</code>, behaviour is undefined if the argument is large enough that the
correct answer is not representable.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr int</code> <strong><code>ilog2p1</code></strong><code>(T t) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Returns <code>floor(log2(t))+1</code>, equal to the number of significant
bits in <code>t</code>, or zero if <code>t</code> is zero.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T1, typename T2&gt; constexpr T1</code> <strong><code>int_power</code></strong><code>(T1 x, T2 y) noexcept</code></li>
</ul>
<p>Calculates <code>x<sup>y</sup></code> for integer types
(<code>0<sup>0</sup></code> will return 1). Behaviour is undefined if <code>y</code> is
negative, if the true result would be out of range for <code>T1</code>, or if either type
is not an integer.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>int_sqrt</code></strong><code>(T t) noexcept</code></li>
</ul>
<p>Returns the integer square root of the argument (the true square root
truncated to an integer). Behaviour is undefined if the argument is negative.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr bool</code> <strong><code>ispow2</code></strong><code>(T t) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> True if the argument is an exact power of 2.</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr uint64_t</code> <strong><code>letter_to_mask</code></strong><code>(char c) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Converts a letter to a mask with bit 0-51 set (corresponding to
<code>[A-Za-z]</code>). Returns zero if the argument is not an ASCII letter.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>rotl</code></strong><code>(T t, int n) noexcept</code></li>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>rotr</code></strong><code>(T t, int n) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Bitwise rotate left or right. The bit count is reduced modulo the
number of bits in <code>T</code>; a negative shift in one direction is treated as a
positive shift in the other.</p>
</div>
<h2 id="date-and-time-functions">Date and time functions</h2>
<h3 id="constants">Constants</h3>
<div class="defns">
<ul>
<li><code>constexpr uint32_t</code> <strong><code>utc_zone</code></strong></li>
<li><code>constexpr uint32_t</code> <strong><code>local_zone</code></strong></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Used to indicate whether a date is expressed in UTC or the local
time zone.</p>
</div>
<h3 id="conversion-functions">Conversion functions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename R, typename P&gt; void</code> <strong><code>from_seconds</code></strong><code>(double s, duration&lt;R, P&gt;&amp; d) noexcept</code></li>
<li><code>template &lt;typename R, typename P&gt; double</code> <strong><code>to_seconds</code></strong><code>(const duration&lt;R, P&gt;&amp; d) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Convenience functions to convert between a <code>duration</code> and a
floating point number of seconds.</p>
</div>
<div class="defns">
<ul>
<li><code>system_clock::time_point</code> <strong><code>make_date</code></strong><code>(int year, int month, int day, int hour = 0, int min = 0, double sec = 0, uint32_t flags = utc_zone)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Converts a broken down date into a time point. Behaviour if any of
the date arguments are invalid follows the same rules as <code>mktime()</code>. This will
throw <code>std::invalid_argument</code> if an invalid flag is passed.</p>
</div>
<h3 id="formatting-functions">Formatting functions</h3>
<div class="defns">
<ul>
<li><code>Ustring</code> <strong><code>format_date</code></strong><code>(system_clock::time_point tp, int prec = 0, uint32_t flags = utc_zone)</code></li>
<li><code>Ustring</code> <strong><code>format_date</code></strong><code>(system_clock::time_point tp, Uview format, uint32_t flags = utc_zone)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> These convert a time point into a broken down date and format it.
The first version writes the date in ISO 8601 format (<code>"yyyy-mm-dd
hh:mm:ss"</code>). If <code>prec</code> is greater than zero, the specified number of decimal
places will be added to the seconds field.</p>
<p>The second version writes the date using the conventions of <code>strftime()</code>. This
will return an empty string if anything goes wrong (there is no way to
distinguish between a conversion error and a legitimately empty result; this
is a limitation of <code>strftime()</code>).</p>
<p>Both of these will throw <code>std::invalid_argument</code> if an invalid flag is passed.</p>
<p>For reference, the portable subset of the <code>strftime()</code> formatting codes are:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Date elements</strong></td>
<td></td>
<td><strong>Weekday elements</strong></td>
<td></td>
</tr>
<tr>
<td><code>%Y</code></td>
<td>Year number</td>
<td><code>%a</code></td>
<td>Local weekday abbreviation</td>
</tr>
<tr>
<td><code>%y</code></td>
<td>Last 2 digits of the year (<code>00-99</code>)</td>
<td><code>%w</code></td>
<td>Sunday-based weekday number (<code>0-6</code>)</td>
</tr>
<tr>
<td><code>%m</code></td>
<td>Month number (<code>00-12</code>)</td>
<td><code>%A</code></td>
<td>Local weekday name</td>
</tr>
<tr>
<td><code>%B</code></td>
<td>Local month name</td>
<td><code>%U</code></td>
<td>Sunday-based week number (<code>00-53</code>)</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>Local month abbreviation</td>
<td><code>%W</code></td>
<td>Monday-based week number (<code>00-53</code>)</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>Day of the month (<code>01-31</code>)</td>
<td><strong>Other elements</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Time of day elements</strong></td>
<td></td>
<td><code>%c</code></td>
<td>Local standard date/time format</td>
</tr>
<tr>
<td><code>%H</code></td>
<td>Hour on 24-hour clock (<code>00-23</code>)</td>
<td><code>%x</code></td>
<td>Local standard date format</td>
</tr>
<tr>
<td><code>%I</code></td>
<td>Hour on 12-hour clock (<code>01-12</code>)</td>
<td><code>%X</code></td>
<td>Local standard time format</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>Local equivalent of a.m./p.m.</td>
<td><code>%j</code></td>
<td>Day of the year (<code>001-366</code>)</td>
</tr>
<tr>
<td><code>%M</code></td>
<td>Minute (<code>00-59</code>)</td>
<td><code>%Z</code></td>
<td>Time zone name</td>
</tr>
<tr>
<td><code>%S</code></td>
<td>Second (<code>00-60</code>)</td>
<td><code>%z</code></td>
<td>Time zone offset</td>
</tr>
</tbody>
</table>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename R, typename P&gt; Ustring</code> <strong><code>format_time</code></strong><code>(const duration&lt;R, P&gt;&amp; time, int prec = 0)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Formats a time duration in days, hours, minutes, seconds, and (if
<code>prec&gt;0</code>) fractions of a second.</p>
</div>
<h2 id="error-handling">Error handling</h2>
<h3 id="assertion-functions">Assertion functions</h3>
<div class="defns">
<ul>
<li><code>void</code> <strong><code>runtime_assert</code></strong><code>(bool condition, std::string_view message) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> A portable, non-blockable version of <code>assert()</code>. If the condition
is false, this will print the message to standard error (followed by a line
break), and then call <code>abort()</code>.</p>
</div>
<h2 id="functional-utilities">Functional utilities</h2>
<h3 id="function-traits">Function traits</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename Function&gt; struct</code> <strong><code>Arity</code></strong><ul>
<li><code>static constexpr size_t Arity::</code><strong><code>value</code></strong></li>
</ul>
</li>
<li><code>template &lt;typename Function&gt; using</code> <strong><code>ArgumentTuple</code></strong> <code>= [tuple type]</code></li>
<li><code>template &lt;typename Function, size_t Index&gt; using</code> <strong><code>ArgumentType</code></strong> <code>= [type of given argument]</code></li>
<li><code>template &lt;typename Function&gt; using</code> <strong><code>ReturnType</code></strong> <code>= [return type]</code></li>
<li><code>template &lt;typename Function&gt; using</code> <strong><code>FunctionSignature</code></strong> <code>= [result(args...)]</code></li>
<li><code>template &lt;typename Function&gt; using</code> <strong><code>StdFunction</code></strong> <code>= function&lt;FunctionSignature&lt;Function&gt;&gt;</code></li>
</ul>
<p>Properties of a function type. This will work with ordinary functions (if not
overloaded), function pointers, function objects, lambda expressions, and
<code>std::function</code> instantiations.</p>
</div>
<h3 id="function-operations">Function operations</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename Function&gt; StdFunction&lt;Function&gt;</code> <strong><code>stdfun</code></strong><code>(Function&amp; f)</code></li>
</ul>
<p>Wraps a function in the appropriate standard function type.</p>
</div>
<div class="defns">
<ul>
<li><code>template&lt;typename Function, typename Tuple&gt; decltype(auto)</code> <strong><code>tuple_invoke</code></strong><code>(Function&amp;&amp; f, Tuple&amp;&amp; t)</code></li>
</ul>
<p>Calls a function, passing a tuple as the argument list.</p>
</div>
<h3 id="generic-function-objects">Generic function objects</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename Signature&gt; class</code> <strong><code>CallRef</code></strong><ul>
<li><code>using CallRef::</code><strong><code>function_type</code></strong> <code>= std::function&lt;Signature&gt;</code></li>
<li><code>using CallRef::</code><strong><code>signature_type</code></strong> <code>= Signature</code></li>
<li><code>CallRef::</code><strong><code>CallRef</code></strong><code>() noexcept</code></li>
<li><code>CallRef::</code><strong><code>CallRef</code></strong><code>(std::nullptr_t) noexcept</code></li>
<li><code>template &lt;typename F&gt; CallRef::</code><strong><code>CallRef</code></strong><code>(F f)</code></li>
<li><code>CallRef::</code><strong><code>~CallRef</code></strong><code>() noexcept</code></li>
<li><code>CallRef::</code><strong><code>CallRef</code></strong><code>(const CallRef&amp; cr)</code></li>
<li><code>CallRef::</code><strong><code>CallRef</code></strong><code>(CallRef&amp;&amp; cr) noexcept</code></li>
<li><code>CallRef&amp; CallRef::</code><strong><code>operator=</code></strong><code>(const CallRef&amp; cr)</code></li>
<li><code>CallRef&amp; CallRef::</code><strong><code>operator=</code></strong><code>(CallRef&amp;&amp; cr) noexcept</code></li>
<li><code>explicit CallRef::</code><strong><code>operator bool</code></strong><code>() const noexcept</code></li>
<li><code>template &lt;typename... Args&gt; [return type] CallRef::</code><strong><code>operator()</code></strong><code>(Args... args) const</code></li>
</ul>
</li>
</ul>
<p>A function wrapper with reference semantics (a thin wrapper around
<code>std::shared_ptr&lt;std::function&lt;Signature&gt;&gt;</code>), intended to make it easier to
use heavyweight function objects where copying them around would impose too
much overhead. Like <code>std::function</code>, invoking a null <code>CallRef</code> will throw
<code>std::bad_function_call</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>struct</code> <strong><code>DoNothing</code></strong><ul>
<li><code>void</code> <strong><code>operator()</code></strong><code>() const noexcept {}</code></li>
<li><code>template &lt;typename T&gt; void</code> <strong><code>operator()</code></strong><code>(T&amp;) const noexcept {}</code></li>
<li><code>template &lt;typename T&gt; void</code> <strong><code>operator()</code></strong><code>(const T&amp;) const noexcept {}</code></li>
</ul>
</li>
<li><code>constexpr DoNothing</code> <strong><code>do_nothing</code></strong></li>
<li><code>struct</code> <strong><code>Identity</code></strong><ul>
<li><code>template &lt;typename T&gt; T&amp;</code> <strong><code>operator()</code></strong><code>(T&amp; t) const noexcept { return t; }</code></li>
<li><code>template &lt;typename T&gt; const T&amp;</code> <strong><code>operator()</code></strong><code>(const T&amp; t) const noexcept { return t; }</code></li>
</ul>
</li>
<li><code>constexpr Identity</code> <strong><code>identity</code></strong></li>
</ul>
<p>Trivial function objects.</p>
</div>
<div class="defns">
<ul>
<li><code>struct</code> <strong><code>RangeEqual</code></strong><ul>
<li><code>template &lt;typename Range&gt; bool RangeEqual::</code><strong><code>operator()</code></strong><code>(const Range&amp; r1, const Range&amp; r2) const</code></li>
</ul>
</li>
<li><code>struct</code> <strong><code>RangeCompare</code></strong><ul>
<li><code>template &lt;typename Range&gt; bool RangeCompare::</code><strong><code>operator()</code></strong><code>(const Range&amp; r1, const Range&amp; r2) const</code></li>
</ul>
</li>
<li><code>constexpr RangeEqual</code> <strong><code>range_equal</code></strong></li>
<li><code>constexpr RangeCompare</code> <strong><code>range_compare</code></strong></li>
</ul>
<p>Range comparison objects. These call <code>std::equal()</code> and
<code>std::lexicographical_compare()</code> respectively.</p>
</div>
<h3 id="hash-functions">Hash functions</h3>
<div class="defns">
<ul>
<li><code>size_t</code> <strong><code>hash_mix</code></strong><code>(size_t h1, size_t h2) noexcept</code></li>
</ul>
<p>Combine two hash values.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename... Args&gt; size_t</code> <strong><code>hash_value</code></strong><code>(const Args&amp;... args) noexcept</code></li>
<li><code>template &lt;typename... Args&gt; void</code> <strong><code>hash_combine</code></strong><code>(size_t&amp; hash, const Args&amp;... args) noexcept</code></li>
<li><code>template &lt;typename InputRange&gt; size_t</code> <strong><code>hash_range</code></strong><code>(const InputRange&amp; range) noexcept</code></li>
<li><code>template &lt;typename InputRange&gt; void</code> <strong><code>hash_range</code></strong><code>(size_t&amp; hash, const InputRange&amp; range) noexcept</code></li>
</ul>
<p>Functions for combining hashes incrementally, or for generating the hash of a
number of objects in one call, for use in implementing hash functions for
compound types. The first version of each pair of functions (<code>hash_value()</code>
and <code>hash_combine()</code> have different names to avoid overload resolution
problems) calculates the hash of the supplied data; the second version takes
an existing hash value and mixes it with additional data. All of these call
the element type's <code>std::hash</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; size_t</code> <strong><code>std_hash</code></strong><code>(const T&amp; t) noexcept</code></li>
</ul>
<p>This simply calls <code>std::hash&lt;T&gt;::operator()</code> on its argument.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename... Args&gt; struct</code> <strong><code>TupleHash</code></strong><ul>
<li><code>size_t</code> <strong><code>operator()</code></strong><code>(const tuple&lt;Args...&gt;&amp; t) const</code></li>
</ul>
</li>
</ul>
<p>Hash function for a tuple.</p>
</div>
<h3 id="scope-guards">Scope guards</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; std::unique_lock&lt;T&gt;</code> <strong><code>make_lock</code></strong><code>(T&amp; t)</code></li>
<li><code>template &lt;typename T&gt; std::shared_lock&lt;T&gt;</code> <strong><code>make_shared_lock</code></strong><code>(T&amp; t)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Simple wrapper functions to create a mutex lock.</p>
</div>
<div class="defns">
<ul>
<li><code>enum class</code> <strong><code>Scope</code></strong><ul>
<li><code>Scope::</code><strong><code>exit</code></strong></li>
<li><code>Scope::</code><strong><code>fail</code></strong></li>
<li><code>Scope::</code><strong><code>success</code></strong></li>
</ul>
</li>
<li><code>template &lt;typename F, Scope S&gt; class</code> <strong><code>BasicScopeGuard</code></strong><ul>
<li><code>BasicScopeGuard::</code><strong><code>BasicScopeGuard</code></strong><code>() noexcept</code></li>
<li><code>BasicScopeGuard::</code><strong><code>BasicScopeGuard</code></strong><code>(F&amp;&amp; f)</code></li>
<li><code>BasicScopeGuard::</code><strong><code>BasicScopeGuard</code></strong><code>(BasicScopeGuard&amp;&amp; sg) noexcept</code></li>
<li><code>BasicScopeGuard::</code><strong><code>~BasicScopeGuard</code></strong><code>() noexcept</code></li>
<li><code>BasicScopeGuard&amp; BasicScopeGuard::</code><strong><code>operator=</code></strong><code>(F&amp;&amp; f)</code></li>
<li><code>BasicScopeGuard&amp; BasicScopeGuard::</code><strong><code>operator=</code></strong><code>(BasicScopeGuard&amp;&amp; sg) noexcept</code></li>
<li><code>void BasicScopeGuard::</code><strong><code>release</code></strong><code>() noexcept</code></li>
</ul>
</li>
<li><code>using</code> <strong><code>ScopeExit</code></strong> <code>= BasicScopeGuard&lt;std::function&lt;void()&gt;, Scope::exit&gt;</code></li>
<li><code>using</code> <strong><code>ScopeFail</code></strong> <code>= BasicScopeGuard&lt;std::function&lt;void()&gt;, Scope::fail&gt;</code></li>
<li><code>using</code> <strong><code>ScopeSuccess</code></strong> <code>= BasicScopeGuard&lt;std::function&lt;void()&gt;, Scope::success&gt;</code></li>
<li><code>template &lt;typename F&gt; BasicScopeGuard&lt;F, Scope::exit&gt;</code> <strong><code>scope_exit</code></strong><code>(F&amp;&amp; f)</code></li>
<li><code>template &lt;typename F&gt; BasicScopeGuard&lt;F, Scope::fail&gt;</code> <strong><code>scope_fail</code></strong><code>(F&amp;&amp; f)</code></li>
<li><code>template &lt;typename F&gt; BasicScopeGuard&lt;F, Scope::success&gt;</code> <strong><code>scope_success</code></strong><code>(F&amp;&amp; f)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> The scope guard class stores a function object, to be called when
the guard is destroyed. The three functions create scope guards with different
execution conditions. The three named specializations are conveniences for
when a scope guard needs to be stored as a movable object.</p>
<p>A <strong>scope exit</strong> guard calls the function unconditionally; <strong>scope success</strong>
calls it only on normal exit, but not when unwinding due to an exception;
<strong>scope fail</strong> calls it only when an exception causes stack unwinding, but not
on normal exit. If the constructor or creation function throws an exception
(this is only possible if the function object's move constructor or assignment
operator throws), <strong>scope exit</strong> and <strong>scope fail</strong> will call the function
before propagating the exception, while <strong>scope success</strong> will not. Any
exceptions thrown by the function call in the scope guard's destructor are
silently ignored (normally the function should be written so as not to throw
anything).</p>
<p>The <code>release()</code> function discards the saved function; after it is called, the
scope guard object will do nothing on destruction.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, int Def = 0&gt; class</code> <strong><code>Resource</code></strong><ul>
<li><code>using Resource::</code><strong><code>delete_function</code></strong> <code>= std::function&lt;void(T&amp;)&gt;</code></li>
<li><code>using Resource::</code><strong><code>resource_type</code></strong> <code>= T</code></li>
<li><code>using Resource::</code><strong><code>value_type</code></strong> <code>= [dereferenced T]</code> <em>[only if T is a pointer]</em></li>
<li><code>Resource::</code><strong><code>Resource</code></strong><code>() noexcept</code></li>
<li><code>explicit Resource::</code><strong><code>Resource</code></strong><code>(T t) noexcept</code></li>
<li><code>template &lt;typename Del&gt; Resource::</code><strong><code>Resource</code></strong><code>(T t, Del d)</code></li>
<li><code>Resource::</code><strong><code>Resource</code></strong><code>(Resource&amp;&amp; r) noexcept</code></li>
<li><code>Resource::</code><strong><code>~Resource</code></strong><code>() noexcept</code></li>
<li><code>Resource&amp; Resource::</code><strong><code>operator=</code></strong><code>(Resource&amp;&amp; r) noexcept</code></li>
<li><code>explicit Resource::</code><strong><code>operator bool</code></strong><code>() const noexcept</code></li>
<li><code>value_type&amp; Resource::</code><strong><code>operator*</code></strong><code>() noexcept</code> <em>[only if T is a non-void pointer]</em></li>
<li><code>const value_type&amp; Resource::</code><strong><code>operator*</code></strong><code>() const noexcept</code> <em>[only if T is a non-void pointer]</em></li>
<li><code>T Resource::</code><strong><code>operator-&gt;</code></strong><code>() const noexcept</code> <em>[only if T is a non-void pointer]</em></li>
<li><code>T&amp; Resource::</code><strong><code>get</code></strong><code>() noexcept</code></li>
<li><code>T Resource::</code><strong><code>get</code></strong><code>() const noexcept</code></li>
<li><code>T Resource::</code><strong><code>release</code></strong><code>() noexcept</code></li>
<li><code>void Resource::</code><strong><code>reset</code></strong><code>() noexcept</code></li>
<li><code>void Resource::</code><strong><code>reset</code></strong><code>(T t) noexcept</code></li>
<li><code>static T Resource::</code><strong><code>def</code></strong><code>() noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T, typename Del&gt; Resource&lt;T&gt;</code> <strong><code>make_resource</code></strong><code>(T t, Del d)</code></li>
</ul>
<p>This holds a resource of some kind, a deleter function that will be called on
destruction (similar to a <code>unique_ptr</code>), and optionally a default value (only
usable if <code>T</code> is constructible from an <code>int</code>). <code>T</code> is assumed to be copyable
and movable without throwing; normally it will be a primitive object such as a
pointer or integer.</p>
<p>The deleter function passed to the constructor is expected to take a single
argument of type <code>T</code>; it defaults to a null function. The destructor will call
<code>d(t)</code>, unless the resource value is equal to the default or the deleter is
null. The constructor will call <code>d(t)</code> if anything goes wrong, with the same
constraints (this can only happen if copying <code>D</code> throws).</p>
<p>The <code>def()</code> function returns the default value of <code>T</code>, which is <code>T(Def)</code> if
<code>T</code> is constructible from an <code>int</code>, otherwise <code>T()</code>. The boolean conversion
operator returns true if the stored value is not equal to the default (note
that this may give a different result from <code>bool(T)</code>).</p>
</div>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>ScopedTransaction</code></strong><ul>
<li><code>using ScopedTransaction::</code><strong><code>callback</code></strong> <code>= function&lt;void()&gt;</code></li>
<li><code>ScopedTransaction::</code><strong><code>ScopedTransaction</code></strong><code>() noexcept</code></li>
<li><code>ScopedTransaction::</code><strong><code>~ScopedTransaction</code></strong><code>() noexcept</code></li>
<li><code>void ScopedTransaction::</code><strong><code>operator()</code></strong><code>(callback func, callback undo)</code></li>
<li><code>void ScopedTransaction::</code><strong><code>commit</code></strong><code>() noexcept</code></li>
<li><code>void ScopedTransaction::</code><strong><code>rollback</code></strong><code>() noexcept</code></li>
</ul>
</li>
</ul>
<p>This holds a stack of "undo" operations, to be carried out if anything goes
wrong during a sequence of operations. The function call operator accepts two
function objects; <code>func()</code> is called immediately, while <code>undo()</code> is saved on
the stack. If <code>func()</code> throws an exception, its <code>undo()</code> is not called, but
any pre-existing undo stack is invoked. Either function can be a null pointer
if no action is required.</p>
<p>Calling <code>commit()</code> discards the saved undo functions; <code>rollback()</code> calls them
in reverse order of insertion, silently ignoring any exceptions (normally the
undo functions should be written so as not to throw anything). The destructor
will perform a rollback if neither <code>commit()</code> nor <code>rollback()</code> have been
called since the last new call.</p>
<p>A single <code>ScopedTransaction</code> object can be used for multiple transactions.
Once <code>commit()</code> or <code>rollback()</code> is called, the undo stack is discarded, and
any newly added function pairs become part of a new cycle, equivalent to a
newly constructed <code>ScopedTransaction</code>.</p>
</div>
<h2 id="io-utilities">I/O utilities</h2>
<h3 id="logging">Logging</h3>
<div class="defns">
<ul>
<li><code>void</code> <strong><code>logx</code></strong><code>(const Ustring&amp; msg) noexcept</code></li>
<li><code>void</code> <strong><code>logx</code></strong><code>(const char* msg) noexcept</code></li>
<li><code>template &lt;typename... Args&gt; void</code> <strong><code>logx</code></strong><code>(Args... args) noexcept</code></li>
</ul>
<p>These write a message to standard output, followed by a line feed and an
output flush. If multiple arguments are supplied, they are delimited with a
space.</p>
<p>This is intended for use in multithreaded code that needs coherent logging
output. A private mutex is used to ensure that messages from different threads
are not interleaved. Output from different threads will be given different
colours, chosen at random based on a hash of the thread ID. Because these are
intended only for debugging the code around them, any exceptions thrown by
their internal workings are silently ignored.</p>
</div>
<h2 id="keyword-arguments">Keyword arguments</h2>
<h3 id="keyword-arguments_1">Keyword arguments</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T, int ID = 0&gt; struct</code> <strong><code>Kwarg</code></strong><ul>
<li><code>constexpr ... Kwarg::</code><strong><code>operator=</code></strong><code>(const T&amp; t) const noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T, int ID, typename... Args&gt; constexpr bool</code> <strong><code>kwtest</code></strong><code>(Kwarg&lt;T, ID&gt; key, Args... args)</code></li>
<li><code>template &lt;typename T, int ID, typename... Args&gt; T</code> <strong><code>kwget</code></strong><code>(Kwarg&lt;T, ID&gt; key, const T&amp; def, Args... args)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> This provides a simple implementation of variadic keyword
arguments for C++ functions.</p>
<p>Define a <code>Kwarg&lt;T[,ID]&gt;</code> object for each keyword argument, where <code>T</code> is the
argument type. The <code>ID</code> parameter is only needed to distinguish between
keywords with the same argument type. Functions that will take keyword
arguments should be declared with a variadic argument pack, possibly preceded
by ordinary positional arguments.</p>
<p>When calling the function, the keyword arguments should be supplied in the
form <code>key=value</code>, where <code>key</code> is a <code>Kwarg</code> object, and <code>value</code> is the argument
value. The value type must be convertible to <code>T</code>. If <code>T</code> is <code>bool</code>, the
keyword alone can be passed as an argument, with the value defaulting to
<code>true</code>.</p>
<p>In the function body, call <code>kwget()</code> or <code>kwtest()</code> for each possible keyword
argument, with the corresponding <code>Kwarg</code> object as the key, a default value
(for <code>kwget()</code>), and the variadic arguments from the enclosing function. The
<code>kwget()</code> function returns the value attached to the keyword, or the default
value if the keyword was not found in the argument list; <code>kwtest()</code> returns
whether or not the keyword was present. If the same keyword appears more than
once in the actual argument list, the first one found will be returned.</p>
<p>Example:</p>
<pre><code>class Window {
public:
    static constexpr Kwarg&lt;int, 1&gt; width = {};
    static constexpr Kwarg&lt;int, 2&gt; height = {};
    static constexpr Kwarg&lt;std::string&gt; title = {};
    static constexpr Kwarg&lt;bool&gt; visible = {};
    template &lt;typename... Args&gt; explicit Window(Args... args) {
        int win_width = kwget(width, 640, args...);
        int win_height = kwget(height, 480, args...);
        string title_text = kwget(title, "New Window"s, args...);
        bool is_visible = kwget(visible, false, args...);
        // ...
    }
};

Window app_window(Window::title="Hello World", Window::width=1000, Window::height=750, Window::visible);
</code></pre>
</div>
<h2 id="multithreading">Multithreading</h2>
<h3 id="thread-class">Thread class</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Thread</code></strong><code>: public std::thread</code><ul>
<li><code>Thread::</code><strong><code>Thread</code></strong><code>() noexcept</code></li>
<li><code>template &lt;typename F, typename... Args&gt; explicit Thread::</code><strong><code>Thread</code></strong><code>(F&amp;&amp; f, Args&amp;&amp;... args)</code></li>
<li><code>Thread::</code><strong><code>Thread</code></strong><code>(Thread&amp;&amp; t) noexcept</code></li>
<li><code>Thread::</code><strong><code>~Thread</code></strong><code>() noexcept</code></li>
<li><code>Thread&amp; Thread::</code><strong><code>operator=</code></strong><code>(Thread&amp;&amp; t) noexcept</code></li>
<li><code>void Thread::</code><strong><code>detach</code></strong><code>()</code></li>
<li><code>void Thread::</code><strong><code>join</code></strong><code>()</code></li>
<li><code>id Thread::</code><strong><code>get_id</code></strong><code>() const noexcept</code></li>
<li><code>bool Thread::</code><strong><code>joinable</code></strong><code>() const noexcept</code></li>
<li><code>native_handle_type Thread::</code><strong><code>native_handle</code></strong><code>() noexcept</code></li>
<li><code>void Thread::</code><strong><code>swap</code></strong><code>(Thread&amp; t) noexcept</code></li>
</ul>
</li>
</ul>
<p>A simple wrapper for <code>std::thread</code>. This differs from <code>std::thread</code> only in
that it will automatically join on destruction, or when used on the LHS of an
assignment.</p>
</div>
<h2 id="string-functions">String functions</h2>
<h3 id="general-string-functions">General string functions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename C&gt; basic_string&lt;C&gt;</code> <strong><code>cstr</code></strong><code>(const C* ptr)</code></li>
<li><code>template &lt;typename C&gt; basic_string&lt;C&gt;</code> <strong><code>cstr</code></strong><code>(const C* ptr, size_t n)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> These construct a string from a pointer to a null-terminated
character sequence, or a pointer and a length. They differ from the
corresponding string constructors in that passing a null pointer will yield an
empty string, or a string of <code>n</code> null characters, instead of undefined
behaviour.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename C&gt; size_t</code> <strong><code>cstr_size</code></strong><code>(const C* ptr)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Returns the length of a null-terminated string (a generalized
version of <code>strlen()</code>). This will return zero if the pointer is null.</p>
</div>
<div class="defns">
<ul>
<li><code>Ustring</code> <strong><code>dent</code></strong><code>(size_t depth)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Returns a string containing <code>4*depth</code> spaces, for indentation.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename S&gt; [string view]</code> <strong><code>make_view</code></strong><code>(const S&amp; s, size_t pos = 0, size_t len = npos) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Returns a string view over the given string. The string argument
may be an instantiation of <code>std:basic_string</code> or <code>std::basic_string_view</code>, or
a pointer to a null terminated character array. The substring bounds are range
checked and clamped to the actual size of the string.</p>
</div>
<div class="defns">
<ul>
<li><code>std::string</code> <strong><code>quote</code></strong><code>(std::string_view str)</code></li>
<li><code>Ustring</code> <strong><code>bquote</code></strong><code>(std::string_view str)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Return a quoted string; internal quotes, backslashes, and control
characters are escaped. The <code>quote()</code> function passes non-ASCII bytes through
unchanged, while <code>bquote()</code> escapes them.</p>
</div>
<div class="defns">
<ul>
<li><code>Ustring</code> <strong><code>unqualify</code></strong><code>(Uview str, Uview delims = ".:")</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Strips off any prefix ending in one of the delimiter characters
(e.g. <code>unqualify("foo::bar::zap()")</code> returns <code>"zap()"</code>). This will return the
original string unchanged if the delimiter string is empty or none of its
characters are found.</p>
</div>
<h3 id="case-conversion-functions">Case conversion functions</h3>
<div class="defns">
<ul>
<li><code>constexpr char</code> <strong><code>ascii_tolower</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr char</code> <strong><code>ascii_toupper</code></strong><code>(char c) noexcept</code></li>
<li><code>std::string</code> <strong><code>ascii_lowercase</code></strong><code>(std::string_view s)</code></li>
<li><code>std::string</code> <strong><code>ascii_uppercase</code></strong><code>(std::string_view s)</code></li>
<li><code>std::string</code> <strong><code>ascii_titlecase</code></strong><code>(std::string_view s)</code></li>
<li><code>std::string</code> <strong><code>ascii_sentencecase</code></strong><code>(std::string_view s)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Simple ASCII-only case conversion functions. All non-ASCII
characters are left unchanged. The sentence case function capitalizes the
first letter of every sentence (delimited by a full stop or two consecutive
line breaks), leaving everything else alone.</p>
</div>
<h3 id="character-functions">Character functions</h3>
<div class="defns">
<ul>
<li><code>constexpr bool</code> <strong><code>ascii_isalnum</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isalpha</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_iscntrl</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isdigit</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isgraph</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_islower</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isprint</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_ispunct</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isspace</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isupper</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isxdigit</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>is_ascii</code></strong><code>(char c) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> These are simple ASCII-only versions of the standard character
type functions. All of them will always return false for bytes outside the
ASCII range (0-127).</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr bool</code> <strong><code>ascii_isalnum_w</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isalpha_w</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_ispunct_w</code></strong><code>(char c) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> These behave the same as the corresponding functions without the
<code>"_w"</code> suffix, except that the underscore character is counted as a letter
instead of a punctuation mark. (The suffix is intended to suggest the <code>"\w"</code>
regex element, which does much the same thing.)</p>
</div>
<h3 id="string-conversion-functions">String conversion functions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Ustring</code> <strong><code>bin</code></strong><code>(T x, size_t digits = 8 * sizeof(T))</code></li>
<li><code>template &lt;typename T&gt; Ustring</code> <strong><code>dec</code></strong><code>(T x, size_t digits = 1)</code></li>
<li><code>template &lt;typename T&gt; Ustring</code> <strong><code>hex</code></strong><code>(T x, size_t digits = 2 * sizeof(T))</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Simple number formatting functions. These convert an integer to a
binary, decimal, or hexadecimal string, generating at least the specified
number of digits.</p>
</div>
<div class="defns">
<ul>
<li><code>unsigned long long</code> <strong><code>binnum</code></strong><code>(std::string_view str) noexcept</code></li>
<li><code>long long</code> <strong><code>decnum</code></strong><code>(std::string_view str) noexcept</code></li>
<li><code>unsigned long long</code> <strong><code>hexnum</code></strong><code>(std::string_view str) noexcept</code></li>
<li><code>double</code> <strong><code>fpnum</code></strong><code>(std::string_view str) noexcept</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> The <code>binnum()</code>, <code>decnum()</code>, and <code>hexnum()</code> functions convert a
binary, decimal, or hexadecimal string to a number; <code>fpnum()</code> converts a
string to a floating point number. These will ignore any trailing characters
that are not part of a number, and will return zero if the string is empty or
does not contain a valid number. Results that are out of range will be clamped
to the nearest end of the return type's range, or for <code>fpnum()</code>, to positive
or negative infinity.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Range&gt; Ustring</code> <strong><code>format_list</code></strong><code>(const Range&amp; r)</code></li>
<li><code>template &lt;typename Range&gt; Ustring</code> <strong><code>format_list</code></strong><code>(const Range&amp; r, std::string_view prefix, std::string_view delimiter, std::string_view suffix)</code></li>
<li><code>template &lt;typename Range&gt; Ustring</code> <strong><code>format_map</code></strong><code>(const Range&amp; r)</code></li>
<li><code>template &lt;typename Range&gt; Ustring</code> <strong><code>format_map</code></strong><code>(const Range&amp; r, std::string_view prefix, std::string_view infix, std::string_view delimiter, std::string_view suffix)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Format a range as a delimited list. The <code>format_list()</code> function
writes the elements in sequence, with <code>prefix</code> and <code>suffix</code> at the beginning
and end, and with a <code>delimiter</code> between each pair of elements; individual
elements are formatted using <code>to_str()</code> (see below). The <code>format_map()</code>
function expects the range's value type to be a pair (or something with
<code>first</code> and <code>second</code> members); the elements of each pair are separated with
the <code>infix</code> string, and the range is otherwise formatted in the same way as
<code>format_list()</code>. The default formats are based on JSON syntax:</p>
<!-- TEXT -->

<ul>
<li><code>format_list(r) = format_list(r, "[", ",", "]")</code></li>
<li><code>format_map(r) = format_map(r, "{", ":", ",", "}")</code></li>
</ul>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Ustring</code> <strong><code>fp_format</code></strong><code>(T t, char mode = 'g', int prec = 6)</code></li>
<li><code>template &lt;typename T&gt; Ustring</code> <strong><code>opt_fp_format</code></strong><code>(T t, char mode = 'g', int prec = 6)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> The <code>fp_format()</code> function performs simple floating point
formatting, by calling <code>snprintf()</code>. <code>T</code> must be an arithmetic type; it will
be converted to <code>long double</code> internally. The additional format <code>'Z/z'</code> is the
same as <code>'G/g'</code> except that trailing zeros are not stripped. The
<code>opt_fp_format()</code> function calls <code>fp_format()</code> for floating point types;
otherwise it calls <code>to_str(t)</code> and ignores the other two arguments. These will
throw <code>std::invalid_argument</code> if the mode is not one of <code>[EFGZefgz]</code> (and is
not ignored); they may throw <code>std::system_error</code> under implementation defined
circumstances.</p>
</div>
<div class="defns">
<ul>
<li><code>Ustring</code> <strong><code>roman</code></strong><code>(int n)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Formats a number as a Roman numeral. Numbers greater than 1000
will be written with an arbitrarily long sequence of <code>"M"</code>. This will return
an empty string if the argument is less than 1.</p>
</div>
<div class="defns">
<ul>
<li><code>int64_t</code> <strong><code>si_to_int</code></strong><code>(Uview str)</code></li>
<li><code>double</code> <strong><code>si_to_float</code></strong><code>(Uview str)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> These parse a number from a string representation tagged with an
SI multiplier abbreviation (e.g. <code>"123k"</code>). For the integer version, only tags
representing positive powers of 1000 (starting with<code>"k"</code>) are recognised, and
are case insensitive. For the floating point version, all tags representing
powers of 100 are recognised (<code>"u"</code> is used for "micro"), and are case
sensitive, except that <code>"K"</code> is equivalent to <code>"k"</code>. For both versions, a
space is allowed between the number and the tag, and any additional text after
the number or tag is ignored. These will throw <code>std::invalid_argument</code> if the
string does not start with a valid number, or <code>std::range_error</code> if the result
is too big for the return type.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; bool</code> <strong><code>from_str</code></strong><code>(std::string_view view, T&amp; t) noexcept</code></li>
<li><code>template &lt;typename T&gt; T</code> <strong><code>from_str</code></strong><code>(std::string_view view)</code></li>
<li><code>template &lt;typename T&gt; std::string</code> <strong><code>to_str</code></strong><code>(const T&amp; t)</code></li>
</ul>
<p><code><span class="unicorn">[unicorn]</span></code> Generic utility functions for converting arbitrary types to or
from a string. The conversion rules are described below; <code>to_str()</code> and the
first version of <code>from_str()</code> can also be overloaded for new types.</p>
<p>The first version of <code>from_str()</code> writes the converted object into its second
argument and returns true on success; otherwise, it returns false and leaves
the referenced object unchanged. The second version calls the first version,
throwing <code>invalid_argument</code> on failure, and returning the converted object on
success; for this version, <code>T</code> must be default constructible.</p>
<p>The <code>from_str()</code> functions follow these rules, using the first conversion rule
that matches the type:</p>
<ul>
<li><code>static_cast</code> from <code>std::string_view</code> to <code>T</code></li>
<li><code>static_cast</code> from <code>std::string</code> to <code>T</code></li>
<li><code>static_cast</code> from <code>const char*</code> to <code>T</code></li>
<li>Read a <code>T</code> from a <code>std::istringstream</code> using <code>operator&gt;&gt;</code></li>
<li>Otherwise fail</li>
</ul>
<p>The <code>to_str()</code> functions follow these rules, using the first conversion rule
that matches the type:</p>
<ul>
<li>If <code>T</code> is <code>bool</code>, return <code>"true"</code> or <code>"false"</code></li>
<li>If <code>T</code> is <code>char</code>, return a one-character string</li>
<li>If <code>T</code> is <code>std::string</code> or <code>std::string_view</code>, simply copy the string</li>
<li>If <code>T</code> is <code>[const] char*</code>, copy the string, or return an empty string if the pointer is null</li>
<li>If <code>T</code> is <code>std::array&lt;uint8_t,N&gt;</code> or <code>std::vector&lt;uint8_t&gt;</code>, format each byte in hexadecimal</li>
<li>If <code>T</code> is an integer type, call <code>std::to_string(t)</code></li>
<li>If <code>T</code> is a floating point type, call <code>fp_format(t)</code></li>
<li>Call <code>t.str()</code>, <code>to_string(t)</code>, or <code>std::to_string(t)</code></li>
<li><code>static_cast</code> from <code>T</code> to <code>std::string</code>, <code>std::string_view</code>, or <code>const char*</code></li>
<li>If <code>T</code> is derived from <code>std::exception</code>, call <code>t.what()</code></li>
<li>If <code>T</code> is a <code>std::optional</code>, <code>std::shared_ptr</code>, or <code>std::unique_ptr</code>, return <code>to_str(*t)</code> or <code>"null"</code></li>
<li>If <code>T</code> is a <code>std::pair</code> or <code>std::tuple</code>, call <code>to_str()</code> on each element and return <code>"(e1,e2,...)"</code></li>
<li>If <code>T</code> is a range whose elements are pairs, call <code>to_str()</code> on each member of each pair and return <code>"{k1:v1,k2:v2,...}"</code></li>
<li>If <code>T</code> is a range whose elements are not pairs, call <code>to_str()</code> on each element and return <code>"[e1,e2,...]"</code></li>
<li>Write a <code>T</code> into a <code>std::ostringstream</code> using <code>operator&lt;&lt;</code></li>
<li>If all else fails, just return the demangled type name</li>
</ul></body>
</html>
