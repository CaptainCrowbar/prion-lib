<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Core Utilities</title>
<link type="text/css" rel="stylesheet" href="style.css"/>
</head>
<body>
<h1 id="core-utilities">Core Utilities</h1>
<p>By Ross Smith</p>
<ul>
<li><code>#include "prion/core.hpp"</code></li>
</ul>
<h2 id="contents">Contents</h2>
<div class="toc">
<ul>
<li><a href="#core-utilities">Core Utilities</a><ul>
<li><a href="#contents">Contents</a></li>
<li><a href="#preprocessor-macros">Preprocessor macros</a></li>
<li><a href="#types">Types</a><ul>
<li><a href="#basic-types">Basic types</a></li>
<li><a href="#containers">Containers</a></li>
<li><a href="#endian-integers">Endian integers</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#metaprogramming-and-type-traits">Metaprogramming and type traits</a></li>
<li><a href="#mixins">Mixins</a></li>
<li><a href="#smart-pointers">Smart pointers</a></li>
<li><a href="#type-related-functions">Type related functions</a></li>
<li><a href="#uuid">UUID</a></li>
<li><a href="#version-number">Version number</a></li>
</ul>
</li>
<li><a href="#constants-and-literals">Constants and literals</a><ul>
<li><a href="#arithmetic-constants">Arithmetic constants</a></li>
<li><a href="#arithmetic-literals">Arithmetic literals</a></li>
<li><a href="#string-related-constants">String related constants</a></li>
<li><a href="#other-constants">Other constants</a></li>
</ul>
</li>
<li><a href="#algorithms-and-ranges">Algorithms and ranges</a><ul>
<li><a href="#generic-algorithms">Generic algorithms</a></li>
<li><a href="#integer-sequences">Integer sequences</a></li>
<li><a href="#memory-algorithms">Memory algorithms</a></li>
<li><a href="#range-traits">Range traits</a></li>
<li><a href="#range-types">Range types</a></li>
</ul>
</li>
<li><a href="#arithmetic-functions">Arithmetic functions</a><ul>
<li><a href="#generic-arithmetic-functions">Generic arithmetic functions</a></li>
<li><a href="#integer-arithmetic-functions">Integer arithmetic functions</a></li>
<li><a href="#bitwise-operations">Bitwise operations</a></li>
<li><a href="#floating-point-arithmetic-functions">Floating point arithmetic functions</a></li>
</ul>
</li>
<li><a href="#functional-utilities">Functional utilities</a><ul>
<li><a href="#function-traits">Function traits</a></li>
<li><a href="#function-operations">Function operations</a></li>
<li><a href="#generic-function-objects">Generic function objects</a></li>
<li><a href="#hash-functions">Hash functions</a></li>
<li><a href="#keyword-arguments">Keyword arguments</a></li>
<li><a href="#scope-guards">Scope guards</a></li>
</ul>
</li>
<li><a href="#io-utilities">I/O utilities</a><ul>
<li><a href="#file-io-operations">File I/O operations</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#terminal-io-operations">Terminal I/O operations</a></li>
</ul>
</li>
<li><a href="#random-numbers">Random numbers</a><ul>
<li><a href="#simple-random-generators">Simple random generators</a></li>
</ul>
</li>
<li><a href="#strings-and-related-functions">Strings and related functions</a><ul>
<li><a href="#character-functions">Character functions</a></li>
<li><a href="#general-string-functions">General string functions</a></li>
<li><a href="#unicode-functions">Unicode functions</a></li>
<li><a href="#string-formatting-and-parsing-functions">String formatting and parsing functions</a></li>
<li><a href="#htmlxml-tags">HTML/XML tags</a></li>
</ul>
</li>
<li><a href="#threads">Threads</a><ul>
<li><a href="#thread-class">Thread class</a></li>
<li><a href="#synchronisation-objects">Synchronisation objects</a></li>
</ul>
</li>
<li><a href="#time-and-date-operations">Time and date operations</a><ul>
<li><a href="#time-and-date-types">Time and date types</a></li>
<li><a href="#general-time-and-date-operations">General time and date operations</a></li>
<li><a href="#time-and-date-formatting">Time and date formatting</a></li>
<li><a href="#system-specific-time-and-date-conversions">System specific time and date conversions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="preprocessor-macros">Preprocessor macros</h2>
<div class="defns">
<ul>
<li><em>Compilers</em><ul>
<li><code>#define</code> <strong><code>PRI_COMPILER_CLANG</code></strong> <code>1</code></li>
<li><code>#define</code> <strong><code>PRI_COMPILER_GCC</code></strong> <code>[version]</code></li>
</ul>
</li>
<li><em>Unix targets</em><ul>
<li><code>#define</code> <strong><code>PRI_TARGET_UNIX</code></strong> <code>1</code> <em>-- defined on all Unix/Posix builds</em></li>
<li><code>#define</code> <strong><code>PRI_TARGET_APPLE</code></strong> <code>1</code> <em>-- defined on all Apple (Darwin) builds</em></li>
<li><code>#define</code> <strong><code>PRI_TARGET_IOS</code></strong> <code>1</code> <em>-- defined on iOS builds</em></li>
<li><code>#define</code> <strong><code>PRI_TARGET_MACOS</code></strong> <code>1</code> <em>-- defined on macOS builds</em></li>
<li><code>#define</code> <strong><code>PRI_TARGET_LINUX</code></strong> <code>1</code> <em>-- defined on Linux builds</em></li>
</ul>
</li>
<li><em>Windows targets</em><ul>
<li><code>#define</code> <strong><code>PRI_TARGET_WINDOWS</code></strong> <code>1</code> <em>-- defined on non-Cygwin native Windows builds</em></li>
<li><code>#define</code> <strong><code>PRI_TARGET_ANYWINDOWS</code></strong> <code>1</code> <em>-- defined on all Windows builds, including Cygwin</em></li>
<li><code>#define</code> <strong><code>PRI_TARGET_WIN32</code></strong> <code>1</code> <em>-- defined if the Win32 API is available</em></li>
<li><code>#define</code> <strong><code>PRI_TARGET_CYGWIN</code></strong> <code>1</code> <em>-- defined on Cygwin builds</em></li>
<li><code>#define</code> <strong><code>PRI_TARGET_MINGW</code></strong> <code>1</code> <em>-- defined on native Win32 builds using Mingw</em></li>
</ul>
</li>
</ul>
<p>Some of these will be defined to provide a consistent way to identify the
compiler and target operating system for conditional compilation.</p>
<p><code>PRI_COMPILER_GCC</code> will be defined as the GCC version number in three digit
form (e.g. 520 for GCC 5.2.0). No version number is supplied for Clang because
its version numbers are not consistent across builds for different systems.</p>
<p>Exactly one of <code>PRI_TARGET_UNIX</code> or <code>PRI_TARGET_WINDOWS</code> will always be
defined, indicating whether a build is intended to use the Posix or Win32
operating system API. <code>PRI_TARGET_WIN32</code> is defined if the Win32 API is
available; normally it will be the same as <code>PRI_TARGET_WINDOWS</code>, except that
it will also be defined in Cygwin <code>-mwin32</code> builds, where both APIs are
available. <code>PRI_TARGET_ANYWINDOWS</code> is always defined on builds intended to run
on the Windows OS, i.e. both native Win32 and Cygwin builds.</p>
<p>Currently only Mingw builds are supported for native Windows targets, so
<code>PRI_TARGET_MINGW</code> will always be defined if <code>PRI_TARGET_WINDOWS</code> is defined.
I may add MSVC support in a future version.</p>
<p>On Apple platforms, <code>PRI_TARGET_APPLE</code> will always be defined; one of
<code>PRI_TARGET_IOS</code> or <code>PRI_TARGET_MACOS</code> will also be defined.</p>
</div>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>PRI_ASSERT</code></strong><code>(expr)</code></li>
</ul>
<p>A simple assertion macro for quick and dirty debugging. If the expression
(explicitly cast to <code>bool</code>) is false, this throws a <code>std::logic_error</code>
exception, with a message containing the text of the expression and the source
code location.</p>
</div>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>PRI_BITMASK_OPERATORS</code></strong><code>(EC)</code></li>
</ul>
<p>Defines bit manipulation and related operators for an <code>enum class</code> (unary <code>!</code>,
<code>~</code>; binary <code>&amp;</code>, <code>&amp;=</code>, <code>|</code>, <code>|=</code>, <code>^</code>, <code>^=</code>).</p>
</div>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>PRI_CHAR</code></strong><code>(C, T)</code></li>
<li><code>#define</code> <strong><code>PRI_CSTR</code></strong><code>(S, T)</code></li>
</ul>
<p>These resolve to the character <code>C</code> as a <code>constexpr T</code>, or the C-style string
literal <code>S</code> as a <code>constexpr const T*</code>. For example, <code>PRI_CHAR('A',wchar_t)</code>
resolves to <code>L'A'</code>; <code>PRI_CSTR("Hello",char32_t)</code> resolves to <code>U"Hello"</code>. <code>C</code>
must be a simple character literal; <code>T</code> must be one of the four character
types that can be used in strings (<code>char</code>, <code>char16_t</code>, <code>char32_t</code>, or
<code>wchar_t</code>). Behaviour is undefined if <code>T</code> is not one of those four types, or
(for <code>PRI_CHAR</code>) if <code>C</code> is not representable by a single code unit.</p>
</div>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>PRI_ENUM</code></strong><code>(EnumType, first_value, first_name, ...)</code></li>
<li><code>#define</code> <strong><code>PRI_ENUM_CLASS</code></strong><code>(EnumType, first_value, first_name, ...)</code></li>
</ul>
<p>These define an enumeration, given the name of the enumeration type, the
integer value of the first entry, and a list of value names. They will also
define the following functions:</p>
<ul>
<li><code>std::ostream&amp;</code> <strong><code>operator&lt;&lt;</code></strong><code>(std::ostream&amp; out, EnumType t)</code></li>
<li><code>constexpr bool</code> <strong><code>enum_is_valid</code></strong><code>(EnumType t) noexcept</code></li>
<li><code>std::vector&lt;EnumType&gt;</code> <strong><code>enum_values&lt;EnumType&gt;</code></strong><code>()</code></li>
</ul>
<p>The output operator prints the name of an enumeration constant (qualified with
the class name if this is an <code>enum class</code>), or the integer value if the
argument is not a named value. The <code>enum_is_valid()</code> function reports whether
or not the argument is a named value of the enumeration. The
<code>enum_values&lt;T&gt;()</code> function returns a <code>vector</code> containing a list of the
enumeration's values.</p>
<p>Example:</p>
<pre><code>PRI_ENUM(Foo, 1, alpha, bravo, charlie)
PRI_ENUM_CLASS(Bar, 1, delta, echo, foxtrot)
</code></pre>
<p>Equivalent code:</p>
<pre><code>enum Foo { alpha = 1, bravo, charlie };
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Foo f) { ... }
enum class Bar { delta = 1, echo, foxtrot };
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Bar b) { ... }
</code></pre>
</div>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>PRI_LDLIB</code></strong><code>([tag:]lib)</code></li>
</ul>
<p>This instructs the makefile to link with one or more static libraries. Specify
library names without the <code>-l</code> prefix (e.g. <code>PRI_LDLIB(foo)</code> will link with
<code>-lfoo</code>). A separate <code>PRI_LDLIB()</code> line is required for each library.
Libraries that are needed only on specific targets can be prefixed with one of
the target identifiers listed below (e.g. <code>PRI_LDLIB(apple:foo)</code> will link
with <code>-lfoo</code> for Apple targets only).</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Build target</th>
<th>Corresponding macro</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>apple:</code></td>
<td>macOS or iOS</td>
<td><code>PRI_TARGET_APPLE</code></td>
</tr>
<tr>
<td><code>linux:</code></td>
<td>Linux</td>
<td><code>PRI_TARGET_LINUX</code></td>
</tr>
<tr>
<td><code>mingw:</code></td>
<td>Mingw</td>
<td><code>PRI_TARGET_MINGW</code></td>
</tr>
<tr>
<td><code>cygwin:</code></td>
<td>Cygwin</td>
<td><code>PRI_TARGET_CYGWIN</code></td>
</tr>
</tbody>
</table>
<p>Only one target can be specified per invocation; if the same libraries are
needed on multiple targets, but not on all targets, you will need a separate
<code>PRI_LDLIB()</code> line for each target.</p>
<p><code>PRI_LDLIB()</code> lines are picked up at the <code>"make dep"</code> stage; if you change a
link library, the change will not be detected until dependencies are rebuilt.</p>
</div>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>PRI_MOVE_ONLY</code></strong><code>(T)</code><ul>
<li><code>T(const T&amp;) = delete;</code></li>
<li><code>T(T&amp;&amp;) = default;</code></li>
<li><code>T&amp; operator=(const T&amp;) = delete;</code></li>
<li><code>T&amp; operator=(T&amp;&amp;) = default;</code></li>
</ul>
</li>
<li><code>#define</code> <strong><code>PRI_NO_COPY_MOVE</code></strong><code>(T)</code><ul>
<li><code>T(const T&amp;) = delete;</code></li>
<li><code>T(T&amp;&amp;) = delete;</code></li>
<li><code>T&amp; operator=(const T&amp;) = delete;</code></li>
<li><code>T&amp; operator=(T&amp;&amp;) = delete;</code></li>
</ul>
</li>
</ul>
<p>Convenience macros for defaulted or deleted copy and move operations.</p>
</div>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>PRI_OVERLOAD</code></strong><code>(f) [] (auto&amp;&amp;... args) { return f(std::forward&lt;decltype(args)&gt;(args)...); }</code></li>
</ul>
<p>Creates a function object wrapping a set of overloaded functions, that can be
passed to a context expecting a function (such as an STL algorithm) without
having to explicitly resolve the overload at the call site. (From an idea by
Arthur O'Dwyer on the C++ standard proposals mailing list, 14 Sep 2015.)</p>
</div>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>PRI_STATIC_ASSERT</code></strong><code>(expr) static_assert((expr), # expr)</code></li>
</ul>
<p>Shorthand for <code>static_assert</code>, using the assertion expression as the error
message. (A planned change in C++17 will make this unnecessary.)</p>
</div>
<h2 id="types">Types</h2>
<h3 id="basic-types">Basic types</h3>
<div class="defns">
<ul>
<li><em>From <code>&lt;functional&gt;</code></em><ul>
<li><code>using std::</code><strong><code>function</code></strong></li>
</ul>
</li>
<li><em>From <code>&lt;iostream&gt;</code></em><ul>
<li><code>using std::</code><strong><code>cerr</code></strong></li>
<li><code>using std::</code><strong><code>cin</code></strong></li>
<li><code>using std::</code><strong><code>clog</code></strong></li>
<li><code>using std::</code><strong><code>cout</code></strong></li>
<li><code>using std::</code><strong><code>endl</code></strong></li>
<li><code>using std::</code><strong><code>flush</code></strong></li>
</ul>
</li>
<li><em>From <code>&lt;memory&gt;</code></em><ul>
<li><code>using std::</code><strong><code>make_shared</code></strong></li>
<li><code>using std::</code><strong><code>make_unique</code></strong></li>
<li><code>using std::</code><strong><code>shared_ptr</code></strong></li>
<li><code>using std::</code><strong><code>unique_ptr</code></strong></li>
</ul>
</li>
<li><em>From <code>&lt;string&gt;</code></em><ul>
<li><code>using std::</code><strong><code>basic_string</code></strong></li>
<li><code>using std::</code><strong><code>string</code></strong></li>
<li><code>using std::</code><strong><code>u16string</code></strong></li>
<li><code>using std::</code><strong><code>u32string</code></strong></li>
<li><code>using std::</code><strong><code>wstring</code></strong></li>
</ul>
</li>
<li><em>From <code>&lt;tuple&gt;</code></em><ul>
<li><code>using std::</code><strong><code>make_tuple</code></strong></li>
<li><code>using std::</code><strong><code>tie</code></strong></li>
<li><code>using std::</code><strong><code>tuple</code></strong></li>
</ul>
</li>
<li><em>From <code>&lt;utility&gt;</code></em><ul>
<li><code>using std::</code><strong><code>make_pair</code></strong></li>
<li><code>using std::</code><strong><code>move</code></strong></li>
<li><code>using std::</code><strong><code>pair</code></strong></li>
</ul>
</li>
<li><em>From <code>&lt;vector&gt;</code></em><ul>
<li><code>using std::</code><strong><code>vector</code></strong></li>
</ul>
</li>
</ul>
<p>Imported for convenience.</p>
</div>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>u8string</code></strong> <code>= std::string</code></li>
</ul>
<p>Use <code>u8string</code> for strings that are expected to be in UTF-8 (or ASCII, since
any ASCII string is also valid UTF-8), while plain <code>string</code> is used where the
string is expected to be in some non-Unicode encoding, or where the string is
being used simply as an array of bytes rather than encoded text.</p>
</div>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>int128_t</code></strong> <code>= [signed 128 bit integer]</code></li>
<li><code>using</code> <strong><code>uint128_t</code></strong> <code>= [unsigned 128 bit integer]</code></li>
<li><code>constexpr uint128_t</code> <strong><code>make_uint128</code></strong><code>(uint64_t hi, uint64_t lo) noexcept</code></li>
<li><code>constexpr int128_t</code> <strong><code>make_int128</code></strong><code>(uint64_t hi, uint64_t lo) noexcept</code></li>
</ul>
<p>Aliases for the compiler's 128 bit integer types (e.g. <code>__int128</code>). (The
function to make a signed <code>int128_t</code> only accepts unsigned arguments because
it is not clear how signed arguments should naturally be interpreted.
Behaviour is undefined if the high bit of <code>hi</code> is set.)</p>
</div>
<h3 id="containers">Containers</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Blob</code></strong><ul>
<li><code>Blob::</code><strong><code>Blob</code></strong><code>()</code></li>
<li><code>explicit Blob::</code><strong><code>Blob</code></strong><code>(size_t n)</code></li>
<li><code>Blob::</code><strong><code>Blob</code></strong><code>(size_t n, uint8_t x)</code></li>
<li><code>Blob::</code><strong><code>Blob</code></strong><code>(void* p, size_t n)</code></li>
<li><code>template &lt;typename F&gt; Blob::</code><strong><code>Blob</code></strong><code>(void* p, size_t n, F f)</code></li>
<li><code>Blob::</code><strong><code>~Blob</code></strong><code>() noexcept</code></li>
<li><code>Blob::</code><strong><code>Blob</code></strong><code>(const Blob&amp; b)</code></li>
<li><code>Blob::</code><strong><code>Blob</code></strong><code>(Blob&amp;&amp; b) noexcept: ptr(b.ptr), len(b.len)</code></li>
<li><code>Blob&amp; Blob::</code><strong><code>operator=</code></strong><code>(const Blob&amp; b)</code></li>
<li><code>Blob&amp; Blob::</code><strong><code>operator=</code></strong><code>(Blob&amp;&amp; b) noexcept</code></li>
<li><code>void* Blob::</code><strong><code>data</code></strong><code>() noexcept</code></li>
<li><code>const void* Blob::</code><strong><code>data</code></strong><code>() const noexcept</code></li>
<li><code>uint8_t* Blob::</code><strong><code>bdata</code></strong><code>() noexcept</code></li>
<li><code>const uint8_t* Blob::</code><strong><code>bdata</code></strong><code>() const noexcept</code></li>
<li><code>char* Blob::</code><strong><code>cdata</code></strong><code>() noexcept</code></li>
<li><code>const char* Blob::</code><strong><code>cdata</code></strong><code>() const noexcept</code></li>
<li><code>Irange&lt;uint8_t*&gt; Blob::</code><strong><code>bytes</code></strong><code>() noexcept</code></li>
<li><code>Irange&lt;const uint8_t*&gt; Blob::</code><strong><code>bytes</code></strong><code>() const noexcept</code></li>
<li><code>Irange&lt;char*&gt; Blob::</code><strong><code>chars</code></strong><code>() noexcept</code></li>
<li><code>Irange&lt;const char*&gt; Blob::</code><strong><code>chars</code></strong><code>() const noexcept</code></li>
<li><code>void Blob::</code><strong><code>clear</code></strong><code>() noexcept</code></li>
<li><code>void Blob::</code><strong><code>copy</code></strong><code>(const void* p, size_t n)</code></li>
<li><code>bool Blob::</code><strong><code>empty</code></strong><code>() const noexcept</code></li>
<li><code>void Blob::</code><strong><code>fill</code></strong><code>(uint8_t x) noexcept</code></li>
<li><code>size_t Blob::</code><strong><code>hash</code></strong><code>() const noexcept</code></li>
<li><code>u8string Blob::</code><strong><code>hex</code></strong><code>(size_t block = 0) const</code></li>
<li><code>void Blob::</code><strong><code>reset</code></strong><code>(size_t n)</code></li>
<li><code>void Blob::</code><strong><code>reset</code></strong><code>(size_t n, uint8_t x)</code></li>
<li><code>void Blob::</code><strong><code>reset</code></strong><code>(void* p, size_t n)</code></li>
<li><code>template &lt;typename F&gt; void Blob::</code><strong><code>reset</code></strong><code>(void* p, size_t n, F f)</code></li>
<li><code>size_t Blob::</code><strong><code>size</code></strong><code>() const noexcept</code></li>
<li><code>string Blob::</code><strong><code>str</code></strong><code>() const</code></li>
<li><code>void Blob::</code><strong><code>swap</code></strong><code>(Blob&amp; b) noexcept</code></li>
</ul>
</li>
<li><code>bool</code> <strong><code>operator==</code></strong><code>(const Blob&amp; lhs, const Blob&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator!=</code></strong><code>(const Blob&amp; lhs, const Blob&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&lt;</code></strong><code>(const Blob&amp; lhs, const Blob&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&gt;</code></strong><code>(const Blob&amp; lhs, const Blob&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&lt;=</code></strong><code>(const Blob&amp; lhs, const Blob&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&gt;=</code></strong><code>(const Blob&amp; lhs, const Blob&amp; rhs) noexcept</code></li>
<li><code>void</code> <strong><code>swap</code></strong><code>(Blob&amp; sb1, Blob&amp; sb2) noexcept</code></li>
<li><code>class std::</code><strong><code>hash</code></strong><code>&lt;Blob&gt;</code></li>
</ul>
<p>A simple wrapper for a block of memory.</p>
<p>The constructor and <code>reset()</code> functions that take a length, and optionally a
byte value, allocate memory using <code>malloc()</code>. The versions that take only a
length do not initialize the newly allocated memory; the ones that take a
length and value will fill the entire blob with the value. The versions that
take a pointer, size, and optional deallocation function take ownership of the
referenced data, and will deallocate it when it is discarded. If no
deallocation function is supplied, the memory is assumed to have been acquired
with <code>malloc()</code>, and will be released with <code>free()</code>. When a blob is copied,
the memory for the new copy is always allocated using <code>malloc()</code>, regardless
of how the source blob was allocated.</p>
<p>Unlike a <code>std::vector</code>, a <code>Blob</code> always allocates exactly the required amount
of memory. Any operation that changes the blob's size will reallocate it and
invalidate all pointers into the old blob.</p>
<p>For all functions that take a pointer and length, if a null pointer is passed,
the length is ignored and the effect is the same as passing a valid pointer
and zero length.</p>
<p>The <code>[bc]data()</code> functions return pointers to the beginning of the blob. The
<code>bytes()</code> and <code>chars()</code> functions return a pair of pointers marking the
beginning and end of the blob.</p>
<p>The <code>copy()</code> function reallocates the blob to the required size and copies the
referenced data.</p>
<p>The <code>hex()</code> function returns the blob's data in hex form; if a nonzero block
size is supplied, a line feed will be inserted after each block.</p>
<p>The <code>str()</code> function copies the entire blob into a string.</p>
<p>The comparison operators perform bytewise comparison by calling <code>memcmp()</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>Stacklike</code></strong><ul>
<li><code>using Stacklike&lt;T&gt;::</code><strong><code>iterator</code></strong> <code>= [random access iterator]</code></li>
<li><code>using Stacklike&lt;T&gt;::</code><strong><code>const_iterator</code></strong> <code>= [random access iterator]</code></li>
<li><code>Stacklike&lt;T&gt;::</code><strong><code>Stacklike</code></strong><code>()</code></li>
<li><code>Stacklike&lt;T&gt;::</code><strong><code>Stacklike</code></strong><code>(Stacklike&amp;&amp; s)</code></li>
<li><code>Stacklike&lt;T&gt;::</code><strong><code>~Stacklike</code></strong><code>()</code></li>
<li><code>Stacklike&amp; Stacklike&lt;T&gt;::</code><strong><code>operator=</code></strong><code>(Stacklike&amp;&amp; s)</code></li>
<li><code>iterator Stacklike&lt;T&gt;::</code><strong><code>begin</code></strong><code>() noexcept</code></li>
<li><code>const_iterator Stacklike&lt;T&gt;::</code><strong><code>begin</code></strong><code>() const noexcept</code></li>
<li><code>const_iterator Stacklike&lt;T&gt;::</code><strong><code>cbegin</code></strong><code>() const noexcept</code></li>
<li><code>void Stacklike&lt;T&gt;::</code><strong><code>clear</code></strong><code>() noexcept</code></li>
<li><code>bool Stacklike&lt;T&gt;::</code><strong><code>empty</code></strong><code>() const noexcept</code></li>
<li><code>iterator Stacklike&lt;T&gt;::</code><strong><code>end</code></strong><code>() noexcept</code></li>
<li><code>const_iterator Stacklike&lt;T&gt;::</code><strong><code>end</code></strong><code>() const noexcept</code></li>
<li><code>const_iterator Stacklike&lt;T&gt;::</code><strong><code>cend</code></strong><code>() const noexcept</code></li>
<li><code>void Stacklike&lt;T&gt;::</code><strong><code>pop</code></strong><code>() noexcept</code></li>
<li><code>void Stacklike&lt;T&gt;::</code><strong><code>push</code></strong><code>(const T&amp; t)</code></li>
<li><code>void Stacklike&lt;T&gt;::</code><strong><code>push</code></strong><code>(T&amp;&amp; t)</code></li>
<li><code>size_t Stacklike&lt;T&gt;::</code><strong><code>size</code></strong><code>() const noexcept</code></li>
</ul>
</li>
</ul>
<p>A simple LIFO container, whose main function is to ensure that its elements
are destroyed in reverse order of insertion (this is not guaranteed by any
standard container, but is often useful for RAII).</p>
</div>
<h3 id="endian-integers">Endian integers</h3>
<div class="defns">
<ul>
<li><code>enum</code> <strong><code>ByteOrder</code></strong><ul>
<li><strong><code>big_endian</code></strong></li>
<li><strong><code>little_endian</code></strong></li>
</ul>
</li>
<li><code>template &lt;typename T, ByteOrder B&gt; class</code> <strong><code>Endian</code></strong><ul>
<li><code>using Endian::</code><strong><code>value_type</code></strong><code>= T</code></li>
<li><code>static constexpr ByteOrder Endian::</code><strong><code>byte_order</code></strong> <code>= B</code></li>
<li><code>constexpr Endian::</code><strong><code>Endian</code></strong><code>() noexcept</code></li>
<li><code>constexpr Endian::</code><strong><code>Endian</code></strong><code>(T t) noexcept</code></li>
<li><code>explicit Endian::</code><strong><code>Endian</code></strong><code>(const void* p) noexcept</code></li>
<li><code>constexpr Endian::</code><strong><code>operator T</code></strong><code>() const noexcept</code></li>
<li><code>constexpr T Endian::</code><strong><code>get</code></strong><code>() const noexcept</code></li>
<li><code>constexpr const T* Endian::</code><strong><code>ptr</code></strong><code>() const noexcept</code></li>
<li><code>T* Endian::</code><strong><code>ptr</code></strong><code>() noexcept</code></li>
<li><code>constexpr T Endian::</code><strong><code>rep</code></strong><code>() const noexcept</code></li>
<li><code>T&amp; Endian::</code><strong><code>rep</code></strong><code>() noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T&gt; using</code> <strong><code>BigEndian</code></strong><code>= Endian&lt;T, big_endian&gt;</code></li>
<li><code>template &lt;typename T&gt; using</code> <strong><code>LittleEndian</code></strong><code>= Endian&lt;T, little_endian&gt;</code></li>
<li><code>template &lt;typename T, ByteOrder B&gt; std::ostream&amp;</code> <strong><code>operator&lt;&lt;</code></strong><code>(std::ostream&amp; out, Endian&lt;T, B&gt; t)</code></li>
</ul>
<p>An <code>Endian</code> object holds an integer in a defined byte order. Assignment to or
from an endian integer performs any necessary reordering transparently. The
default constructor sets the value to zero. The constructor from a pointer
copies <code>sizeof(T)</code> bytes into the object. The <code>ptr()</code> and <code>rep()</code> functions
give access to the internal, byte ordered form. The <code>Endian</code> class is a
literal type and can be used in <code>constexpr</code> expressions.</p>
</div>
<h3 id="exceptions">Exceptions</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>WindowsCategory</code></strong><code>: public std::error_category</code><ul>
<li><code>virtual u8string WindowsCategory::</code><strong><code>message</code></strong><code>(int ev) const</code></li>
<li><code>virtual const char* WindowsCategory::</code><strong><code>name</code></strong><code>() const noexcept</code></li>
</ul>
</li>
<li><code>const std::error_category&amp;</code> <strong><code>windows_category</code></strong><code>() noexcept</code></li>
</ul>
<p>An error category instance for translating Win32 API error codes; naturally
this is only defined on Windows builds <code>(PRI_TARGET_WIN32</code>). (MSVC
provides this through the standard <code>system_category()</code> instance, but GCC does
not supply any equivalent.)</p>
</div>
<h3 id="metaprogramming-and-type-traits">Metaprogramming and type traits</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; using</code> <strong><code>BinaryType</code></strong> <code>= [unsigned integer type]</code></li>
</ul>
<p>Yields an unsigned integer type the same size as <code>T</code>. This will fail to
compile if no such type exists.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T1, typename T2&gt; using</code> <strong><code>CopyConst</code></strong> <code>= ...</code></li>
</ul>
<p>Yields a type created by transferring the <code>const</code> qualification (or lack of
it) from <code>T1</code> to the unqualified type of <code>T2</code>. For example, <code>CopyConst&lt;int,
const string&gt;</code> yields <code>string</code>, while <code>CopyConst&lt;const int, string&gt;</code> yields
<code>const string</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;size_t Bits&gt; using</code> <strong><code>SignedInteger</code></strong> <code>= [signed integer type]</code></li>
<li><code>template &lt;size_t Bits&gt; using</code> <strong><code>UnsignedInteger</code></strong> <code>= [unsigned integer type]</code></li>
</ul>
<p>Signed and unsigned integer types with the specified number of bits (the same
types as <code>int8_t</code>, <code>int16_t</code>, etc). These will fail to compile if <code>Bits</code> is
not a power of 2 in the supported range (8-128).</p>
</div>
<h3 id="mixins">Mixins</h3>
<div class="defns">
<!-- DEFN -->

<p>These are convenience base classes that define members and
operators that would normally just be repetitive boilerplate (similar to the
ones in Boost). They all use the CRTP idiom; a class <code>T</code> should derive from
<code>Mixin&lt;T&gt;</code> to automatically generate the desired boilerplate code. The table
below shows which operations the user is required to define, and which ones
the mixin will automatically define. (Here, <code>t</code> and <code>u</code> are objects of type
<code>T</code>, <code>v</code> is an object of <code>T</code>'s value type, and <code>n</code> is an integer.)</p>
<table>
<thead>
<tr>
<th>Mixin</th>
<th>Requires</th>
<th>Defines</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>EqualityComparable</code></strong><code>&lt;T&gt;</code></td>
<td><code>t==u</code></td>
<td><code>t!=u</code></td>
</tr>
<tr>
<td><strong><code>LessThanComparable</code></strong><code>&lt;T&gt;</code></td>
<td><code>t==u, t&lt;u</code></td>
<td><code>t!=u, t&gt;u, t&lt;=u, t&gt;=u</code></td>
</tr>
<tr>
<td><strong><code>InputIterator</code></strong><code>&lt;T,CV&gt;</code></td>
<td><code>*t, ++t, t==u</code></td>
<td><code>t-&gt;, t++, t!=u</code></td>
</tr>
<tr>
<td><strong><code>OutputIterator</code></strong><code>&lt;T&gt;</code></td>
<td><code>t=v</code></td>
<td><code>*t, ++t, t++</code></td>
</tr>
<tr>
<td><strong><code>ForwardIterator</code></strong><code>&lt;T,CV&gt;</code></td>
<td><code>*t, ++t, t==u</code></td>
<td><code>t-&gt;, t++, t!=u</code></td>
</tr>
<tr>
<td><strong><code>BidirectionalIterator</code></strong><code>&lt;T,CV&gt;</code></td>
<td><code>*t, ++t, --t, t==u</code></td>
<td><code>t-&gt;, t++, t--, t!=u</code></td>
</tr>
<tr>
<td><strong><code>RandomAccessIterator</code></strong><code>&lt;T,CV&gt;</code></td>
<td><code>*t, t+=n, t-u</code></td>
<td><code>t-&gt;, t[n], ++t, t++, --t, t--, t-=n, t+n, n+t, t-n,</code><br><code>t==u, t!=u, t&lt;u, t&gt;u, t&lt;=u, t&gt;=u</code></td>
</tr>
</tbody>
</table>
<p>In the iterator mixins, <code>CV</code> is either <code>V</code> or <code>const V</code>, where <code>V</code> is the
iterator's value type, depending on whether a mutable or const iterator is
required. In addition to the operators listed in the table above, all iterator
mixins supply the standard member types:</p>
<ul>
<li><code>using</code> <strong><code>difference_type</code></strong> <code>= ptrdiff_t</code></li>
<li><code>using</code> <strong><code>iterator_category</code></strong> <code>= [standard iterator tag type]</code></li>
<li><code>using</code> <strong><code>pointer</code></strong> <code>= CV*</code></li>
<li><code>using</code> <strong><code>reference</code></strong> <code>= CV&amp;</code></li>
<li><code>using</code> <strong><code>value_type</code></strong> <code>= std::remove_const_t&lt;CV&gt;</code></li>
</ul>
</div>
<h3 id="smart-pointers">Smart pointers</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>Nnptr</code></strong><ul>
<li><code>using Nnptr::</code><strong><code>element_type</code></strong> <code>= T</code></li>
<li><code>Nnptr::</code><strong><code>Nnptr</code></strong><code>(const Nnptr&amp; p) noexcept</code></li>
<li><code>Nnptr::</code><strong><code>Nnptr</code></strong><code>(Nnptr&amp;&amp; p) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Nnptr::</code><strong><code>Nnptr</code></strong><code>(const Nnptr&lt;T2&gt;&amp; p) noexcept</code></li>
<li><code>template &lt;typename T2&gt; explicit Nnptr::</code><strong><code>Nnptr</code></strong><code>(T2* p)</code></li>
<li><code>template &lt;typename T2, typename D&gt; Nnptr::</code><strong><code>Nnptr</code></strong><code>(T2* p, D d)</code></li>
<li><code>template &lt;typename T2, typename D&gt; Nnptr::</code><strong><code>Nnptr</code></strong><code>(unique_ptr&lt;T2, D&gt;&amp;&amp; p)</code></li>
<li><code>Nnptr::</code><strong><code>~Nnptr</code></strong><code>() noexcept</code></li>
<li><code>Nnptr&amp; Nnptr::</code><strong><code>operator=</code></strong><code>(const Nnptr&amp; p) noexcept</code></li>
<li><code>Nnptr&amp; Nnptr::</code><strong><code>operator=</code></strong><code>(Nnptr&amp;&amp; p) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Nnptr&amp; Nnptr::</code><strong><code>operator=</code></strong><code>(const Nnptr&lt;T2&gt;&amp; p) noexcept</code></li>
<li><code>template &lt;typename T2, typename D&gt; Nnptr&amp; Nnptr::</code><strong><code>operator=</code></strong><code>(unique_ptr&lt;T2, D&gt;&amp;&amp; p)</code></li>
<li><code>explicit Nnptr::</code><strong><code>operator bool</code></strong><code>() const noexcept</code></li>
<li><code>bool Nnptr::</code><strong><code>operator!</code></strong><code>() const noexcept</code></li>
<li><code>T&amp; Nnptr::</code><strong><code>operator*</code></strong><code>() const noexcept</code></li>
<li><code>T* Nnptr::</code><strong><code>operator-&gt;</code></strong><code>() const noexcept</code></li>
<li><code>T* Nnptr::</code><strong><code>get</code></strong><code>() const noexcept</code></li>
<li><code>template &lt;typename T2&gt; void Nnptr::</code><strong><code>reset</code></strong><code>(T2* p)</code></li>
<li><code>template &lt;typename T2, typename D&gt; void Nnptr::</code><strong><code>reset</code></strong><code>(T2* p, D d)</code></li>
<li><code>bool Nnptr::</code><strong><code>unique</code></strong><code>() const noexcept</code></li>
</ul>
</li>
<li><code>class</code> <strong><code>NullPointer</code></strong><code>: public std::runtime_error</code></li>
<li><code>template &lt;typename T, typename... Args&gt; Nnptr&lt;T&gt;</code> <strong><code>make_nnptr</code></strong><code>(Args&amp;&amp;... args)</code></li>
<li><code>template &lt;typename T1, typename T2&gt; Nnptr&lt;T1&gt;</code> <strong><code>const_pointer_cast</code></strong><code>(const Nnptr&lt;T2&gt;&amp; r) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2&gt; Nnptr&lt;T1&gt;</code> <strong><code>dynamic_pointer_cast</code></strong><code>(const Nnptr&lt;T2&gt;&amp; r) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2&gt; Nnptr&lt;T1&gt;</code> <strong><code>static_pointer_cast</code></strong><code>(const Nnptr&lt;T2&gt;&amp; r) noexcept</code></li>
<li><em>Comparison operators (see below)</em></li>
</ul>
<p>This is basically the same as a <code>shared_ptr</code>, except that the pointer can
never be null. Any method that implicitly takes ownership of a pointer (i.e.
any that is not marked <code>noexcept</code>) will throw <code>NullPointer</code> if the pointer is
null.</p>
<p>Note that there is no default constructor. Move construction and assignment
are implemented as reference incrementing copies on the underlying pointer
(i.e. the same as copy construction and assignment). Behaviour is otherwise
the same as the corresponding operations on a <code>shared_ptr</code>.</p>
<p>Comparison operators are defined between two heterogeneous <code>Nnptr</code> objects,
between an <code>Nnptr</code> and a raw pointer, and between an <code>Nnptr</code> and a <code>nullptr</code>.
These call the corresponding operations on the underlying raw pointers.</p>
</div>
<h3 id="type-related-functions">Type related functions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T2, typename T1&gt; bool</code> <strong><code>is</code></strong><code>(const T1&amp; ref) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; bool</code> <strong><code>is</code></strong><code>(const T1* ptr) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; bool</code> <strong><code>is</code></strong><code>(const unique_ptr&lt;T1&gt;&amp; ptr) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; bool</code> <strong><code>is</code></strong><code>(const shared_ptr&lt;T1&gt;&amp; ptr) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(T1&amp; ref)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; const T2&amp;</code> <strong><code>as</code></strong><code>(const T1&amp; ref)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(T1* ptr)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; const T2&amp;</code> <strong><code>as</code></strong><code>(const T1* ptr)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(unique_ptr&lt;T1&gt;&amp; ptr)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(const unique_ptr&lt;T1&gt;&amp; ptr)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(shared_ptr&lt;T1&gt;&amp; ptr)</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2&amp;</code> <strong><code>as</code></strong><code>(const shared_ptr&lt;T1&gt;&amp; ptr)</code></li>
</ul>
<p>These are simple wrappers around <code>dynamic_cast</code>. The <code>is()</code> function returns
true if the pointer or reference's target has the requested dynamic type;
<code>as()</code> returns a reference to the object converted to the requested dynamic
type, or throws <code>std::bad_cast</code> if the <code>dynamic_cast</code> fails.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T2, typename T1&gt; T2</code> <strong><code>binary_cast</code></strong><code>(const T1&amp; t) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2</code> <strong><code>implicit_cast</code></strong><code>(const T1&amp; t)</code></li>
</ul>
<p>Type conversions. The <code>binary_cast()</code> operation does a simple bitwise copy
from one type to another; it will fail to compile if the two types have
different sizes, but does no other safety checks. The <code>implicit_cast()</code>
operation performs the conversion only if it would be allowed as an implicit
conversion.</p>
</div>
<div class="defns">
<ul>
<li><code>string</code> <strong><code>demangle</code></strong><code>(const string&amp; name)</code></li>
<li><code>string</code> <strong><code>type_name</code></strong><code>(const std::type_info&amp; t)</code></li>
<li><code>string</code> <strong><code>type_name</code></strong><code>(const std::type_index&amp; t)</code></li>
<li><code>template &lt;typename T&gt; string</code> <strong><code>type_name</code></strong><code>()</code></li>
<li><code>template &lt;typename T&gt; string</code> <strong><code>type_name</code></strong><code>(const T&amp;)</code></li>
</ul>
<p>Demangle a type name. The original mangled name can be supplied as an explicit
string, as a <code>std::type_info</code> or <code>std:type_index</code> object, as a type argument
to a template function (e.g. <code>type_name&lt;int&gt;()</code>), or as an object whose type
is to be named (e.g. <code>type_name(42)</code>).</p>
</div>
<h3 id="uuid">UUID</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Uuid</code></strong><ul>
<li><code>Uuid::</code><strong><code>Uuid</code></strong><code>() noexcept</code></li>
<li><code>Uuid::</code><strong><code>Uuid</code></strong><code>(uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint8_t e, uint8_t f, uint8_t g, uint8_t h, uint8_t i, uint8_t j, uint8_t k, uint8_t l, uint8_t m, uint8_t n, uint8_t o, uint8_t p) noexcept</code></li>
<li><code>Uuid::</code><strong><code>Uuid</code></strong><code>(uint32_t abcd, uint16_t ef, uint16_t gh, uint8_t i, uint8_t j, uint8_t k, uint8_t l, uint8_t m, uint8_t n, uint8_t o, uint8_t p) noexcept</code></li>
<li><code>explicit Uuid::</code><strong><code>Uuid</code></strong><code>(uint128_t u) noexcept</code></li>
<li><code>explicit Uuid::</code><strong><code>Uuid</code></strong><code>(const uint8_t* ptr) noexcept</code></li>
<li><code>explicit Uuid::</code><strong><code>Uuid</code></strong><code>(const string&amp; s)</code></li>
<li><code>Uuid::</code><strong><code>Uuid</code></strong><code>(const Uuid&amp; u) noexcept</code></li>
<li><code>Uuid::</code><strong><code>Uuid</code></strong><code>(Uuid&amp;&amp; u) noexcept</code></li>
<li><code>Uuid::</code><strong><code>~Uuid</code></strong><code>() noexcept</code></li>
<li><code>Uuid&amp; Uuid::</code><strong><code>operator=</code></strong><code>(const Uuid&amp; u) noexcept</code></li>
<li><code>Uuid&amp; Uuid::</code><strong><code>operator=</code></strong><code>(Uuid&amp;&amp; u) noexcept</code></li>
<li><code>uint8_t&amp; Uuid::</code><strong><code>operator[](</code></strong><code>size_t i) noexcept</code></li>
<li><code>const uint8_t&amp; Uuid::</code><strong><code>operator[]</code></strong><code>(size_t i) const noexcept</code></li>
<li><code>uint8_t* Uuid::</code><strong><code>begin</code></strong><code>() noexcept</code></li>
<li><code>const uint8_t* Uuid::</code><strong><code>begin</code></strong><code>() const noexcept</code></li>
<li><code>uint8_t* Uuid::</code><strong><code>end</code></strong><code>() noexcept</code></li>
<li><code>const uint8_t* Uuid::</code><strong><code>end</code></strong><code>() const noexcept</code></li>
<li><code>uint128_t Uuid::</code><strong><code>as_integer</code></strong><code>() const noexcept</code></li>
<li><code>size_t Uuid::</code><strong><code>hash</code></strong><code>() const noexcept</code></li>
<li><code>u8string Uuid::</code><strong><code>str</code></strong><code>() const</code></li>
</ul>
</li>
<li><code>bool</code> <strong><code>operator==</code></strong><code>(const Uuid&amp; lhs, const Uuid&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator!=</code></strong><code>(const Uuid&amp; lhs, const Uuid&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&lt;</code></strong><code>(const Uuid&amp; lhs, const Uuid&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&gt;</code></strong><code>(const Uuid&amp; lhs, const Uuid&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&lt;=</code></strong><code>(const Uuid&amp; lhs, const Uuid&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&gt;=</code></strong><code>(const Uuid&amp; lhs, const Uuid&amp; rhs) noexcept</code></li>
<li><code>std::ostream&amp;</code> <strong><code>operator&lt;&lt;</code></strong><code>(std::ostream&amp; o, const Uuid&amp; u)</code></li>
<li><code>class std::</code><strong><code>hash</code></strong><code>&lt;Uuid&gt;</code></li>
</ul>
<p>This class holds a standard 16 byte universally unique identifier (UUID).</p>
<p>The default constructor sets all bytes to zero. The second and third
constructors accept explicit byte values, either as a list of 16 bytes, or in
the standard breakdown format. The fourth constructor copies a UUID from a 128
bit integer, in big endian order. The fifth constructor copies the next 16
bytes from the location pointed to; a null pointer will set all bytes to zero.</p>
<p>The sixth constructor parses the string representation of a UUID. It expects
the string to hold exactly 32 hex digits, in groups each containing an even
number of digits (optionally prefixed with <code>"0x"</code>), and will treat any
characters that are not ASCII alphanumerics as delimiters. It will throw
<code>std::invalid_argument</code> if the string is not a valid UUID.</p>
<p>The <code>begin()</code>, <code>end()</code>, and <code>operator[]</code> functions grant access to the byte
representation. Behaviour is undefined if the index to <code>operator[]</code> is greater
than 15.</p>
<p>The <code>as_integer()</code> function returns the UUID as a 128 bit integer, in big
endian order.</p>
<p>A specialization of <code>std::hash</code> is provided to allow <code>Uuid</code> to be used as the
key in an unordered container.</p>
<p>The <code>str()</code> function, and the output operator, format the UUID in the standard
broken down hex representation, e.g. <code>"01234567-89ab-cdef-0123-456789abcdef"</code>.</p>
<p>The comparison operators perform the natural bytewise lexicographical
comparisons.</p>
</div>
<div class="defns">
<ul>
<li><code>struct</code> <strong><code>RandomUuid</code></strong><ul>
<li><code>using RandomUuid::</code><strong><code>result_type</code></strong> <code>= RandomUuid::Uuid</code></li>
<li><code>template &lt;typename Rng&gt; Uuid RandomUuid::</code><strong><code>operator()</code></strong><code>(Rng&amp; rng) const</code></li>
</ul>
</li>
</ul>
<p>Generates a random version 4 UUID.</p>
</div>
<h3 id="version-number">Version number</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Version</code></strong><ul>
<li><code>using Version::</code><strong><code>value_type</code></strong> <code>= unsigned</code></li>
<li><code>Version::</code><strong><code>Version</code></strong><code>() noexcept</code></li>
<li><code>template &lt;typename... Args&gt; Version::</code><strong><code>Version</code></strong><code>(unsigned n, Args... args)</code></li>
<li><code>explicit Version::</code><strong><code>Version</code></strong><code>(const u8string&amp; s)</code></li>
<li><code>Version::</code><strong><code>Version</code></strong><code>(const Version&amp; v)</code></li>
<li><code>Version::</code><strong><code>Version</code></strong><code>(Version&amp;&amp; v) noexcept</code></li>
<li><code>Version::</code><strong><code>~Version</code></strong><code>() noexcept</code></li>
<li><code>Version&amp; Version::</code><strong><code>operator=</code></strong><code>(const Version&amp; v)</code></li>
<li><code>Version&amp; Version::</code><strong><code>operator=</code></strong><code>(Version&amp;&amp; v) noexcept</code></li>
<li><code>unsigned Version::</code><strong><code>operator[]</code></strong><code>(size_t i) const noexcept</code></li>
<li><code>const unsigned* Version::</code><strong><code>begin</code></strong><code>() const noexcept</code></li>
<li><code>const unsigned* Version::</code><strong><code>end</code></strong><code>() const noexcept</code></li>
<li><code>unsigned Version::</code><strong><code>major</code></strong><code>() const noexcept</code></li>
<li><code>unsigned Version::</code><strong><code>minor</code></strong><code>() const noexcept</code></li>
<li><code>unsigned Version::</code><strong><code>patch</code></strong><code>() const noexcept</code></li>
<li><code>string Version::</code><strong><code>str</code></strong><code>(size_t min_elements = 2) const</code></li>
<li><code>string Version::</code><strong><code>suffix</code></strong><code>() const</code></li>
<li><code>uint32_t Version::</code><strong><code>to32</code></strong><code>() const noexcept</code></li>
<li><code>static Version Version::</code><strong><code>from32</code></strong><code>(uint32_t n) noexcept</code></li>
</ul>
</li>
<li><code>bool</code> <strong><code>operator==</code></strong><code>(const Version&amp; lhs, const Version&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator!=</code></strong><code>(const Version&amp; lhs, const Version&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&lt;</code></strong><code>(const Version&amp; lhs, const Version&amp; rhs) noexcept;</code></li>
<li><code>bool</code> <strong><code>operator&gt;</code></strong><code>(const Version&amp; lhs, const Version&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&lt;=</code></strong><code>(const Version&amp; lhs, const Version&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&gt;=</code></strong><code>(const Version&amp; lhs, const Version&amp; rhs) noexcept</code></li>
<li><code>std::ostream&amp;</code> <strong><code>operator&lt;&lt;</code></strong><code>(std::ostream&amp; o, const Version&amp; v)</code></li>
</ul>
<p>A version number, represented as an array of integers optionally followed by a
trailing string (e.g. <code>1.2.3beta</code>). The default constructor sets the version
number to zero; the second constructor expects one or more integers followed
by a string; the third constructor parses a string (a string that does not
start with an integer is assumed to start with an implicit zero). Results are
unspecified if a version number element is too big to fit in an <code>unsigned
int</code>.</p>
<p>The indexing operator returns the requested element; it will return zero if
the index is out of range for the stored array. The <code>major()</code>, <code>minor()</code>, and
<code>patch()</code> functions return elements 0, 1, and 2. The <code>suffix()</code> function
returns the trailing string element.</p>
<p>The <code>str()</code> function (and the output operator) formats the version number in
the conventional form; a minimum number of elements can be requested. The
<code>to32()</code> and <code>from32()</code> functions pack or unpack the version into a 32 bit
integer, with one byte per element (e.g. version <code>1.2.3</code> becomes
<code>0x01020300</code>); <code>to32()</code> truncates elements higher than 255 and ignores the
string element.</p>
</div>
<h2 id="constants-and-literals">Constants and literals</h2>
<h3 id="arithmetic-constants">Arithmetic constants</h3>
<div class="defns">
<ul>
<li><code>#define</code> <strong><code>PRI_DEFINE_CONSTANT</code></strong><code>(name, value)</code><ul>
<li><code>static constexpr double</code> <strong><code>name</code></strong> <code>= value</code></li>
<li><code>static constexpr float</code> <strong><code>name ## _f</code></strong> <code>= value ## f</code></li>
<li><code>static constexpr long double</code> <strong><code>name ## _ld</code></strong> <code>= value ## l</code></li>
<li><code>template &lt;typename T&gt; static constexpr T</code> <strong><code>name ## _v</code></strong> <code>= T(value ## l)</code></li>
</ul>
</li>
</ul>
<p>Defines a floating point constant, in several forms. This generates a set of
three named constants (for the three standard floating point types) and a
variable template. The <code>value</code> argument must be a floating point literal with
no type suffix.</p>
<p>The values quoted for the following constants are approximate; the values
actually supplied are accurate to at least <code>long double</code> precision where an
exact value is defined, or to the best known accuracy for the empirical
constants.</p>
</div>
<div class="defns">
<ul>
<li><em>Mathematical constants</em><ul>
<li><strong><code>e</code></strong> <em>= 2.7183</em></li>
<li><strong><code>ln_2</code></strong> <em>= log<sub>e</sub> 2 = 0.6931</em></li>
<li><strong><code>ln_10</code></strong> <em>= log<sub>e</sub> 10 = 2.3026</em></li>
<li><strong><code>pi</code></strong> <em>= &pi; = 3.1416</em></li>
<li><strong><code>sqrt_2</code></strong> <em>= &radic;2 = 1.4142</em></li>
<li><strong><code>sqrt_3</code></strong> <em>= &radic;3 = 1.7321</em></li>
<li><strong><code>sqrt_5</code></strong> <em>= &radic;5 = 2.2361</em></li>
<li><strong><code>sqrt_pi</code></strong> <em>= &radic;&pi; = 1.7725</em></li>
<li><strong><code>sqrt_2pi</code></strong> <em>= &radic;2&pi; = 2.5066</em></li>
</ul>
</li>
<li><em>Conversion factors</em><ul>
<li><strong><code>inch</code></strong> <em>= 0.0254 m</em></li>
<li><strong><code>foot</code></strong> <em>= 0.3048 m</em></li>
<li><strong><code>yard</code></strong> <em>= 0.9144 m</em></li>
<li><strong><code>mile</code></strong> <em>= 1609 m</em></li>
<li><strong><code>nautical_mile</code></strong> <em>= 1852 m</em></li>
<li><strong><code>ounce</code></strong> <em>= 0.02835 kg</em></li>
<li><strong><code>pound</code></strong> <em>= 0.4536 kg</em></li>
<li><strong><code>short_ton</code></strong> <em>= 907.2 kg</em></li>
<li><strong><code>long_ton</code></strong> <em>= 1016 kg</em></li>
<li><strong><code>pound_force</code></strong> <em>= 4.448 N</em></li>
<li><strong><code>erg</code></strong> <em>= 10<sup>-7</sup> J</em></li>
<li><strong><code>foot_pound</code></strong> <em>= 1.356 J</em></li>
<li><strong><code>calorie</code></strong> <em>= 4.184 J</em></li>
<li><strong><code>ton_tnt</code></strong> <em>= 4.184&times;10<sup>9</sup> J</em></li>
<li><strong><code>horsepower</code></strong> <em>= 745.7 W</em></li>
<li><strong><code>mmHg</code></strong> <em>= 133.3 Pa</em></li>
<li><strong><code>atmosphere</code></strong> <em>= 101300 Pa</em></li>
<li><strong><code>zero_celsius</code></strong> <em>= 273.15 K</em></li>
</ul>
</li>
<li><em>Physical constants</em><ul>
<li><strong><code>atomic_mass_unit</code></strong> <em>= 1.661&times;10<sup>-27</sup> kg</em></li>
<li><strong><code>avogadro_constant</code></strong> <em>= 6.022&times;10<sup>23</sup> mol<sup>-1</sup></em></li>
<li><strong><code>boltzmann_constant</code></strong> <em>= 1.381&times;10<sup>-23</sup> J K<sup>-1</sup></em></li>
<li><strong><code>elementary_charge</code></strong> <em>= 1.602&times;10<sup>-19</sup> C</em></li>
<li><strong><code>gas_constant</code></strong> <em>= 8.314 J mol<sup>-1</sup> K<sup>-1</sup></em></li>
<li><strong><code>gravitational_constant</code></strong> <em>= 6.674&times;10<sup>-11</sup> m<sup>3</sup> kg<sup>-1</sup> s<sup>-2</sup></em></li>
<li><strong><code>planck_constant</code></strong> <em>= 6.626&times;10<sup>-34</sup> J s</em></li>
<li><strong><code>speed_of_light</code></strong> <em>= 2.998&times;10<sup>8</sup> m s<sup>-1</sup></em></li>
<li><strong><code>stefan_boltzmann_constant</code></strong> <em>= 5.670&times;10<sup>-8</sup> W m<sup>-2</sup> K<sup>-4</sup></em></li>
</ul>
</li>
<li><em>Astronomical constants</em><ul>
<li><strong><code>earth_mass</code></strong> <em>= 5.972&times;10<sup>24</sup> kg</em></li>
<li><strong><code>earth_radius</code></strong> <em>= 6.371&times;10<sup>6</sup> m</em></li>
<li><strong><code>earth_gravity</code></strong> <em>= 9.807 m s<sup>-2</sup></em></li>
<li><strong><code>jupiter_mass</code></strong> <em>= 1.899&times;10<sup>27</sup> kg</em></li>
<li><strong><code>jupiter_radius</code></strong> <em>= 6.991&times;10<sup>7</sup> m</em></li>
<li><strong><code>solar_mass</code></strong> <em>= 1.989&times;10<sup>30</sup> kg</em></li>
<li><strong><code>solar_radius</code></strong> <em>= 6.963&times;10<sup>8</sup> m</em></li>
<li><strong><code>solar_luminosity</code></strong> <em>= 3.846&times;10<sup>26</sup> W</em></li>
<li><strong><code>solar_temperature</code></strong> <em>= 5778 K</em></li>
<li><strong><code>astronomical_unit</code></strong> <em>= 1.496&times;10<sup>11</sup> m</em></li>
<li><strong><code>light_year</code></strong> <em>= 9.461&times;10<sup>15</sup> m</em></li>
<li><strong><code>parsec</code></strong> <em>= 3.086&times;10<sup>16</sup> m</em></li>
<li><strong><code>julian_day</code></strong> <em>= 86400 s</em></li>
<li><strong><code>julian_year</code></strong> <em>= 31557600 s</em></li>
<li><strong><code>sidereal_year</code></strong> <em>= 31558150 s</em></li>
<li><strong><code>tropical_year</code></strong> <em>= 31556925 s</em></li>
</ul>
</li>
</ul>
</div>
<h3 id="arithmetic-literals">Arithmetic literals</h3>
<p>These are all in <code>namespace Prion::Literals</code>.</p>
<div class="defns">
<ul>
<li><code>constexpr int8_t</code> <strong><code>operator""_s8</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr uint8_t</code> <strong><code>operator""_u8</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr int16_t</code> <strong><code>operator""_s16</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr uint16_t</code> <strong><code>operator""_u16</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr int32_t</code> <strong><code>operator""_s32</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr uint32_t</code> <strong><code>operator""_u32</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr int64_t</code> <strong><code>operator""_s64</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>constexpr uint64_t</code> <strong><code>operator""_u64</code></strong><code>(unsigned long long n) noexcept</code></li>
<li><code>template &lt;char... CS&gt; constexpr int128_t</code> <strong><code>operator""_s128</code></strong><code>() noexcept</code></li>
<li><code>template &lt;char... CS&gt; constexpr uint128_t</code> <strong><code>operator""_u128</code></strong><code>() noexcept</code></li>
</ul>
<p>Integer literals.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;char... CS&gt; constexpr ptrdiff_t</code> <strong><code>operator""_t</code></strong><code>() noexcept</code></li>
<li><code>template &lt;char... CS&gt; constexpr size_t</code> <strong><code>operator""_z</code></strong><code>() noexcept</code></li>
</ul>
<p>Literals for <code>ptrdiff_t</code> and <code>size_t</code>, anticipating similar features in C++17
(see ISO N4254).</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr unsigned long long</code> <strong><code>operator""_KB</code></strong><code>(unsigned long long n) noexcept</code> <em>(&times; 2<sup>10</sup> = 1024)</em></li>
<li><code>constexpr unsigned long long</code> <strong><code>operator""_MB</code></strong><code>(unsigned long long n) noexcept</code> <em>(&times; 2<sup>20</sup> = 1 048 576)</em></li>
<li><code>constexpr unsigned long long</code> <strong><code>operator""_GB</code></strong><code>(unsigned long long n) noexcept</code> <em>(&times; 2<sup>30</sup> = 1 073 741 824)</em></li>
<li><code>constexpr unsigned long long</code> <strong><code>operator""_TB</code></strong><code>(unsigned long long n) noexcept</code> <em>(&times; 2<sup>40</sup> = 1 099 511 627 776)</em></li>
</ul>
<p>Integer literals for abbreviating large constants.</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr float</code> <strong><code>operator""_degf</code></strong><code>(long double x) noexcept</code></li>
<li><code>constexpr float</code> <strong><code>operator""_degf</code></strong><code>(unsigned long long x) noexcept</code></li>
<li><code>constexpr double</code> <strong><code>operator""_deg(</code></strong><code>long double x) noexcept</code></li>
<li><code>constexpr double</code> <strong><code>operator""_deg(</code></strong><code>unsigned long long x) noexcept</code></li>
<li><code>constexpr long double</code> <strong><code>operator""_degl</code></strong><code>(long double x) noexcept</code></li>
<li><code>constexpr long double</code> <strong><code>operator""_degl</code></strong><code>(unsigned long long x) noexcept</code></li>
</ul>
<p>Angle literals, converting degrees to radians.</p>
</div>
<h3 id="string-related-constants">String related constants</h3>
<div class="defns">
<ul>
<li><code>constexpr const char*</code> <strong><code>ascii_whitespace</code></strong> <code>= "\t\n\v\f\r "</code></li>
</ul>
<p>ASCII whitespace characters.</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr size_t</code> <strong><code>npos</code></strong> <code>= string::npos</code></li>
</ul>
<p>Defined for convenience. Following the conventions established by the standard
library, this value is often used as a function argument to mean "as large as
possible" or "no limit", or as a return value to mean "not found".</p>
</div>
<h3 id="other-constants">Other constants</h3>
<div class="defns">
<ul>
<li><code>constexpr bool</code> <strong><code>big_endian_target</code></strong></li>
<li><code>constexpr bool</code> <strong><code>little_endian_target</code></strong></li>
</ul>
<p>One of these will be true and the other false, reflecting the target system's
byte order.</p>
</div>
<h2 id="algorithms-and-ranges">Algorithms and ranges</h2>
<h3 id="generic-algorithms">Generic algorithms</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename Container&gt; [output iterator]</code> <strong><code>append</code></strong><code>(Container&amp; con)</code></li>
<li><code>template &lt;typename Container&gt; [output iterator]</code> <strong><code>overwrite</code></strong><code>(Container&amp; con)</code></li>
</ul>
<p>These create output iterators that will append elements to a standard
container. The <code>append()</code> function is similar to <code>std::back_inserter()</code> (but
supports containers without <code>push_back()</code>), while <code>overwrite()</code> will first
clear the container and then return the append iterator.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Range1, typename Range2&gt; int</code> <strong><code>compare_3way</code></strong><code>(const Range1&amp; r1, const Range2&amp; r2)</code></li>
<li><code>template &lt;typename Range1, typename Range2, typename Compare&gt; int</code> <strong><code>compare_3way</code></strong><code>(const Range1&amp; r1, const Range2&amp; r2, Compare cmp)</code></li>
</ul>
<p>Compare two ranges, returning -1 if the first range is less than the second,
zero if they are equal, and +1 if the first range is greater.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Range, typename Container&gt; void</code> <strong><code>con_append</code></strong><code>(const Range&amp; src, Container&amp; dst)</code></li>
<li><code>template &lt;typename Range, typename Container&gt; void</code> <strong><code>con_overwrite</code></strong><code>(const Range&amp; src, Container&amp; dst)</code></li>
</ul>
<p>These are just shorthand for a <code>std::copy()</code> from a range to an append or
overwrite iterator.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Container, typename T&gt; void</code> <strong><code>con_remove</code></strong><code>(Container&amp; con, const T&amp; t)</code></li>
<li><code>template &lt;typename Container, typename Predicate&gt; void</code> <strong><code>con_remove_if</code></strong><code>(Container&amp; con, Predicate p)</code></li>
<li><code>template &lt;typename Container, typename Predicate&gt; void</code> <strong><code>con_remove_if_not</code></strong><code>(Container&amp; con, Predicate p)</code></li>
<li><code>template &lt;typename Container&gt; void</code> <strong><code>con_unique</code></strong><code>(Container&amp; con)</code></li>
<li><code>template &lt;typename Container, typename BinaryPredicate&gt; void</code> <strong><code>con_unique</code></strong><code>(Container&amp; con, BinaryPredicate p)</code></li>
<li><code>template &lt;typename Container&gt; void</code> <strong><code>con_sort_unique</code></strong><code>(Container&amp; con)</code></li>
<li><code>template &lt;typename Container, typename Compare&gt; void</code> <strong><code>con_sort_unique</code></strong><code>(Container&amp; con, Compare cmp)</code></li>
</ul>
<p>These carry out the same algorithms as the similarly named STL functions,
except that unwanted elements are removed from the container rather than
shuffled to the end. The <code>con_sort_unique()</code> functions perform a sort followed
by removing equivalent elements from the container; like <code>std::sort()</code>, its
predicate has less-than semantics (whereas that of <code>con_unique()</code>, like that
of <code>std::unique()</code>, has equality semantics).</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename F&gt; void</code> <strong><code>do_n</code></strong><code>(size_t n, F f)</code></li>
<li><code>template &lt;typename F&gt; void</code> <strong><code>for_n</code></strong><code>(size_t n, F f)</code></li>
</ul>
<p>These simply call the function <code>n</code> times. The <code>do_n()</code> loop expects a function
that takes no arguments, while <code>for_n()</code> passes the iteration count (zero to
<code>n-1</code>) as an argument.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename M, typename K&gt; M::mapped_type</code> <strong><code>find_in_map</code></strong><code>(const M&amp; map, const K&amp; key)</code></li>
<li><code>template &lt;typename M, typename K, typename T&gt; M::mapped_type</code> <strong><code>find_in_map</code></strong><code>(const M&amp; map, const K&amp; key, const T&amp; def)</code></li>
</ul>
<p>Find a key in a map, returning the corresponding value, or the supplied
default value (or a default constructed <code>mapped_type</code>) if the key is not
found.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Range1, typename Range2&gt; bool</code> <strong><code>sets_intersect</code></strong><code>(const Range1&amp; r1, const Range2&amp; r2)</code></li>
<li><code>template &lt;typename Range1, typename Range2, typename Compare&gt; bool</code> <strong><code>sets_intersect</code></strong><code>(const Range1&amp; r1, const Range2&amp; r2, Compare c)</code></li>
</ul>
<p>Test whether two ordered ranges (sets) have any elements in common. The ranges
are assumed to be ordered in accordance with the comparison predicate.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename Range&gt; [value type]</code> <strong><code>sum_of</code></strong><code>(const Range&amp; r)</code></li>
<li><code>template &lt;typename Range&gt; [value type]</code> <strong><code>product_of</code></strong><code>(const Range&amp; r)</code></li>
</ul>
<p>Simple range sum and product functions, to save the trouble of calling
<code>std::accumulate()</code> in trivial cases. Calling <code>sum_of()</code> on an empty range
will return a default constructed value. The value type of <code>product_of()</code> must
be constructible by a <code>static_cast</code> from <code>int</code>; an empty range will return 1.</p>
</div>
<h3 id="integer-sequences">Integer sequences</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>iseq</code></strong><code>(T stop) noexcept</code></li>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>iseq</code></strong><code>(T init, T stop) noexcept</code></li>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>iseq</code></strong><code>(T init, T stop, T delta) noexcept</code></li>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>xseq</code></strong><code>(T stop) noexcept</code></li>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>xseq</code></strong><code>(T init, T stop) noexcept</code></li>
<li><code>template &lt;typename T&gt; Irange&lt;[random access iterator]&gt;</code> <strong><code>xseq</code></strong><code>(T init, T stop, T delta) noexcept</code></li>
</ul>
<p>Linear sequences of integers (<code>T</code> must be an integer type). The generated
range starts with <code>init</code> (defaulting to zero) and runs to <code>stop</code>, in steps of
<code>delta</code> (defaulting to 1). The <code>iseq()</code> function produces an inclusive
(closed) sequence that includes <code>stop</code>, while <code>xseq()</code> is an exclusive (half
open) sequence that excludes it (if the exact value <code>stop</code> would never be
generated, because <code>stop-init</code> is not a multiple of <code>delta</code>, there is no
difference between the two).</p>
<p>If <code>stop=init</code>, or if <code>delta=0</code>, the <code>iseq()</code> sequence contains a single
value, while the <code>xseq()</code> sequence is empty. Both sequences will be empty if
<code>stop-init</code> and <code>delta</code> have opposite signs.</p>
<p>The iterators must be able to generate a value beyond the end of the sequence
in order to check for an end iterator; for <code>iseq()</code>, this means that
<code>stop+delta</code> must be in range for <code>T</code>.</p>
</div>
<h3 id="memory-algorithms">Memory algorithms</h3>
<div class="defns">
<ul>
<li><code>int</code> <strong><code>mem_compare</code></strong><code>(const void* lhs, size_t n1, const void* rhs, size_t n2) noexcept</code></li>
</ul>
<p>This returns -1 if the first block is less than the second (by a
lexicographical bytewise comparison), 0 if they are equal, 1 if the first is
greater than the second. If the two blocks are equal up to the length of the
shorter one, the shorter is considered less than the longer. This is similar
to <code>memcmp()</code>, except that the memory blocks being compared may have different
lengths. A null pointer is treated as less than any non-null pointer; the
length accompanying a null pointer is ignored.</p>
</div>
<div class="defns">
<ul>
<li><code>void</code> <strong><code>mem_swap</code></strong><code>(void* ptr1, void* ptr2, size_t n) noexcept</code></li>
</ul>
<p>Swap two blocks of memory. This will work if the two ranges overlap or are the
same, but behaviour is undefined if either pointer is null.</p>
</div>
<h3 id="range-traits">Range traits</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename Range&gt; using</code> <strong><code>RangeIterator</code></strong> <code>= ...</code></li>
<li><code>template &lt;typename Range&gt; using</code> <strong><code>RangeValue</code></strong> <code>= ...</code></li>
</ul>
<p>The iterator and value types of a range.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, size_t N&gt; constexpr size_t</code> <strong><code>array_count</code></strong><code>(T[N]) noexcept</code></li>
<li><code>template &lt;typename Range&gt; size_t</code> <strong><code>range_count</code></strong><code>(const Range&amp; r)</code></li>
<li><code>template &lt;typename Range&gt; bool</code> <strong><code>range_empty</code></strong><code>(const Range&amp; r)</code></li>
</ul>
<p>Return the length of a range. The <code>range_count()</code> function is just shorthand
for <code>std::distance(begin(r),end(r))</code>, and <code>range_empty()</code> has the obvious
meaning. The <code>array_count()</code> version returns the same value, but only works on
C-style arrays and is <code>constexpr</code>.</p>
</div>
<h3 id="range-types">Range types</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename Iterator&gt; struct</code> <strong><code>Irange</code></strong><ul>
<li><code>using Irange::</code><strong><code>iterator</code></strong> <code>= Iterator</code></li>
<li><code>using Irange::</code><strong><code>value_type</code></strong> <code>= [Iterator's value type]</code></li>
<li><code>Iterator Irange::</code><strong><code>first</code></strong></li>
<li><code>Iterator Irange::</code><strong><code>second</code></strong></li>
<li><code>constexpr Iterator Irange::</code><strong><code>begin</code></strong><code>() const { return first; }</code></li>
<li><code>constexpr Iterator Irange::</code><strong><code>end</code></strong><code>() const { return second; }</code></li>
<li><code>constexpr bool Irange::</code><strong><code>empty</code></strong><code>() const { return first == second; }</code></li>
<li><code>constexpr size_t Irange::</code><strong><code>size</code></strong><code>() const { return std::distance(first, second); }</code></li>
</ul>
</li>
<li><code>template &lt;typename Iterator&gt; constexpr Irange&lt;Iterator&gt;</code> <strong><code>irange</code></strong><code>(const Iterator&amp; i, const Iterator&amp; j)</code></li>
<li><code>template &lt;typename Iterator&gt; constexpr Irange&lt;Iterator&gt;</code> <strong><code>irange</code></strong><code>(const pair&lt;Iterator, Iterator&gt;&amp; p)</code></li>
</ul>
<p>A wrapper for a pair of iterators, usable as a range in standard algorithms.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr Irange&lt;T*&gt;</code> <strong><code>array_range</code></strong><code>(T* ptr, size_t len)</code></li>
</ul>
<p>Returns <code>irange(ptr,ptr+len)</code>.</p>
</div>
<h2 id="arithmetic-functions">Arithmetic functions</h2>
<p>Some of these duplicate functionality already in the standard library; this is
to ensure that the functions are available for 128 bit integers even if the
standard library implementation doesn't support them.</p>
<h3 id="generic-arithmetic-functions">Generic arithmetic functions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T, typename... Args&gt; constexpr T</code> <strong><code>static_min</code></strong><code>(T t, Args... args) noexcept</code></li>
<li><code>template &lt;typename T, typename... Args&gt; constexpr T</code> <strong><code>static_max</code></strong><code>(T t, Args... args) noexcept</code></li>
</ul>
<p>Compile time maximum and minimum functions.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; T</code> <strong><code>abs</code></strong><code>(T t) noexcept</code></li>
</ul>
<p>Absolute value function. This is the same as <code>std::abs()</code> apart from
guaranteeing 128 bit integer support.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, typename T2, typename T3&gt; constexpr T</code> <strong><code>clamp</code></strong><code>(const T&amp; x, const T2&amp; min, const T3&amp; max) noexcept</code></li>
</ul>
<p>Clamps a value to a fixed range. This returns <code>static_cast&lt;T&gt;(min)</code> if
<code>t&lt;min</code>, <code>static_cast&lt;T&gt;(max)</code> if <code>t&gt;max</code>, otherwise <code>t</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; pair&lt;T, T&gt;</code> <strong><code>divide</code></strong><code>(T lhs, T rhs) noexcept</code></li>
<li><code>template &lt;typename T&gt; T</code> <strong><code>quo</code></strong><code>(T lhs, T rhs) noexcept</code></li>
<li><code>template &lt;typename T&gt; T</code> <strong><code>rem</code></strong><code>(T lhs, T rhs) noexcept</code></li>
</ul>
<p>These perform floor division operations: if the division is not exact, the
remainder is always positive (regardless of the signs of the arguments), and
the quotient is the integer that satisfies <code>lhs=quo*rhs+rem</code> (apart from
rounding errors). The pair returned by <code>divide()</code> contains the quotient and
remainder. For all three functions, behaviour is undefined if <code>rhs=0</code> or the
quotient is out of <code>T</code>'s representable range.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; T</code> <strong><code>shift_left</code></strong><code>(T t, int n) noexcept</code></li>
<li><code>template &lt;typename T&gt; T</code> <strong><code>shift_right</code></strong><code>(T t, int n) noexcept</code></li>
</ul>
<p>Multiply or divide <code>t</code> by <code>2<sup>n</sup></code>. <code>T</code> may be an integer or
floating point type. Results are unspecified if the correct result would be
out of <code>T</code>'s representable range.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr int</code> <strong><code>sign_of</code></strong><code>(T t) noexcept</code></li>
</ul>
<p>Returns the sign of its argument (-1 if <code>t&lt;0</code>, 0 if <code>t=0</code>, 1 if <code>t&gt;0</code>).</p>
</div>
<h3 id="integer-arithmetic-functions">Integer arithmetic functions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr std::make_signed_t&lt;T&gt;</code> <strong><code>as_signed</code></strong><code>(T t) noexcept</code></li>
<li><code>template &lt;typename T&gt; constexpr std::make_unsigned_t&lt;T&gt;</code> <strong><code>as_unsigned</code></strong><code>(T t) noexcept</code></li>
</ul>
<p>These return their argument converted to a signed or unsigned value of the
same size (the argument is returned unchanged if <code>T</code> already had the desired
signedness). Behaviour is undefined if <code>T</code> is not an integer or enumeration
type.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; T</code> <strong><code>binomial</code></strong><code>(T a, T b) noexcept</code></li>
<li><code>double</code> <strong><code>xbinomial</code></strong><code>(int a, int b) noexcept</code></li>
</ul>
<p>These return the binomial coefficient (<code>a!/b!(a-b)!</code> if <code>0&lt;=b&lt;=a</code>, otherwise
zero). <code>T</code> must be an integer type. Behaviour is undefined if the correct
result would be out of range for the return type.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>gcd</code></strong><code>(T a, T b) noexcept</code></li>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>lcm</code></strong><code>(T a, T b) noexcept</code></li>
</ul>
<p>Return the greatest common divisor or lowest common multiple of two numbers.
The argument type must be an integer. If one argument is zero, <code>gcd()</code> will
return the other one, and <code>lcm()</code> will return zero. The return value is always
positive (if not zero), regardless of the signs of the arguments. If the
correct result for <code>lcm()</code> would be outside the range of <code>T</code>, behaviour is
undefined if <code>T</code> is signed, unspecified if <code>T</code> is unsigned.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; T</code> <strong><code>int_power</code></strong><code>(T x, T y) noexcept</code></li>
</ul>
<p>Calculates <code>x<sup>y</sup></code> for integer types.
<code>0<sup>0</sup></code> will return 1. Behaviour is undefined if <code>y</code> is
negative, or if <code>T</code> is signed and the true result would be out of range.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; T</code> <strong><code>int_sqrt</code></strong><code>(T t) noexcept</code></li>
</ul>
<p>Returns the integer square root of the argument (the true square root
truncated to an integer). Behaviour is undefined if the argument is negative.</p>
</div>
<h3 id="bitwise-operations">Bitwise operations</h3>
<div class="defns">
<ul>
<li><code>constexpr size_t</code> <strong><code>binary_size</code></strong><code>(uint64_t x) noexcept</code></li>
</ul>
<p>Returns the size of the argument in bits (i.e. the index of the highest 1 bit
plus 1, or zero if the argument is zero).</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr size_t</code> <strong><code>bits_set</code></strong><code>(uint64_t x) noexcept</code></li>
</ul>
<p>Returns the number of 1 bits in <code>x</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr uint64_t</code> <strong><code>letter_to_mask</code></strong><code>(char c) noexcept</code></li>
</ul>
<p>Converts a letter to a mask with bit 0-51 set. The result is unspecified if
the argument is not an ASCII letter.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>rotl</code></strong><code>(T t, int n) noexcept</code></li>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>rotr</code></strong><code>(T t, int n) noexcept</code></li>
</ul>
<p>Bitwise rotate left or right. The bit count is reduced modulo the number of
bits in <code>T</code>; a negative shift in one direction is treated as a positive shift
in the other.</p>
</div>
<h3 id="floating-point-arithmetic-functions">Floating point arithmetic functions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>degrees</code></strong><code>(T rad) noexcept</code></li>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>radians</code></strong><code>(T deg) noexcept</code></li>
</ul>
<p>Convert between degrees and radians.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T1, typename T2&gt; constexpr T2</code> <strong><code>interpolate</code></strong><code>(T1 x1, T2 y1, T1 x2, T2 y2, T1 x) noexcept</code></li>
</ul>
<p>Returns the value of <code>y</code> corresponding to <code>x</code>, by interpolating or
extrapolating the line between <code>(x1,y1)</code> and <code>(x2,y2)</code>. If <code>x1=x2</code> it will
return the average of <code>y1</code> and <code>y2</code>. The usual arithmetic rules apply if the
result is not representable by the return type.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T2, typename T1&gt; T2</code> <strong><code>iceil</code></strong><code>(T1 value) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2</code> <strong><code>ifloor</code></strong><code>(T1 value) noexcept</code></li>
<li><code>template &lt;typename T2, typename T1&gt; T2</code> <strong><code>round</code></strong><code>(T1 value) noexcept</code></li>
</ul>
<p>Rounds the argument toward positive infinity (<code>iceil()</code>), toward negative
infinity (<code>ifloor()</code>), or to the nearest integer (<code>round()</code>; halves round up),
converting the result to the specified return type. The usual arithmetic rules
apply if the result is not representable by the return type.</p>
</div>
<h2 id="functional-utilities">Functional utilities</h2>
<h3 id="function-traits">Function traits</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename Function&gt; struct</code> <strong><code>Arity</code></strong><ul>
<li><code>static constexpr size_t Arity::</code><strong><code>value</code></strong></li>
</ul>
</li>
<li><code>template &lt;typename Function&gt; using</code> <strong><code>ArgumentTuple</code></strong> <code>= [tuple type]</code></li>
<li><code>template &lt;typename Function, size_t Index&gt; using</code> <strong><code>ArgumentType</code></strong> <code>= [type of given argument]</code></li>
<li><code>template &lt;typename Function&gt; using</code> <strong><code>ReturnType</code></strong> <code>= [return type]</code></li>
<li><code>template &lt;typename Function&gt; using</code> <strong><code>FunctionSignature</code></strong> <code>= [result(args...)]</code></li>
<li><code>template &lt;typename Function&gt; using</code> <strong><code>StdFunction</code></strong> <code>= function&lt;FunctionSignature&lt;Function&gt;&gt;</code></li>
</ul>
<p>Properties of a function type. This will work with ordinary functions (if not
overloaded), function pointers, function objects, lambda expressions, and
<code>std::function</code> instantiations.</p>
</div>
<h3 id="function-operations">Function operations</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename Function&gt; StdFunction&lt;Function&gt;</code> <strong><code>stdfun</code></strong><code>(Function&amp; f)</code></li>
</ul>
<p>Wraps a function in the appropriate standard function type.</p>
</div>
<div class="defns">
<ul>
<li><code>template&lt;typename Function, typename Tuple&gt; decltype(auto)</code> <strong><code>tuple_invoke</code></strong><code>(Function&amp;&amp; f, Tuple&amp;&amp; t)</code></li>
</ul>
<p>Calls a function, passing a tuple as the argument list.</p>
</div>
<h3 id="generic-function-objects">Generic function objects</h3>
<div class="defns">
<ul>
<li><code>struct</code> <strong><code>DoNothing</code></strong><ul>
<li><code>void</code> <strong><code>operator()</code></strong><code>() const noexcept {}</code></li>
<li><code>template &lt;typename T&gt; void</code> <strong><code>operator()</code></strong><code>(T&amp;) const noexcept {}</code></li>
<li><code>template &lt;typename T&gt; void</code> <strong><code>operator()</code></strong><code>(const T&amp;) const noexcept {}</code></li>
</ul>
</li>
<li><code>constexpr DoNothing</code> <strong><code>do_nothing</code></strong></li>
<li><code>struct</code> <strong><code>Identity</code></strong><ul>
<li><code>template &lt;typename T&gt; T&amp;</code> <strong><code>operator()</code></strong><code>(T&amp; t) const noexcept { return t; }</code></li>
<li><code>template &lt;typename T&gt; const T&amp;</code> <strong><code>operator()</code></strong><code>(const T&amp; t) const noexcept { return t; }</code></li>
</ul>
</li>
<li><code>constexpr Identity</code> <strong><code>identity</code></strong></li>
</ul>
<p>Trivial function objects.</p>
</div>
<h3 id="hash-functions">Hash functions</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Djb2a</code></strong><ul>
<li><code>Djb2a&amp;</code> <strong><code>Djb2a</code></strong><code>::operator()(const void* ptr, size_t n) noexcept</code></li>
<li><code>Djb2a&amp;</code> <strong><code>Djb2a</code></strong><code>::operator()(const string&amp; s) noexcept</code></li>
<li><code>Djb2a::</code><strong><code>operator uint32_t</code></strong><code>() const noexcept</code></li>
</ul>
</li>
<li><code>uint32_t</code> <strong><code>djb2a</code></strong><code>(const void* ptr, size_t n) noexcept</code></li>
</ul>
<p>A simple, efficient hash algorithm for a string of bytes.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename... Args&gt; size_t</code> <strong><code>hash_value</code></strong><code>(const Args&amp;... args) noexcept</code></li>
<li><code>template &lt;typename... Args&gt; void</code> <strong><code>hash_combine</code></strong><code>(size_t&amp; hash, const Args&amp;... args) noexcept</code></li>
<li><code>template &lt;typename Range&gt; size_t</code> <strong><code>hash_range</code></strong><code>(const Range&amp; range) noexcept</code></li>
<li><code>template &lt;typename Range&gt; void</code> <strong><code>hash_range</code></strong><code>(size_t&amp; hash, const Range&amp; range) noexcept</code></li>
</ul>
<p>Functions for combining hashes incrementally, or for generating the hash of a
number of objects in one call, for use in implementing hash functions for
compound types. The first version of each pair of functions (<code>hash_value()</code>
and <code>hash_combine()</code> have different names to avoid overload resolution
problems) calculates the hash of the supplied data; the second version takes
an existing hash value and mixes it with additional data. All of these call
the element type's <code>std::hash</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename... Args&gt; struct</code> <strong><code>TupleHash</code></strong><ul>
<li><code>size_t</code> <strong><code>operator()</code></strong><code>(const tuple&lt;Args...&gt;&amp; t) const</code></li>
</ul>
</li>
</ul>
<p>Hash function for a tuple.</p>
</div>
<h3 id="keyword-arguments">Keyword arguments</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename K&gt; struct</code> <strong><code>Kwarg</code></strong><ul>
<li><code>template &lt;typename A&gt; ... Kwarg::</code><strong><code>operator=</code></strong><code>(const A&amp; arg) const</code></li>
</ul>
</li>
<li><code>template &lt;typename K, typename V, typename... Args&gt; bool</code> <strong><code>kwget</code></strong><code>(const Kwarg&lt;K&gt;&amp; key, V&amp; var, const Args&amp;... args)</code></li>
</ul>
<p>This provides a simple implementation of variadic keyword arguments for C++
functions.</p>
<p>Define a <code>Kwarg&lt;K&gt;</code> object for each keyword argument, where <code>K</code> is the
argument type. Functions that will take keyword arguments should be declared
with a variadic argument pack, possibly preceded by ordinary positional
arguments. The variadic arguments must be passed by reference, since the
global <code>Kwarg</code> objects are identified by address.</p>
<p>When calling the function, the keyword arguments should be supplied in the
form <code>key=value</code>, where <code>key</code> is a <code>Kwarg&lt;K&gt;</code> object, and <code>value</code> is the
argument value. The value type must be convertible to <code>K</code>. If <code>K</code> is <code>bool</code>,
the keyword alone can be passed as an argument, with the value defaulting to
<code>true</code>.</p>
<p>In the function body, call <code>kwget()</code> for each possible keyword argument, with
the corresponding <code>Kwarg&lt;K&gt;</code> object as the key, a reference to the variable
that will receive the value, and the variadic arguments from the enclosing
function. The variable passed by reference will be updated with the value
supplied with the key, or left unchanged if no corresponding keyword argument
was supplied. The return value indicates whether the variable was updated. If
the same key appears more than once in the actual argument list, it is
unspecified which value will be copied.</p>
<p>Example:</p>
<pre><code>constexpr Kwarg&lt;int&gt; win_width, win_height;
constexpr Kwarg&lt;string&gt; win_title;
constexpr Kwarg&lt;bool&gt; win_visible;

class Window {
public:
    template &lt;typename... Args&gt; explicit Window(const Args&amp;... args) {
        int width = 640, height = 480;
        string title = "New Window";
        bool visible = false;
        kwget(win_width, width, args...);
        kwget(win_height, height, args...);
        kwget(win_title, title, args...);
        kwget(win_visible, visible, args...);
        // ...
    }
};

Window app_window(win_title = "Hello World", win_width = 1024, win_height = 768, win_visible);
</code></pre>
</div>
<h3 id="scope-guards">Scope guards</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>Resource</code></strong><ul>
<li><code>using Resource::</code><strong><code>resource_type</code></strong> <code>= T</code></li>
<li><code>using Resource::</code><strong><code>value_type</code></strong> <code>= [dereferenced T]</code> <em>[only if T is a pointer]</em></li>
<li><code>Resource::</code><strong><code>Resource</code></strong><code>() noexcept</code></li>
<li><code>explicit Resource::</code><strong><code>Resource</code></strong><code>(T t)</code></li>
<li><code>template &lt;typename D&gt; Resource::</code><strong><code>Resource</code></strong><code>(T t, D d)</code></li>
<li><code>Resource::</code><strong><code>Resource</code></strong><code>(Resource&amp;&amp; r) noexcept</code></li>
<li><code>Resource::</code><strong><code>~Resource</code></strong><code>() noexcept</code></li>
<li><code>Resource&amp; Resource::</code><strong><code>operator=</code></strong><code>(Resource&amp;&amp; r) noexcept</code></li>
<li><code>Resource::</code><strong><code>operator T&amp;</code></strong><code>() noexcept</code></li>
<li><code>Resource::</code><strong><code>operator T</code></strong><code>() const noexcept</code></li>
<li><code>explicit Resource::</code><strong><code>operator bool</code></strong><code>() const noexcept</code></li>
<li><code>bool Resource::</code><strong><code>operator!</code></strong><code>() const noexcept</code></li>
<li><code>value_type&amp; Resource::</code><strong><code>operator*</code></strong><code>() noexcept</code> <em>[only if T is a non-void pointer]</em></li>
<li><code>const value_type&amp; Resource::</code><strong><code>operator*</code></strong><code>() const noexcept</code> <em>[only if T is a non-void pointer]</em></li>
<li><code>T Resource::</code><strong><code>operator-&gt;</code></strong><code>() const noexcept</code> <em>[only if T is a non-void pointer]</em></li>
<li><code>T&amp; Resource::</code><strong><code>get</code></strong><code>() noexcept</code></li>
<li><code>T Resource::</code><strong><code>get</code></strong><code>() const noexcept</code></li>
<li><code>T Resource::</code><strong><code>release</code></strong><code>() noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T, typename D&gt; Resource&lt;T&gt;</code> <strong><code>make_resource</code></strong><code>(T t, D d)</code></li>
</ul>
<p>This holds a resource of some kind, and a deleter function that will be called
on destruction, similar to a <code>unique_ptr</code> (but without the requirement that
the resource type be a pointer, or that the deleter type be specified
explicitly in the class template). The deleter function passed to the
constructor is expected to take a single argument of type <code>T</code>; it defaults to
a null function. The destructor will call <code>d(t)</code>, unless <code>release()</code> has been
called, the resource object has been moved from, or the deleter is null. The
constructor will call <code>d(t)</code> if anything goes wrong (in practise this can only
happen if copying <code>D</code> throws).</p>
<p>The template is specialized for pointer types; if <code>T</code> is a pointer, the
deleter will never be called if the resource pointer is null. The <code>bool</code>
conversion and <code>!</code> operator have their usual meaning for pointers; for other
types, they will fail to compile if <code>T</code> does not have an explicit conversion
to <code>bool</code>. Behaviour is otherwise the same for pointer and non-pointer types.</p>
</div>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>ScopeExit</code></strong><ul>
<li><code>using ScopeExit::</code><strong><code>callback</code></strong> <code>= function&lt;void()&gt;</code></li>
<li><code>explicit ScopeExit::</code><strong><code>ScopeExit</code></strong><code>(callback f)</code></li>
<li><code>ScopeExit::</code><strong><code>~ScopeExit</code></strong><code>() noexcept</code></li>
<li><code>void ScopeExit::</code><strong><code>release</code></strong><code>() noexcept</code></li>
</ul>
</li>
<li><code>class</code> <strong><code>ScopeSuccess</code></strong><ul>
<li><code>using ScopeSuccess::</code><strong><code>callback</code></strong> <code>= function&lt;void()&gt;</code></li>
<li><code>explicit ScopeSuccess::</code><strong><code>ScopeSuccess</code></strong><code>(callback f)</code></li>
<li><code>ScopeSuccess::</code><strong><code>~ScopeSuccess</code></strong><code>() noexcept</code></li>
<li><code>void ScopeSuccess::</code><strong><code>release</code></strong><code>() noexcept</code></li>
</ul>
</li>
<li><code>class</code> <strong><code>ScopeFailure</code></strong><ul>
<li><code>using ScopeFailure::</code><strong><code>callback</code></strong> <code>= function&lt;void()&gt;</code></li>
<li><code>explicit ScopeFailure::</code><strong><code>ScopeFailure</code></strong><code>(callback f)</code></li>
<li><code>ScopeFailure::</code><strong><code>~ScopeFailure</code></strong><code>() noexcept</code></li>
<li><code>void ScopeFailure::</code><strong><code>release</code></strong><code>() noexcept</code></li>
</ul>
</li>
</ul>
<p>These store a function object, to be called when the guard is destroyed
(passing <code>nullptr</code> will just do nothing). <code>ScopeExit</code> calls the function
unconditionally, <code>ScopeSuccess</code> calls it only on normal exit (not when
unwinding due to an exception), and <code>ScopeFailure</code> calls it only when an
exception causes stack unwinding (not on normal exit). If the constructor
throws an exception (this is only possible if the function object's copy
constructor or assignment operator throws), <code>ScopeExit</code> and <code>ScopeFailure</code>
will call the function before propagating the exception, while <code>ScopeSuccess</code>
will not. Any exceptions thrown by the function call in the destructor are
silently ignored (normally the function should be written so as not to throw
anything).</p>
<p>The <code>release()</code> function discards the saved function; after it is called, the
scope guard object will do nothing on destruction.</p>
</div>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>ScopedTransaction</code></strong><ul>
<li><code>using ScopedTransaction::</code><strong><code>callback</code></strong> <code>= function&lt;void()&gt;</code></li>
<li><code>ScopedTransaction::</code><strong><code>ScopedTransaction</code></strong><code>() noexcept</code></li>
<li><code>ScopedTransaction::</code><strong><code>~ScopedTransaction</code></strong><code>() noexcept</code></li>
<li><code>void ScopedTransaction::</code><strong><code>call</code></strong><code>(callback func, callback undo)</code></li>
<li><code>void ScopedTransaction::</code><strong><code>commit</code></strong><code>() noexcept</code></li>
<li><code>void ScopedTransaction::</code><strong><code>rollback</code></strong><code>() noexcept</code></li>
</ul>
</li>
</ul>
<p>This holds a stack of "undo" operations, to be carried out if anything goes
wrong during a sequence of operations. The <code>call()</code> function accepts two
function objects; <code>func()</code> is called immediately, while <code>undo()</code> is saved on
the stack. If <code>func()</code> throws an exception, its <code>undo()</code> is not called, but
any pre-existing undo stack is invoked. Either function can be a null pointer
if no action is required.</p>
<p>Calling <code>commit()</code> discards the saved undo functions; <code>rollback()</code> calls them
in reverse order of insertion, silently ignoring any exceptions (normally the
undo functions should be written so as not to throw anything). The destructor
will perform a rollback if neither <code>commit()</code> nor <code>rollback()</code> have been
called since the last <code>call()</code>.</p>
<p>A single <code>ScopedTransaction</code> object can be used for multiple transactions.
Once <code>commit()</code> or <code>rollback()</code> is called, the undo stack is discarded, and
any newly added function pairs become part of a new cycle, equivalent to a
newly constructed <code>ScopedTransaction</code>.</p>
</div>
<h2 id="io-utilities">I/O utilities</h2>
<h3 id="file-io-operations">File I/O operations</h3>
<p>Functions that take a file name have overloads that take a UTF-16 string in
native Windows builds (not on Cygwin, where the <code>_wfopen()</code> function is not
available). In all of these functions, passing an empty string or <code>"-"</code> as the
file name will cause the function to read from standard input or write to
standard output.</p>
<div class="defns">
<ul>
<li><code>bool</code> <strong><code>load_file</code></strong><code>(const string&amp; file, string&amp; dst, size_t limit = npos)</code></li>
<li><code>bool</code> <strong><code>load_file</code></strong><code>(const wstring&amp; file, string&amp; dst, size_t limit = npos)</code> <em>(Native Windows only)</em></li>
</ul>
<p>Read a file's contents into a string. Optionally, a maximum number of bytes
can be specified The return value is true if everything went well, false if
there was an error while opening or reading the file. If the function returns
false, the destination string will be cleared.</p>
</div>
<div class="defns">
<ul>
<li><code>bool</code> <strong><code>save_file</code></strong><code>(const string&amp; file, const void* ptr, size_t n, bool append = false)</code></li>
<li><code>bool</code> <strong><code>save_file</code></strong><code>(const string&amp; file, const string&amp; src, bool append = false)</code></li>
<li><code>bool</code> <strong><code>save_file</code></strong><code>(const wstring&amp; file, const void* ptr, size_t n, bool append = false)</code> <em>(Native Windows only)</em></li>
<li><code>bool</code> <strong><code>save_file</code></strong><code>(const wstring&amp; file, const string&amp; src, bool append = false)</code> <em>(Native Windows only)</em></li>
</ul>
<p>Write a string's contents into a file, optionally appending it to the file
instead of overwriting it if it already exists (if the file does not exist, or
is standard output, the <code>append</code> flag has no effect). The return value is true
if everything went well, false if there was an error while opening or writing
the file.</p>
</div>
<h3 id="logging">Logging</h3>
<div class="defns">
<ul>
<li><code>void</code> <strong><code>logx</code></strong><code>(const u8string&amp; msg)</code></li>
<li><code>void</code> <strong><code>logx</code></strong><code>(const char* msg)</code></li>
<li><code>template &lt;typename... Args&gt; void</code> <strong><code>logx</code></strong><code>(Args... args)</code></li>
<li><code>void</code> <strong><code>logt</code></strong><code>(const u8string&amp; msg)</code></li>
<li><code>void</code> <strong><code>logt</code></strong><code>(const char* msg)</code></li>
<li><code>template &lt;typename... Args&gt; void</code> <strong><code>logt</code></strong><code>(Args... args)</code></li>
</ul>
<p>These write a message to standard output, followed by a line feed and an
output flush. If multiple arguments are supplied, they are delimited with a
space. The <code>logt()</code> functions prefix each message with the time (in UTC).</p>
<p>These functions are intended mainly for use in multithreaded code. A private
mutex is used to ensure that messages from different threads are not
interleaved. Output from different threads will be given different colours,
chosen at random based on a hash of the thread ID.</p>
</div>
<h3 id="terminal-io-operations">Terminal I/O operations</h3>
<div class="defns">
<ul>
<li><code>bool</code> <strong><code>is_stdout_redirected</code></strong><code>() noexcept</code></li>
</ul>
<p>Attempts to detect whether standard output has been redirected to a file or
pipe (true), or is going directly to a terminal (false). This is not always
possible to detect reliably; this function is fairly reliable on Unix, less so
on Windows.</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr const char*</code> <strong><code>xt_up</code></strong> <code>=           &lt;esc&gt; [A    = Cursor up</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_down</code></strong> <code>=         &lt;esc&gt; [B    = Cursor down</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_right</code></strong> <code>=        &lt;esc&gt; [C    = Cursor right</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_left</code></strong> <code>=         &lt;esc&gt; [D    = Cursor left</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_erase_left</code></strong> <code>=   &lt;esc&gt; [1K   = Erase left</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_erase_right</code></strong> <code>=  &lt;esc&gt; [K    = Erase right</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_erase_above</code></strong> <code>=  &lt;esc&gt; [1J   = Erase above</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_erase_below</code></strong> <code>=  &lt;esc&gt; [J    = Erase below</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_erase_line</code></strong> <code>=   &lt;esc&gt; [2K   = Erase line</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_clear</code></strong> <code>=        &lt;esc&gt; [2J   = Clear screen</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_reset</code></strong> <code>=        &lt;esc&gt; [0m   = Reset attributes</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_bold</code></strong> <code>=         &lt;esc&gt; [1m   = Bold</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_under</code></strong> <code>=        &lt;esc&gt; [4m   = Underline</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_bold_off</code></strong> <code>=     &lt;esc&gt; [22m  = Bold off</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_under_off</code></strong> <code>=    &lt;esc&gt; [24m  = Underline off</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_colour_off</code></strong> <code>=   &lt;esc&gt; [39m  = Colour off</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_black</code></strong> <code>=        &lt;esc&gt; [30m  = Black foreground</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_red</code></strong> <code>=          &lt;esc&gt; [31m  = Red foreground</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_green</code></strong> <code>=        &lt;esc&gt; [32m  = Green foreground</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_yellow</code></strong> <code>=       &lt;esc&gt; [33m  = Yellow foreground</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_blue</code></strong> <code>=         &lt;esc&gt; [34m  = Blue foreground</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_magenta</code></strong> <code>=      &lt;esc&gt; [35m  = Magenta foreground</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_cyan</code></strong> <code>=         &lt;esc&gt; [36m  = Cyan foreground</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_white</code></strong> <code>=        &lt;esc&gt; [37m  = White foreground</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_black_bg</code></strong> <code>=     &lt;esc&gt; [40m  = Black background</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_red_bg</code></strong> <code>=       &lt;esc&gt; [41m  = Red background</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_green_bg</code></strong> <code>=     &lt;esc&gt; [42m  = Green background</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_yellow_bg</code></strong> <code>=    &lt;esc&gt; [43m  = Yellow background</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_blue_bg</code></strong> <code>=      &lt;esc&gt; [44m  = Blue background</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_magenta_bg</code></strong> <code>=   &lt;esc&gt; [45m  = Magenta background</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_cyan_bg</code></strong> <code>=      &lt;esc&gt; [46m  = Cyan background</code></li>
<li><code>constexpr const char*</code> <strong><code>xt_white_bg</code></strong> <code>=     &lt;esc&gt; [47m  = White background</code></li>
</ul>
<p>Xterm cursor movement and output formatting codes.</p>
</div>
<div class="defns">
<ul>
<li><code>string</code> <strong><code>xt_move_up</code></strong><code>(int n)      = &lt;esc&gt; [&lt;n&gt;A             = Cursor up n spaces</code></li>
<li><code>string</code> <strong><code>xt_move_down</code></strong><code>(int n)    = &lt;esc&gt; [&lt;n&gt;B             = Cursor down n spaces</code></li>
<li><code>string</code> <strong><code>xt_move_right</code></strong><code>(int n)   = &lt;esc&gt; [&lt;n&gt;C             = Cursor right n spaces</code></li>
<li><code>string</code> <strong><code>xt_move_left</code></strong><code>(int n)    = &lt;esc&gt; [&lt;n&gt;D             = Cursor left n spaces</code></li>
<li><code>string</code> <strong><code>xt_colour</code></strong><code>(int rgb)     = &lt;esc&gt; [38;5;&lt;16-231&gt;m   = Set foreground colour to an RGB value</code></li>
<li><code>string</code> <strong><code>xt_colour_bg</code></strong><code>(int rgb)  = &lt;esc&gt; [48;5;&lt;16-231&gt;m   = Set background colour to an RGB value</code></li>
<li><code>string</code> <strong><code>xt_grey</code></strong><code>(int grey)      = &lt;esc&gt; [38;5;&lt;232-255&gt;m  = Set foreground colour to a grey level</code></li>
<li><code>string</code> <strong><code>xt_grey_bg</code></strong><code>(int grey)   = &lt;esc&gt; [48;5;&lt;232-255&gt;m  = Set background colour to a grey level</code></li>
</ul>
<p>Functions for generating variable Xterm codes. The RGB levels passed to the
<code>xt_colour[_bg]()</code> functions are in the form of a 3 digit number from 111 to
666; each digit is clamped to a range of 1-6, yielding 216 different colours.
The grey level passed to the <code>xt_grey[_bg]()</code> functions is clamped to a range
of 1-24.</p>
</div>
<h2 id="random-numbers">Random numbers</h2>
<h3 id="simple-random-generators">Simple random generators</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename RNG&gt; bool</code> <strong><code>random_bool</code></strong><code>(RNG&amp; rng)</code> <em>- True with probability 1/2</em></li>
<li><code>template &lt;typename RNG&gt; bool</code> <strong><code>random_bool</code></strong><code>(RNG&amp; rng, double p)</code> <em>- True with probability p (clamped to 0-1)</em></li>
<li><code>template &lt;typename RNG, typename T&gt; bool</code> <strong><code>random_bool</code></strong><code>(RNG&amp; rng, T num, T den)</code> <em>- True with probability num/den (clamped to 0-1)</em></li>
<li><code>template &lt;typename T, typename RNG&gt; T</code> <strong><code>random_integer</code></strong><code>(RNG&amp; rng, T t)</code> <em>- Random integer from 0 to t-1 (always 0 if t&lt;2)</em></li>
<li><code>template &lt;typename T, typename RNG&gt; T</code> <strong><code>random_integer</code></strong><code>(RNG&amp; rng, T a, T b)</code> <em>- Random integer from a to b inclusive (limits may be in either order)</em></li>
<li><code>template &lt;typename T, typename RNG&gt; T</code> <strong><code>random_dice</code></strong><code>(RNG&amp; rng, T n = 1, T faces = 6)</code> <em>- Roll n dice numbered from 1 to faces (0 if either argument is &lt;1)</em></li>
<li><code>template &lt;typename T, typename RNG&gt; T</code> <strong><code>random_float</code></strong><code>(RNG&amp; rng, T a = 1, T b = 0)</code> <em>- Random number between a and b (limits may be in either order)</em></li>
<li><code>template &lt;typename T, typename RNG&gt; T</code> <strong><code>random_normal</code></strong><code>(RNG&amp; rng)</code> <em>- Normal distribution with mean 0, sd 1</em></li>
<li><code>template &lt;typename T, typename RNG&gt; T</code> <strong><code>random_normal</code></strong><code>(RNG&amp; rng, T m, T s)</code> <em>- Normal distribution with given mean and sd</em></li>
<li><code>template &lt;typename Range, typename RNG&gt; [value type]</code> <strong><code>random_choice</code></strong><code>(RNG&amp; rng, const Range&amp; range)</code> <em>- Random element from range (default constructed value if range is empty)</em></li>
<li><code>template &lt;typename T, typename RNG&gt; T</code> <strong><code>random_choice</code></strong><code>(RNG&amp; rng, initializer_list&lt;T&gt; list)</code> <em>- Random element from explicit list</em></li>
</ul>
<p>Simple random number functions. These do not call the standard distribution
classes; given the same underlying random number engine (the <code>RNG</code> type),
these can be relied on to return the same values on different systems and
compilers (apart from small differences due to rounding errors in the floating
point functions).</p>
</div>
<h2 id="strings-and-related-functions">Strings and related functions</h2>
<h3 id="character-functions">Character functions</h3>
<div class="defns">
<ul>
<li><code>constexpr bool</code> <strong><code>ascii_isalnum</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isalpha</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_iscntrl</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isdigit</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isgraph</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_islower</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isprint</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_ispunct</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isspace</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isupper</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isxdigit</code></strong><code>(char c) noexcept</code></li>
</ul>
<p>These are simple ASCII-only versions of the standard character type functions.
All of them will always return false for bytes outside the ASCII range
(0-127).</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr bool</code> <strong><code>ascii_isalnum_w</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_isalpha_w</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr bool</code> <strong><code>ascii_ispunct_w</code></strong><code>(char c) noexcept</code></li>
</ul>
<p>These behave the same as the corresponding functions without the <code>"_w"</code>
suffix, except that the underscore character is counted as a letter instead of
a punctuation mark. (The suffix is intended to suggest the <code>"\w"</code> regex
element, which does much the same thing.)</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr char</code> <strong><code>ascii_tolower</code></strong><code>(char c) noexcept</code></li>
<li><code>constexpr char</code> <strong><code>ascii_toupper</code></strong><code>(char c) noexcept</code></li>
</ul>
<p>Simple ASCII-only case conversion functions. All non-ASCII characters are left
unchanged.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; constexpr T</code> <strong><code>char_to</code></strong><code>(char c) noexcept</code></li>
</ul>
<p>A simple conversion function that casts a <code>char</code> to a larger integer type by
first passing it through <code>unsigned char</code>, to ensure that characters with the
high bit set end up as integers in the 128-255 range, and not as negative or
extremely high values.</p>
</div>
<h3 id="general-string-functions">General string functions</h3>
<div class="defns">
<ul>
<li><code>bool</code> <strong><code>ascii_icase_equal</code></strong><code>(const string&amp; lhs, const string&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>ascii_icase_less</code></strong><code>(const string&amp; lhs, const string&amp; rhs) noexcept</code></li>
</ul>
<p>Comparison functions that treat upper and lower case ASCII letters as
equivalent (comparison between letters and non-letters uses the upper case
code points).</p>
</div>
<div class="defns">
<ul>
<li><code>string</code> <strong><code>ascii_lowercase</code></strong><code>(const string&amp; s)</code></li>
<li><code>string</code> <strong><code>ascii_uppercase</code></strong><code>(const string&amp; s)</code></li>
<li><code>string</code> <strong><code>ascii_titlecase</code></strong><code>(const string&amp; s)</code></li>
<li><code>string</code> <strong><code>ascii_sentencecase</code></strong><code>(const string&amp; s)</code></li>
</ul>
<p>Simple ASCII-only case conversion functions. All non-ASCII characters are left
unchanged. The sentence case function capitalizes the first letter of every
sentence (delimited by a full stop or two consecutive line breaks), leaving
everything else alone.</p>
</div>
<div class="defns">
<ul>
<li><code>u8string</code> <strong><code>bquote</code></strong><code>(const string&amp; str)</code></li>
<li><code>u8string</code> <strong><code>uquote</code></strong><code>(const u8string&amp; str)</code></li>
</ul>
<p>Return a quoted string; internal quotes, backslashes, and control characters
are escaped. The <code>bquote()</code> function also escapes all non-ASCII bytes, while
<code>uquote()</code> passes them through unchanged.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename C&gt; basic_string&lt;C&gt;</code> <strong><code>cstr</code></strong><code>(const C* ptr)</code></li>
<li><code>template &lt;typename C&gt; basic_string&lt;C&gt;</code> <strong><code>cstr</code></strong><code>(const C* ptr, size_t n)</code></li>
</ul>
<p>These construct a string from a pointer to a null-terminated character
sequence, or a pointer and a length. They differ from the corresponding string
constructors in that passing a null pointer will yield an empty string instead
of undefined behaviour.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename C&gt; size_t</code> <strong><code>cstr_size</code></strong><code>(const C* ptr)</code></li>
</ul>
<p>Returns the length of a null-terminated string (a generalized version of
<code>strlen()</code>). This will return zero if the pointer is null.</p>
</div>
<div class="defns">
<ul>
<li><code>u8string</code> <strong><code>dent</code></strong><code>(size_t depth)</code></li>
</ul>
<p>Returns a string containing <code>4*depth</code> spaces, for indentation.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename InputRange&gt; string</code> <strong><code>join</code></strong><code>(const InputRange&amp; range, const string&amp; delim = "")</code></li>
<li><code>template &lt;typename OutputIterator&gt; void</code> <strong><code>split</code></strong><code>(const string&amp; src, OutputIterator dst, const string&amp; delim = ascii_whitespace)</code></li>
</ul>
<p>Join strings into a single string, using the given delimiter, or split a
string into substrings, discarding any sequence of delimiter characters. The
dereferenced iterators must be assignment compatible with <code>string</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename C&gt; void</code> <strong><code>null_term</code></strong><code>(basic_string&lt;C&gt;&amp; str)</code></li>
</ul>
<p>Cuts off a string at the first null character (useful after the string has
been used as an output buffer by some C APIs).</p>
</div>
<div class="defns">
<ul>
<li><code>string</code> <strong><code>trim</code></strong><code>(const string&amp; str, const string&amp; chars = ascii_whitespace)</code></li>
<li><code>string</code> <strong><code>trim_left</code></strong><code>(const string&amp; str, const string&amp; chars = ascii_whitespace)</code></li>
<li><code>string</code> <strong><code>trim_right</code></strong><code>(const string&amp; str, const string&amp; chars = ascii_whitespace)</code></li>
</ul>
<p>Trim unwanted bytes from the ends of a string.</p>
</div>
<div class="defns">
<ul>
<li><code>string</code> <strong><code>unqualify</code></strong><code>(const string&amp; str, const string&amp; delims = ".:")</code></li>
</ul>
<p>Strips off any prefix ending in one of the delimiter characters (e.g.
<code>unqualify("Prion::unqualify()")</code> returns <code>"unqualify()"</code>). This will return
the original string unchanged if the delimiter string is empty or none of its
characters are found.</p>
</div>
<h3 id="unicode-functions">Unicode functions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename S2, typename S1&gt; S2</code> <strong><code>uconv</code></strong><code>(const S1&amp; s)</code></li>
</ul>
<p>Converts between UTF representations. The input and output types (<code>S1</code> and
<code>S2</code>) must be instantiations of <code>basic_string</code> with 8, 16, or 32 bit character
types. If the character types are the same size, the input string is copied to
the output without any validity checking; otherwise, invalid UTF in the input
is replaced with the standard Unicode replacement character (<code>U+FFFD</code>) in the
output.</p>
</div>
<h3 id="string-formatting-and-parsing-functions">String formatting and parsing functions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; u8string</code> <strong><code>bin</code></strong><code>(T x, size_t digits = 8 * sizeof(T))</code></li>
<li><code>template &lt;typename T&gt; u8string</code> <strong><code>dec</code></strong><code>(T x, size_t digits = 1)</code></li>
<li><code>template &lt;typename T&gt; u8string</code> <strong><code>hex</code></strong><code>(T x, size_t digits = 2 * sizeof(T))</code></li>
<li><code>unsigned long long</code> <strong><code>binnum</code></strong><code>(const string&amp; str) noexcept</code></li>
<li><code>long long</code> <strong><code>decnum</code></strong><code>(const string&amp; str) noexcept</code></li>
<li><code>unsigned long long</code> <strong><code>hexnum</code></strong><code>(const string&amp; str) noexcept</code></li>
<li><code>double</code> <strong><code>fpnum</code></strong><code>(const string&amp; str) noexcept</code></li>
</ul>
<p>Simple string and number conversion functions. The <code>bin()</code>, <code>dec()</code>, and
<code>hex()</code> functions convert an integer to a binary, decimal, or hexadecimal
string, generating at least the specified number of digits. The <code>binnum()</code>,
<code>decnum()</code>, and <code>hexnum()</code> functions perform the reverse conversion, while
<code>fpnum()</code> converts a string to a floating point number; these will ignore any
trailing characters that are not part of a number, and will return zero if the
string is empty or does not contain a valid number. Results that are out of
range will be clamped to the nearest end of the return type's range (for
<code>fpnum()</code> this will normally be positive or negative infinity).</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; u8string</code> <strong><code>fp_format</code></strong><code>(T t, char mode = 'g', int prec = 6)</code></li>
</ul>
<p>Simple floating point formatting, by calling <code>snprintf()</code>. <code>T</code> must be an
arithmetic type; it will be converted to <code>double</code> internally. The additional
format <code>'h'</code> is the same as <code>'g'</code> except that trailing zeros are not stripped.
This will throw <code>std::invalid_argument</code> if the mode is not one of
<code>[EFGHefgh]</code>; it may throw <code>std::system_error</code> under implementation defined
circumstances.</p>
</div>
<div class="defns">
<ul>
<li><code>int64_t</code> <strong><code>si_to_int</code></strong><code>(const u8string&amp; s)</code></li>
<li><code>double</code> <strong><code>si_to_float</code></strong><code>(const u8string&amp; s)</code></li>
</ul>
<p>These parse a number from a string representation tagged with an SI multiplier
abbreviation (e.g. <code>"123k"</code>). For the integer version, only tags representing
positive powers of 1000 (starting with<code>"k"</code>) are recognised, and are case
insensitive. For the floating point version, all tags representing powers of
100 are recognised (<code>"u"</code> is used for "micro"), and are case sensitive, except
that <code>"K"</code> is equivalent to <code>"k"</code>. For both versions, a space is allowed
between the number and the tag, and any additional text after the number or
tag is ignored.</p>
<p>This will throw <code>std::invalid_argument</code> if the string does not start with a
valid number, or <code>std::range_error</code> if the result is too big for the return
type.</p>
</div>
<div class="defns">
<ul>
<li><code>u8string</code> <strong><code>hexdump</code></strong><code>(const void* ptr, size_t n, size_t block = 0)</code></li>
<li><code>u8string</code> <strong><code>hexdump</code></strong><code>(const string&amp; str, size_t block = 0)</code></li>
</ul>
<p>Converts a block of raw data into hexadecimal bytes. If <code>block</code> is not zero, a
line feed is inserted after each block.</p>
</div>
<div class="defns">
<ul>
<li><code>u8string</code> <strong><code>tf</code></strong><code>(bool b)</code></li>
<li><code>u8string</code> <strong><code>yn</code></strong><code>(bool b)</code></li>
</ul>
<p>Convert a boolean to <code>"true"/"false"</code> or <code>"yes"/"no"</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; string</code> <strong><code>to_str</code></strong><code>(const T&amp; t)</code></li>
</ul>
<p>Formats an object as a string. For most types this uses the type's output
stream operator. For strings, including character arrays and pointers, the
string content is simply copied directly without using an output stream (a
null character pointer is treated as an empty string). Ranges (other than
strings) are serialized in a format similar to a JSON array (e.g.
<code>"[1,2,3]"</code>), or an object (e.g. <code>"{1:a,2:b,3:c}"</code>) if the range's value type
is a pair; <code>to_str()</code> is called recursively on each range element.</p>
</div>
<h3 id="htmlxml-tags">HTML/XML tags</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Tag</code></strong><ul>
<li><code>Tag::</code><strong><code>Tag</code></strong><code>() noexcept</code></li>
<li><code>Tag::</code><strong><code>Tag</code></strong><code>(const u8string&amp; text, std::ostream&amp; out)</code></li>
<li><code>Tag::</code><strong><code>Tag</code></strong><code>(Tag&amp;&amp; t) noexcept</code></li>
<li><code>Tag::</code><strong><code>~Tag</code></strong><code>() noexcept</code></li>
<li><code>Tag&amp; Tag::</code><strong><code>operator=</code></strong><code>(Tag&amp;&amp; t) noexcept</code></li>
</ul>
</li>
</ul>
<p>This class writes an HTML/XML tag in its constructor, then writes the
corresponding closing tag in its destructor. If the supplied string ends with
one line feed, a line feed will be written after the closing tag, but not the
opening one; if it ends with two line feeds, one will be written after both
tags.</p>
<p>If the opening tag is standalone, the text will simply be written as is, and
no closing tag will be written (standalone tags are identified by a closing
slash; the class is not aware of HTML's list of automatic self closing tags).</p>
<p>The constructor will throw <code>std::invalid_argument</code> if the string does not
appear to be a valid tag (this check is not very sophisticated).</p>
</div>
<h2 id="threads">Threads</h2>
<p>This section of the library exists because some of the compilers I need to
support don't implement C++11 threads yet.</p>
<h3 id="thread-class">Thread class</h3>
<div class="defns">
<ul>
<li><code>class Thread</code><ul>
<li><code>using Thread::</code><strong><code>callback</code></strong> <code>= function&lt;void()&gt;</code></li>
<li><code>using Thread::</code><strong><code>id_type</code></strong> <code>= ...</code></li>
<li><code>Thread::</code><strong><code>Thread</code></strong><code>() noexcept</code></li>
<li><code>explicit Thread::</code><strong><code>Thread</code></strong><code>(callback f)</code></li>
<li><code>Thread::</code><strong><code>Thread</code></strong><code>(Thread&amp;&amp; t)</code></li>
<li><code>Thread::</code><strong><code>~Thread</code></strong><code>() noexcept</code></li>
<li><code>Thread&amp; Thread::</code><strong><code>operator=</code></strong><code>(Thread&amp;&amp; t)</code></li>
<li><code>Thread::id_type Thread::</code><strong><code>get_id</code></strong><code>() const noexcept</code></li>
<li><code>bool Thread::</code><strong><code>poll</code></strong><code>() noexcept</code></li>
<li><code>void Thread::</code><strong><code>wait</code></strong><code>()</code></li>
<li><code>size_t Thread::</code><strong><code>cpu_threads</code></strong><code>() noexcept</code></li>
<li><code>static Thread::id_type Thread::</code><strong><code>current</code></strong><code>() noexcept</code></li>
<li><code>void Thread::</code><strong><code>yield</code></strong><code>() noexcept</code></li>
</ul>
</li>
</ul>
<p>This is a wrapper for an operating system thread. The constructor accepts a
callback function, which will be called as the thread's payload. If a null
function is supplied, or the default constructor is used, no actual thread
will be created, and <code>wait()</code> will return immediately.</p>
<p>The <code>get_id()</code> function returns a thread identifier. This is guaranteed to be
unique only between threads running simultaneously; threads whose lifetimes do
not overlap may re-use the same ID (a thread's lifetime starts during the
constructor, and ends during the first call to <code>wait()</code> or the destructor). If
the thread was default constructed, the value of <code>get_id()</code> is unspecified.
The <code>current()</code> function returns the calling thread's ID.</p>
<p>The <code>poll()</code> function returns true if the thread's payload has completed
(meaning that the thread is either awaiting joining or already joined), false
if it is still running. A default constructed thread is considered to be
already completed.</p>
<p>The <code>wait()</code> function and the destructor wait for the thread to finish. Any
exceptions thrown by the callback function will be rethrown by <code>wait()</code>, or
silently discarded by the destructor. If the thread has already been
successfully waited on (or was default constructed), subsequent waits will
return immediately (and will not rethrow exceptions). Behaviour is undefined
if more than one thread is waiting on the same thread, or if a thread attempts
to wait on itself.</p>
<p>Apart from <code>wait()</code>, the other methods can be safely called simultaneously on
the same thread object from multiple other threads without synchronisation
precautions.</p>
<p>The constructor and the <code>wait()</code> function may throw <code>std::system_error</code> if
anything goes wrong in the underlying native thread API, and <code>wait()</code> may
rethrow as described above.</p>
<p>The <code>cpu_threads()</code> function returns the number of hardware threads available.</p>
<p>The <code>yield()</code> function causes the current thread to yield its scheduler time
slice.</p>
</div>
<h3 id="synchronisation-objects">Synchronisation objects</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Mutex</code></strong><ul>
<li><code>Mutex::</code><strong><code>Mutex</code></strong><code>() noexcept</code></li>
<li><code>Mutex::</code><strong><code>~Mutex</code></strong><code>() noexcept</code></li>
<li><code>void Mutex::</code><strong><code>lock</code></strong><code>() noexcept</code></li>
<li><code>bool Mutex::</code><strong><code>try_lock</code></strong><code>() noexcept</code></li>
<li><code>void Mutex::</code><strong><code>unlock</code></strong><code>() noexcept</code></li>
</ul>
</li>
<li><code>class</code> <strong><code>MutexLock</code></strong><ul>
<li><code>MutexLock::</code><strong><code>MutexLock</code></strong><code>() noexcept</code></li>
<li><code>explicit MutexLock::</code><strong><code>MutexLock</code></strong><code>(Mutex&amp; m) noexcept</code></li>
<li><code>MutexLock::</code><strong><code>~MutexLock</code></strong><code>() noexcept</code></li>
<li><code>MutexLock::</code><strong><code>MutexLock</code></strong><code>(MutexLock&amp;&amp; lock) noexcept</code></li>
<li><code>MutexLock&amp; MutexLock::</code><strong><code>operator=</code></strong><code>(MutexLock&amp;&amp; lock) noexcept</code></li>
</ul>
</li>
<li><code>MutexLock</code> <strong><code>make_lock</code></strong><code>(Mutex&amp; m) noexcept</code></li>
</ul>
<p>Mutex and exclusive lock. (A version of <code>make_lock()</code> that returns a
<code>std::unique_lock&lt;std::mutex&gt;</code> is also defined on systems that support it.)</p>
</div>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>ConditionVariable</code></strong><ul>
<li><code>ConditionVariable::</code><strong><code>ConditionVariable</code></strong><code>()</code></li>
<li><code>ConditionVariable::</code><strong><code>~ConditionVariable</code></strong><code>() noexcept</code></li>
<li><code>void ConditionVariable::</code><strong><code>notify_all</code></strong><code>() noexcept</code></li>
<li><code>void ConditionVariable::</code><strong><code>notify_one</code></strong><code>() noexcept</code></li>
<li><code>void ConditionVariable::</code><strong><code>wait</code></strong><code>(MutexLock&amp; lock)</code></li>
<li><code>template &lt;typename Pred&gt; void ConditionVariable::</code><strong><code>wait</code></strong><code>(MutexLock&amp; lock, Pred p)</code></li>
<li><code>template &lt;typename R, typename P, typename Pred&gt; bool ConditionVariable::</code><strong><code>wait_for</code></strong><code>(MutexLock&amp; lock, std::chrono::duration&lt;R, P&gt; t, Pred p)</code></li>
<li><code>template &lt;typename C, typename D, typename Pred&gt; bool ConditionVariable::</code><strong><code>wait_until</code></strong><code>(MutexLock&amp; lock, std::chrono::time_point&lt;C, D&gt; t, Pred p)</code></li>
</ul>
</li>
</ul>
<p>Condition variable.</p>
</div>
<h2 id="time-and-date-operations">Time and date operations</h2>
<p>In this documentation, the <code>std::chrono::</code> prefix on the standard date and
time types is left out for brevity. For all functions here that accept or
return a broken down date, results are unspecified if the date is outside the
range of a <code>time_t</code> (1970-2038 on 32-bit systems), or if the fields are set to
values that do not represent a valid date.</p>
<h3 id="time-and-date-types">Time and date types</h3>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>Dseconds</code></strong> <code>= duration&lt;double&gt;</code></li>
<li><code>using</code> <strong><code>Ddays</code></strong> <code>= duration&lt;double, ratio&lt;86400&gt;&gt;</code></li>
<li><code>using</code> <strong><code>Dyears</code></strong> <code>= duration&lt;double, ratio&lt;31557600&gt;&gt;</code></li>
</ul>
<p>Floating point duration types.</p>
</div>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>ReliableClock</code></strong> <code>= [high_resolution_clock or steady_clock]</code></li>
</ul>
<p>This is the highest resolution clock that can be trusted to be steady. It will
be <code>high_resolution_clock</code> if <code>high_resolution_clock::is_steady</code> is true,
otherwise <code>steady_clock</code>.</p>
</div>
<h3 id="general-time-and-date-operations">General time and date operations</h3>
<div class="defns">
<ul>
<li><code>enum class</code> <strong><code>Zone</code></strong><ul>
<li><code>Zone::</code><strong><code>utc</code></strong></li>
<li><code>Zone::</code><strong><code>local</code></strong></li>
</ul>
</li>
</ul>
<p>This is passed to some of the time and date functions to indicate whether a
broken down date is expressed in UTC or the local time zone.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename R, typename P&gt; void</code> <strong><code>from_seconds</code></strong><code>(double s, duration&lt;R, P&gt;&amp; d) noexcept</code></li>
<li><code>template &lt;typename R, typename P&gt; double</code> <strong><code>to_seconds</code></strong><code>(const duration&lt;R, P&gt;&amp; d) noexcept</code></li>
</ul>
<p>Convenience functions to convert between a <code>duration</code> and a floating point
number of seconds.</p>
</div>
<div class="defns">
<ul>
<li><code>system_clock::time_point</code> <strong><code>make_date</code></strong><code>(int year, int month, int day, int hour, int min, double sec, Zone z = Zone::utc) noexcept</code></li>
</ul>
<p>Converts a broken down date into a time point.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename R, typename P&gt; void</code> <strong><code>sleep_for</code></strong><code>(duration&lt;R, P&gt; t) noexcept</code></li>
<li><code>void</code> <strong><code>sleep_for</code></strong><code>(double t) noexcept</code></li>
<li><code>template &lt;typename C, typename D&gt; void</code> <strong><code>sleep_until</code></strong><code>(time_point&lt;C, D&gt; t) noexcept</code></li>
</ul>
<p>Suspend the current thread for the specified interval, supplied as a duration,
a number of seconds, or an absolute time. Calling this with a duration less
than or equal to zero will cause the thread to yield its time slice.
Resolution is system dependent. Behaviour is undefined if the duration exceeds
31 days.</p>
</div>
<h3 id="time-and-date-formatting">Time and date formatting</h3>
<div class="defns">
<ul>
<li><code>u8string</code> <strong><code>format_date</code></strong><code>(system_clock::time_point tp, int prec = 0, Zone z = Zone::utc)</code></li>
<li><code>u8string</code> <strong><code>format_date</code></strong><code>(system_clock::time_point tp, const u8string&amp; format, Zone z = Zone::utc)</code></li>
</ul>
<p>These convert a time point into a broken down date and format it. The first
version writes the date in ISO 8601 format (<code>"yyyy-mm-dd hh:mm:ss"</code>). If
<code>prec</code> is greater than zero, the specified number of decimal places will be
added to the seconds field.</p>
<p>The second version writes the date using the conventions of <code>strftime()</code>. This
will return an empty string if anything goes wrong; there is no way to
distinguish between a conversion error and a legitimately empty result (this
is a limitation of <code>strftime()</code>).</p>
<p>For reference, the portable subset of the <code>strftime()</code> formatting codes are:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Date elements</strong></td>
<td></td>
<td><strong>Weekday elements</strong></td>
<td></td>
</tr>
<tr>
<td><code>%Y</code></td>
<td>Year number</td>
<td><code>%a</code></td>
<td>Local weekday abbreviation</td>
</tr>
<tr>
<td><code>%y</code></td>
<td>Last 2 digits of the year (<code>00-99</code>)</td>
<td><code>%w</code></td>
<td>Sunday-based weekday number (<code>0-6</code>)</td>
</tr>
<tr>
<td><code>%m</code></td>
<td>Month number (<code>00-12</code>)</td>
<td><code>%A</code></td>
<td>Local weekday name</td>
</tr>
<tr>
<td><code>%B</code></td>
<td>Local month name</td>
<td><code>%U</code></td>
<td>Sunday-based week number (<code>00-53</code>)</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>Local month abbreviation</td>
<td><code>%W</code></td>
<td>Monday-based week number (<code>00-53</code>)</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>Day of the month (<code>01-31</code>)</td>
<td><strong>Other elements</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Time of day elements</strong></td>
<td></td>
<td><code>%c</code></td>
<td>Local standard date/time format</td>
</tr>
<tr>
<td><code>%H</code></td>
<td>Hour on 24-hour clock (<code>00-23</code>)</td>
<td><code>%x</code></td>
<td>Local standard date format</td>
</tr>
<tr>
<td><code>%I</code></td>
<td>Hour on 12-hour clock (<code>01-12</code>)</td>
<td><code>%X</code></td>
<td>Local standard time format</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>Local equivalent of a.m./p.m.</td>
<td><code>%j</code></td>
<td>Day of the year (<code>001-366</code>)</td>
</tr>
<tr>
<td><code>%M</code></td>
<td>Minute (<code>00-59</code>)</td>
<td><code>%Z</code></td>
<td>Time zone name</td>
</tr>
<tr>
<td><code>%S</code></td>
<td>Second (<code>00-60</code>)</td>
<td><code>%z</code></td>
<td>Time zone offset</td>
</tr>
</tbody>
</table>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename R, typename P&gt; u8string</code> <strong><code>format_time</code></strong><code>(const duration&lt;R, P&gt;&amp; time, int prec = 0)</code></li>
</ul>
<p>Formats a time duration in Julian years, days, hours, minutes, seconds, and
(if <code>prec&gt;0</code>) fractions of a second. Results are unspecified if the number of
years in <code>time</code> does not fit in a signed 32-bit integer.</p>
</div>
<h3 id="system-specific-time-and-date-conversions">System specific time and date conversions</h3>
<div class="defns">
<ul>
<li><em>Unix</em><ul>
<li><code>template &lt;typename R, typename P&gt; timespec</code> <strong><code>duration_to_timespec</code></strong><code>(const duration&lt;R, P&gt;&amp; d) noexcept</code></li>
<li><code>template &lt;typename R, typename P&gt; timeval</code> <strong><code>duration_to_timeval</code></strong><code>(const duration&lt;R, P&gt;&amp; d) noexcept</code></li>
<li><code>timespec</code> <strong><code>timepoint_to_timespec</code></strong><code>(const system_clock::time_point&amp; tp) noexcept</code></li>
<li><code>timeval</code> <strong><code>timepoint_to_timeval</code></strong><code>(const system_clock::time_point&amp; tp) noexcept</code></li>
<li><code>template &lt;typename R, typename P&gt; void</code> <strong><code>timespec_to_duration</code></strong><code>(const timespec&amp; ts, duration&lt;R, P&gt;&amp; d) noexcept</code></li>
<li><code>system_clock::time_point</code> <strong><code>timespec_to_timepoint</code></strong><code>(const timespec&amp; ts) noexcept</code></li>
<li><code>template &lt;typename R, typename P&gt; void</code> <strong><code>timeval_to_duration</code></strong><code>(const timeval&amp; tv, duration&lt;R, P&gt;&amp; d) noexcept</code></li>
<li><code>system_clock::time_point</code> <strong><code>timeval_to_timepoint</code></strong><code>(const timeval&amp; tv) noexcept</code></li>
</ul>
</li>
<li><em>Windows</em><ul>
<li><code>system_clock::time_point</code> <strong><code>filetime_to_timepoint</code></strong><code>(const FILETIME&amp; ft) noexcept</code></li>
<li><code>FILETIME</code> <strong><code>timepoint_to_filetime</code></strong><code>(const system_clock::time_point&amp; tp) noexcept</code></li>
</ul>
</li>
</ul>
<p>Conversion functions between C++ chrono types and system API types. Some of
these return their result through a reference argument to avoid having to
explicitly specify the duration type. Behaviour is undefined if the value
being represented is out of range for either the source or destination type.</p>
<p>The Windows functions are only defined on Win32 builds; the Unix functions are
always defined (since the relevant time structures are defined in the Windows
API).</p>
<p>For reference, the system time types are:</p>
<ul>
<li><em>Unix</em><ul>
<li><code>#include &lt;time.h&gt;</code><ul>
<li><code>struct</code> <strong><code>timespec</code></strong><ul>
<li><code>time_t timespec::</code><strong><code>tv_sec</code></strong> <code>// seconds</code></li>
<li><code>long timespec::</code><strong><code>tv_nsec</code></strong> <code>// nanoseconds</code></li>
</ul>
</li>
</ul>
</li>
<li><code>#include &lt;sys/time.h&gt;</code><ul>
<li><code>struct</code> <strong><code>timeval</code></strong><ul>
<li><code>time_t timeval::</code><strong><code>tv_sec</code></strong> <code>// seconds</code></li>
<li><code>suseconds_t timeval::</code><strong><code>tv_usec</code></strong> <code>// microseconds</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><em>Windows</em><ul>
<li><code>#include &lt;windows.h&gt;</code><ul>
<li><code>struct</code> <strong><code>FILETIME</code></strong><ul>
<li><code>DWORD FILETIME::</code><strong><code>dwLowDateTime</code></strong> <code>// low 32 bits</code></li>
<li><code>DWORD FILETIME::</code><strong><code>dwHighDateTime</code></strong> <code>// high 32 bits</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul></body>
</html>
