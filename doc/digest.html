<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Message Digest Algorithms</title>
<link type="text/css" rel="stylesheet" href="style.css"/>
</head>
<body>
<h1 id="message-digest-algorithms">Message Digest Algorithms</h1>
<p>By Ross Smith</p>
<ul>
<li><code>#include "rs-core/digest.hpp"</code></li>
</ul>
<h2 id="contents">Contents</h2>
<div class="toc">
<ul>
<li><a href="#message-digest-algorithms">Message Digest Algorithms</a><ul>
<li><a href="#contents">Contents</a></li>
<li><a href="#hash-function-base-class">Hash function base class</a></li>
<li><a href="#general-purpose-hash-functions">General purpose hash functions</a></li>
<li><a href="#cryptographic-hash-functions">Cryptographic hash functions</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="hash-function-base-class">Hash function base class</h2>
<div class="defns">
<ul>
<li><code>template &lt;size_t Bits&gt; class</code> <strong><code>HashFunction</code></strong><ul>
<li><code>static constexpr size_t HashFunction::</code><strong><code>bits</code></strong> <code>= Bits</code></li>
<li><code>static constexpr size_t HashFunction::</code><strong><code>bytes</code></strong> <code>= Bits / 8</code></li>
<li><code>using HashFunction::</code><strong><code>result_type</code></strong> <code>= [see below]</code></li>
<li><code>virtual HashFunction::</code><strong><code>~HashFunction</code></strong><code>() noexcept</code></li>
<li><code>virtual result_type HashFunction::</code><strong><code>hash</code></strong><code>(const void* ptr, size_t len) const noexcept = 0</code></li>
<li><code>result_type HashFunction::</code><strong><code>operator()</code></strong><code>(const void* ptr, size_t len) const noexcept</code></li>
<li><code>result_type HashFunction::</code><strong><code>operator()</code></strong><code>(const std::string&amp; str) const noexcept</code></li>
</ul>
</li>
</ul>
<p>Common base class for hash functions of a given output size. A static assert
ensures that the bit count is positive and a multiple of 8. If the bit count
is less than or equal to 64, the result type is the smallest standard fixed
size unsigned integer (<code>uint8_t</code> through <code>uint64_t</code>) that will hold the
result; otherwise, the result type is <code>std::array&lt;uint8_t,bytes&gt;</code>. The
function call operators call the virtual <code>hash()</code> function. Behaviour is
undefined if a null pointer is passed to any function.</p>
<p>Members of individual hash function classes are described below only when they
are not present in the base class or have significant semantic differences.</p>
</div>
<h2 id="general-purpose-hash-functions">General purpose hash functions</h2>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Adler32</code></strong><code>: public HashFunction&lt;32&gt;</code></li>
<li><code>class</code> <strong><code>Crc32</code></strong><code>: public HashFunction&lt;32&gt;</code></li>
<li><code>class</code> <strong><code>Djb2a</code></strong><code>: public HashFunction&lt;32&gt;</code></li>
<li><code>class</code> <strong><code>Fnv1a_32</code></strong><code>: public HashFunction&lt;32&gt;</code></li>
<li><code>class</code> <strong><code>Fnv1a_64</code></strong><code>: public HashFunction&lt;64&gt;</code></li>
<li><code>using</code> <strong><code>Fnv1a_std</code></strong> <code>= Fnv1a_32 or Fnv1a_64 [see below]</code></li>
<li><code>class</code> <strong><code>Murmur3_32</code></strong><code>: public HashFunction&lt;32&gt;</code><ul>
<li><code>Murmur3_32::</code><strong><code>Murmur3_32</code></strong><code>() noexcept</code></li>
<li><code>explicit Murmur3_32::</code><strong><code>Murmur3_32</code></strong><code>(uint32_t seed) noexcept</code></li>
</ul>
</li>
<li><code>class</code> <strong><code>SipHash_32</code></strong><code>: public HashFunction&lt;32&gt;</code><ul>
<li><code>static constexpr size_t SipHash_32::</code><strong><code>key_bits</code></strong> <code>= 128</code></li>
<li><code>static constexpr size_t SipHash_32::</code><strong><code>key_bytes</code></strong> <code>= 16</code></li>
<li><code>SipHash_32::</code><strong><code>SipHash_32</code></strong><code>() noexcept</code></li>
<li><code>SipHash_32::</code><strong><code>SipHash_32</code></strong><code>(const void* key, size_t keylen) noexcept</code></li>
</ul>
</li>
<li><code>class</code> <strong><code>SipHash_64</code></strong><code>: public HashFunction&lt;64&gt;</code><ul>
<li><code>static constexpr size_t SipHash_64::</code><strong><code>key_bits</code></strong> <code>= 128</code></li>
<li><code>static constexpr size_t SipHash_64::</code><strong><code>key_bytes</code></strong> <code>= 16</code></li>
<li><code>SipHash_64::</code><strong><code>SipHash_64</code></strong><code>() noexcept</code></li>
<li><code>SipHash_64::</code><strong><code>SipHash_64</code></strong><code>(const void* key, size_t keylen) noexcept</code></li>
</ul>
</li>
<li><code>using</code> <strong><code>SipHash_std</code></strong> <code>= SipHash_32 or SipHash_64 [see below]</code></li>
</ul>
<p>Commonly used general purpose hash functions. The Murmur3 and SipHash hashes
can optionally take an initialization key; if the length of the key does not
match the standard length, the key will be zero padded or truncated on the
right. <code>SipHash_64</code> is the standard 64-bit SipHash; <code>SipHash_32</code> is generated
by XORing the two halves of a <code>SipHash_64</code>.</p>
<p>The classes whose names end in <code>_std</code> are aliases for the corresponding 32-bit
or 64-bit implementations, selected to match the size of a <code>size_t</code> (the
result type of <code>std::hash</code>).</p>
</div>
<h2 id="cryptographic-hash-functions">Cryptographic hash functions</h2>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Md5</code></strong><code>: public HashFunction&lt;128&gt;</code></li>
<li><code>class</code> <strong><code>Sha1</code></strong><code>: public HashFunction&lt;160&gt;</code></li>
<li><code>class</code> <strong><code>Sha256</code></strong><code>: public HashFunction&lt;256&gt;</code></li>
<li><code>class</code> <strong><code>Sha512</code></strong><code>: public HashFunction&lt;512&gt;</code></li>
</ul>
<p>Commonly used cryptographic hash functions.</p></body>
</html>
