<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Two-Way Map</title>
<link type="text/css" rel="stylesheet" href="style.css"/>
</head>
<body>
<h1 id="two-way-map">Two-Way Map</h1>
<p>By Ross Smith</p>
<ul>
<li><code>#include "rs-core/mirror-map.hpp"</code></li>
</ul>
<h2 id="contents">Contents</h2>
<div class="toc">
<ul>
<li><a href="#two-way-map">Two-Way Map</a><ul>
<li><a href="#contents">Contents</a></li>
<li><a href="#class-mirrormap">Class MirrorMap</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="class-mirrormap">Class MirrorMap</h2>
<div class="defns">
<ul>
<li><code>template &lt;typename K1, typename K2, typename C1 = std::less&lt;K1&gt;, typename C2 = std::less&lt;K2&gt;&gt; class</code> <strong><code>MirrorMap</code></strong></li>
</ul>
<p>An associative container that allows look-up using either of the two key types
that make up a value pair. Value pairs must be unique, but either of the two
key types can have duplicate entries.</p>
</div>
<div class="defns">
<ul>
<li><code>using MirrorMap::</code><strong><code>left_key</code></strong> <code>= K1</code></li>
<li><code>using MirrorMap::</code><strong><code>right_key</code></strong> <code>= K2</code></li>
<li><code>using MirrorMap::</code><strong><code>left_compare</code></strong> <code>= C1</code></li>
<li><code>using MirrorMap::</code><strong><code>right_compare</code></strong> <code>= C2</code></li>
<li><code>using MirrorMap::</code><strong><code>value_type</code></strong> <code>= std::pair&lt;K1, K2&gt;</code></li>
<li><code>class MirrorMap::</code><strong><code>left_iterator</code></strong> <em>- const bidirectional iterator</em></li>
<li><code>class MirrorMap::</code><strong><code>right_iterator</code></strong> <em>- const bidirectional iterator</em></li>
<li><code>struct MirrorMap::</code><strong><code>insert_result</code></strong><ul>
<li><code>left_iterator insert_result::</code><strong><code>left</code></strong></li>
<li><code>right_iterator insert_result::</code><strong><code>right</code></strong></li>
<li><code>bool insert_result::</code><strong><code>inserted</code></strong></li>
</ul>
</li>
<li><code>using MirrorMap::</code><strong><code>left_range</code></strong> <code>= Irange&lt;left_iterator&gt;</code></li>
<li><code>using MirrorMap::</code><strong><code>right_range</code></strong> <code>= Irange&lt;right_iterator&gt;</code></li>
</ul>
<p>Member types. The left and right iterators traverse the map in the orders
generated by the left and right comparison functions; in each case the other
comparison function is used as a tie-breaker. The <code>insert_result</code> type is
returned from the single element insert operation.</p>
</div>
<div class="defns">
<ul>
<li><code>MirrorMap::</code><strong><code>MirrorMap</code></strong><code>()</code></li>
<li><code>explicit MirrorMap::</code><strong><code>MirrorMap</code></strong><code>(C1 c1, C2 c2 = {})</code></li>
<li><code>MirrorMap::</code><strong><code>MirrorMap</code></strong><code>(std::initializer_list&lt;value_type&gt; list)</code></li>
<li><code>template &lt;typename Iterator&gt; MirrorMap::</code><strong><code>MirrorMap</code></strong><code>(Iterator i, Iterator j, C1 c1 = {}, C2 c2 = {})</code></li>
<li><code>MirrorMap::</code><strong><code>MirrorMap</code></strong><code>(const MirrorMap&amp; mm)</code></li>
<li><code>MirrorMap::</code><strong><code>MirrorMap</code></strong><code>(MirrorMap&amp;&amp; mm) noexcept</code></li>
<li><code>MirrorMap::</code><strong><code>~MirrorMap</code></strong><code>() noexcept</code></li>
<li><code>MirrorMap&amp; MirrorMap::</code><strong><code>operator=</code></strong><code>(const MirrorMap&amp; mm)</code></li>
<li><code>MirrorMap&amp; MirrorMap::</code><strong><code>operator=</code></strong><code>(MirrorMap&amp;&amp; mm) noexcept</code></li>
</ul>
<p>Life cycle functions. These all work in the same way as their equivalents in
<code>std::map</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>void MirrorMap::</code><strong><code>clear</code></strong><code>() noexcept</code></li>
</ul>
<p>Erase all elements.</p>
</div>
<div class="defns">
<ul>
<li><code>size_t MirrorMap::</code><strong><code>count_left</code></strong><code>(const K1&amp; key) const</code></li>
<li><code>size_t MirrorMap::</code><strong><code>count_right</code></strong><code>(const K2&amp; key) const</code></li>
</ul>
<p>Return the number of times a given key occurs.</p>
</div>
<div class="defns">
<ul>
<li><code>bool MirrorMap::</code><strong><code>empty</code></strong><code>() const noexcept</code></li>
</ul>
<p>True if the container is empty.</p>
</div>
<div class="defns">
<ul>
<li><code>left_range MirrorMap::</code><strong><code>equal_left</code></strong><code>(const K1&amp; key) const</code></li>
<li><code>right_range MirrorMap::</code><strong><code>equal_right</code></strong><code>(const K2&amp; key) const</code></li>
</ul>
<p>Return matching ranges (following the usual meaning of <code>equal_range()</code>) for a
given left or right key.</p>
</div>
<div class="defns">
<ul>
<li><code>void MirrorMap::</code><strong><code>erase</code></strong><code>(left_iterator i) noexcept</code></li>
<li><code>void MirrorMap::</code><strong><code>erase</code></strong><code>(right_iterator i) noexcept</code></li>
<li><code>bool MirrorMap::</code><strong><code>erase</code></strong><code>(const value_type&amp; pair) noexcept</code></li>
<li><code>size_t MirrorMap::</code><strong><code>erase_left</code></strong><code>(const K1&amp; key) noexcept</code></li>
<li><code>size_t MirrorMap::</code><strong><code>erase_right</code></strong><code>(const K2&amp; key) noexcept</code></li>
</ul>
<p>Erase an element. The third version returns true if a matching element was
erased; the last two versions return the number of erased elements.</p>
</div>
<div class="defns">
<ul>
<li><code>left_iterator MirrorMap::</code><strong><code>find_left</code></strong><code>(const K1&amp; key) const</code></li>
<li><code>left_iterator MirrorMap::</code><strong><code>find_left</code></strong><code>(const value_type&amp; pair) const</code></li>
<li><code>right_iterator MirrorMap::</code><strong><code>find_right</code></strong><code>(const K2&amp; key) const</code></li>
<li><code>right_iterator MirrorMap::</code><strong><code>find_right</code></strong><code>(const value_type&amp; pair) const</code></li>
</ul>
<p>Return an iterator pointing to the first matching element, or the appropriate
end iterator if there is no match.</p>
</div>
<div class="defns">
<ul>
<li><code>insert_result MirrorMap::</code><strong><code>insert</code></strong><code>(const value_type&amp; pair)</code></li>
<li><code>template &lt;typename Iterator&gt; void MirrorMap::</code><strong><code>insert</code></strong><code>(Iterator i, Iterator j)</code></li>
</ul>
<p>Insert one or more elements. The returned <code>insert_result</code> contains left and
right iterators pointing to the matching entry, and a boolean to indicate
whether a new element was inserted.</p>
</div>
<div class="defns">
<ul>
<li><code>left_range MirrorMap::</code><strong><code>left</code></strong><code>() const</code></li>
<li><code>left_iterator MirrorMap::</code><strong><code>begin_left</code></strong><code>() const</code></li>
<li><code>left_iterator MirrorMap::</code><strong><code>end_left</code></strong><code>() const</code></li>
<li><code>right_range MirrorMap::</code><strong><code>right</code></strong><code>() const</code></li>
<li><code>right_iterator MirrorMap::</code><strong><code>begin_right</code></strong><code>() const</code></li>
<li><code>right_iterator MirrorMap::</code><strong><code>end_right</code></strong><code>() const</code></li>
</ul>
<p>Iterators over the elements of the map, ordered by the left or right key.</p>
</div>
<div class="defns">
<ul>
<li><code>C1 MirrorMap::</code><strong><code>left_comp</code></strong><code>() const</code></li>
<li><code>C2 MirrorMap::</code><strong><code>right_comp</code></strong><code>() const</code></li>
</ul>
<p>Return copies of the comparison objects.</p>
</div>
<div class="defns">
<ul>
<li><code>left_iterator MirrorMap::</code><strong><code>mirror</code></strong><code>(right_iterator i) const</code></li>
<li><code>right_iterator MirrorMap::</code><strong><code>mirror</code></strong><code>(left_iterator i) const</code></li>
</ul>
<p>Given a left or right iterator, return the right or left iterator that points
to the same element (or an end iterator if the argument was an end iterator).</p>
</div>
<div class="defns">
<ul>
<li><code>size_t MirrorMap::</code><strong><code>size</code></strong><code>() const noexcept</code></li>
</ul>
<p>Returns the number of elements in the container.</p>
</div>
<div class="defns">
<ul>
<li><code>void MirrorMap::</code><strong><code>swap</code></strong><code>(MirrorMap&amp; mm) noexcept</code></li>
<li><code>void</code> <strong><code>swap</code></strong><code>(MirrorMap&amp; mm1, MirrorMap&amp; mm2) noexcept</code></li>
</ul>
<p>Swap two container.</p></body>
</html>
