<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Random Numbers</title>
<link type="text/css" rel="stylesheet" href="style.css"/>
</head>
<body>
<h1 id="random-numbers">Random Numbers</h1>
<p>By Ross Smith</p>
<ul>
<li><code>#include "rs-core/random.hpp"</code></li>
</ul>
<h2 id="contents">Contents</h2>
<div class="toc">
<ul>
<li><a href="#random-numbers">Random Numbers</a><ul>
<li><a href="#contents">Contents</a></li>
<li><a href="#random-number-sources">Random number sources</a><ul>
<li><a href="#lcg-functions">LCG functions</a></li>
<li><a href="#isaac-generators">ISAAC generators</a></li>
<li><a href="#pcg-generators">PCG generators</a></li>
<li><a href="#xoshiro-and-related-generators">Xoshiro and related generators</a></li>
<li><a href="#generic-random-number-engine-wrappers">Generic random number engine wrappers</a></li>
</ul>
</li>
<li><a href="#random-distributions">Random distributions</a><ul>
<li><a href="#basic-random-distributions">Basic random distributions</a></li>
<li><a href="#random-choice-distributions">Random choice distributions</a></li>
<li><a href="#random-samples">Random samples</a></li>
<li><a href="#spatial-distributions">Spatial distributions</a></li>
<li><a href="#unique-distribution">Unique distribution</a></li>
<li><a href="#special-distribution-properties">Special distribution properties</a></li>
</ul>
</li>
<li><a href="#other-random-algorithms">Other random algorithms</a></li>
<li><a href="#text-generators">Text generators</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="random-number-sources">Random number sources</h2>
<h3 id="lcg-functions">LCG functions</h3>
<div class="defns">
<ul>
<li><code>constexpr uint32_t</code> <strong><code>lcg32</code></strong><code>(uint32_t x) noexcept { return 32310901ul * x + 850757001ul; }</code></li>
<li><code>constexpr uint64_t</code> <strong><code>lcg64</code></strong><code>(uint64_t x) noexcept { return 3935559000370003845ull * x + 8831144850135198739ull; }</code></li>
</ul>
<p>Good LCG transformations for 32 and 64 bit integers,
from Pierre L'Ecuyer (1999),
<a href="http://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf">"Tables of Linear Congruential Generators of Different Sizes and Good Lattice Structure"</a>.</p>
</div>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Lcg32</code></strong><ul>
<li><code>using Lcg32::</code><strong><code>result_type</code></strong> <code>= uint32_t</code></li>
<li><code>constexpr Lcg32::</code><strong><code>Lcg32</code></strong><code>() noexcept</code></li>
<li><code>explicit constexpr Lcg32::</code><strong><code>Lcg32</code></strong><code>(uint32_t s) noexcept</code></li>
<li><code>constexpr uint32_t Lcg32::</code><strong><code>operator()</code></strong><code>() noexcept</code></li>
<li><code>constexpr bool Lcg32::</code><strong><code>operator==</code></strong><code>(const Lcg32&amp; rhs) const noexcept</code></li>
<li><code>constexpr bool Lcg32::</code><strong><code>operator!=</code></strong><code>(const Lcg32&amp; rhs) const noexcept</code></li>
<li><code>constexpr void Lcg32::</code><strong><code>seed</code></strong><code>(uint32_t s) noexcept</code></li>
<li><code>static constexpr uint32_t Lcg32::</code><strong><code>min</code></strong><code>() noexcept</code> <em>= 0</em></li>
<li><code>static constexpr uint32_t Lcg32::</code><strong><code>max</code></strong><code>() noexcept</code> <em>= 2<sup>32</sup>-1</em></li>
</ul>
</li>
<li><code>class</code> <strong><code>Lcg64</code></strong><ul>
<li><code>using Lcg64::</code><strong><code>result_type</code></strong> <code>= uint64_t</code></li>
<li><code>constexpr Lcg64::</code><strong><code>Lcg64</code></strong><code>() noexcept</code></li>
<li><code>explicit constexpr Lcg64::</code><strong><code>Lcg64</code></strong><code>(uint64_t s) noexcept</code></li>
<li><code>constexpr uint64_t Lcg64::</code><strong><code>operator()</code></strong><code>() noexcept</code></li>
<li><code>constexpr bool Lcg64::</code><strong><code>operator==</code></strong><code>(const Lcg64&amp; rhs) const noexcept</code></li>
<li><code>constexpr bool Lcg64::</code><strong><code>operator!=</code></strong><code>(const Lcg64&amp; rhs) const noexcept</code></li>
<li><code>constexpr void Lcg64::</code><strong><code>seed</code></strong><code>(uint64_t s) noexcept</code></li>
<li><code>static constexpr uint64_t Lcg64::</code><strong><code>min</code></strong><code>() noexcept</code> <em>= 0</em></li>
<li><code>static constexpr uint64_t Lcg64::</code><strong><code>max</code></strong><code>() noexcept</code> <em>= 2<sup>64</sup>-1</em></li>
</ul>
</li>
</ul>
<p>Random number engine classes based on the above functions.</p>
</div>
<h3 id="isaac-generators">ISAAC generators</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Isaac32</code></strong><ul>
<li><code>using Isaac32::</code><strong><code>result_type</code></strong> <code>= uint32_t</code></li>
<li><code>Isaac32::</code><strong><code>Isaac32</code></strong><code>() noexcept</code></li>
<li><code>explicit Isaac32::</code><strong><code>Isaac32</code></strong><code>(uint32_t s) noexcept</code></li>
<li><code>Isaac32::</code><strong><code>Isaac32</code></strong><code>(const uint32_t* sptr, size_t len) noexcept</code></li>
<li><code>Isaac32::</code><strong><code>Isaac32</code></strong><code>(std::initializer_list&lt;uint32_t&gt; s) noexcept</code></li>
<li><code>uint32_t Isaac32::</code><strong><code>operator()</code></strong><code>() noexcept</code></li>
<li><code>void Isaac32::</code><strong><code>seed</code></strong><code>() noexcept</code></li>
<li><code>void Isaac32::</code><strong><code>seed</code></strong><code>(uint32_t s) noexcept</code></li>
<li><code>void Isaac32::</code><strong><code>seed</code></strong><code>(const uint32_t* sptr, size_t len) noexcept</code></li>
<li><code>void Isaac32::</code><strong><code>seed</code></strong><code>(std::initializer_list&lt;uint32_t&gt; s) noexcept</code></li>
<li><code>static constexpr uint32_t Isaac32::</code><strong><code>min</code></strong><code>() noexcept</code> <em>= 0</em></li>
<li><code>static constexpr uint32_t Isaac32::</code><strong><code>max</code></strong><code>() noexcept</code> <em>= 2<sup>32</sup>-1</em></li>
</ul>
</li>
<li><code>class</code> <strong><code>Isaac64</code></strong><ul>
<li><code>using Isaac64::</code><strong><code>result_type</code></strong> <code>= uint64_t</code></li>
<li><code>Isaac64::</code><strong><code>Isaac64</code></strong><code>() noexcept</code></li>
<li><code>explicit Isaac64::</code><strong><code>Isaac64</code></strong><code>(uint64_t s) noexcept</code></li>
<li><code>Isaac64::</code><strong><code>Isaac64</code></strong><code>(const uint64_t* sptr, size_t len) noexcept</code></li>
<li><code>Isaac64::</code><strong><code>Isaac64</code></strong><code>(std::initializer_list&lt;uint64_t&gt; s) noexcept</code></li>
<li><code>uint64_t Isaac64::</code><strong><code>operator()</code></strong><code>() noexcept</code></li>
<li><code>void Isaac64::</code><strong><code>seed</code></strong><code>() noexcept</code></li>
<li><code>void Isaac64::</code><strong><code>seed</code></strong><code>(uint64_t s) noexcept</code></li>
<li><code>void Isaac64::</code><strong><code>seed</code></strong><code>(const uint64_t* sptr, size_t len) noexcept</code></li>
<li><code>void Isaac64::</code><strong><code>seed</code></strong><code>(std::initializer_list&lt;uint64_t&gt; s) noexcept</code></li>
<li><code>static constexpr uint64_t Isaac64::</code><strong><code>min</code></strong><code>() noexcept</code> <em>= 0</em></li>
<li><code>static constexpr uint64_t Isaac64::</code><strong><code>max</code></strong><code>() noexcept</code> <em>= 2<sup>64</sup>-1</em></li>
</ul>
</li>
</ul>
<p>ISAAC cryptographic quality generator by <a href="http://burtleburtle.net/bob/rand/isaacafa.html">Bob Jenkins</a>.</p>
</div>
<h3 id="pcg-generators">PCG generators</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Pcg32</code></strong><ul>
<li><code>using Pcg32::</code><strong><code>result_type</code></strong> <code>= uint32_t</code></li>
<li><code>constexpr Pcg32::</code><strong><code>Pcg32</code></strong><code>() noexcept</code></li>
<li><code>constexpr explicit Pcg32::</code><strong><code>Pcg32</code></strong><code>(uint64_t s) noexcept</code></li>
<li><code>constexpr uint32_t Pcg32::</code><strong><code>operator()</code></strong><code>() noexcept</code></li>
<li><code>constexpr void Pcg32::</code><strong><code>advance</code></strong><code>(int64_t offset) noexcept</code></li>
<li><code>constexpr void Pcg32::</code><strong><code>seed</code></strong><code>(uint64_t s) noexcept</code></li>
<li><code>static constexpr uint32_t Pcg32::</code><strong><code>min</code></strong><code>() noexcept</code> <em>= 0</em></li>
<li><code>static constexpr uint32_t Pcg32::</code><strong><code>max</code></strong><code>() noexcept</code> <em>= 2<sup>32</sup>-1</em></li>
</ul>
</li>
<li><code>class</code> <strong><code>Pcg64</code></strong><ul>
<li><code>using Pcg64::</code><strong><code>result_type</code></strong> <code>= uint64_t</code></li>
<li><code>constexpr Pcg64::</code><strong><code>Pcg64</code></strong><code>() noexcept</code></li>
<li><code>constexpr explicit Pcg64::</code><strong><code>Pcg64</code></strong><code>(Uint128 s) noexcept</code></li>
<li><code>constexpr explicit Pcg64::</code><strong><code>Pcg64</code></strong><code>(uint64_t hi, uint64_t lo) noexcept</code></li>
<li><code>constexpr uint64_t Pcg64::</code><strong><code>operator()</code></strong><code>() noexcept</code></li>
<li><code>constexpr void Pcg64::</code><strong><code>advance</code></strong><code>(int64_t offset) noexcept</code></li>
<li><code>constexpr void Pcg64::</code><strong><code>seed</code></strong><code>(Uint128 s) noexcept</code></li>
<li><code>constexpr void Pcg64::</code><strong><code>seed</code></strong><code>(uint64_t hi, uint64_t lo) noexcept</code></li>
<li><code>static constexpr uint64_t Pcg64::</code><strong><code>min</code></strong><code>() noexcept</code> <em>= 0</em></li>
<li><code>static constexpr uint64_t Pcg64::</code><strong><code>max</code></strong><code>() noexcept</code> <em>= 2<sup>64</sup>-1</em></li>
</ul>
</li>
</ul>
<p>PCG generators by <a href="http://www.pcg-random.org/">Melissa O'Neill</a>.</p>
</div>
<h3 id="xoshiro-and-related-generators">Xoshiro and related generators</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>SplitMix64</code></strong><ul>
<li><code>using SplitMix64::</code><strong><code>result_type</code></strong> <code>= uint64_t</code></li>
<li><code>constexpr SplitMix64::</code><strong><code>SplitMix64</code></strong><code>() noexcept: x(0)</code></li>
<li><code>constexpr explicit SplitMix64::</code><strong><code>SplitMix64</code></strong><code>(uint64_t s) noexcept: x (s)</code></li>
<li><code>constexpr uint64_t SplitMix64::</code><strong><code>operator()</code></strong><code>() noexcept</code></li>
<li><code>constexpr void SplitMix64::</code><strong><code>seed</code></strong><code>(uint64_t s = 0) noexcept</code></li>
<li><code>static constexpr uint64_t SplitMix64::</code><strong><code>min</code></strong><code>() noexcept</code></li>
<li><code>static constexpr uint64_t SplitMix64::</code><strong><code>max</code></strong><code>() noexcept</code></li>
</ul>
</li>
<li><code>class</code> <strong><code>Xoroshiro64s</code></strong></li>
<li><code>class</code> <strong><code>Xoroshiro64ss</code></strong></li>
<li><code>class</code> <strong><code>Xoroshiro128p</code></strong></li>
<li><code>class</code> <strong><code>Xoroshiro128ss</code></strong></li>
<li><code>class</code> <strong><code>Xoshiro128p</code></strong></li>
<li><code>class</code> <strong><code>Xoshiro128ss</code></strong></li>
<li><code>class</code> <strong><code>Xoshiro256p</code></strong></li>
<li><code>class</code> <strong><code>Xoshiro256ss</code></strong><ul>
<li><code>using [Xoroshiro64,Xoshiro128]::</code><strong><code>result_type</code></strong> <code>= uint32_t</code></li>
<li><code>using [Xoroshiro128,Xoshiro256]::</code><strong><code>result_type</code></strong> <code>= uint64_t</code></li>
<li><code>constexpr [Class]::</code><strong><code>[Class]</code></strong><code>() noexcept</code></li>
<li><code>constexpr explicit [Class]::</code><strong><code>[Class]</code></strong><code>(result_type s) noexcept</code></li>
<li><code>constexpr [Xoroshiro]::</code><strong><code>[Class]</code></strong><code>(result_type s, result_type t) noexcept</code></li>
<li><code>constexpr [Xoshiro]::</code><strong><code>[Class]</code></strong><code>(result_type s, result_type t, result_type u, result_type v) noexcept</code></li>
<li><code>constexpr result_type [Class]::</code><strong><code>operator()</code></strong><code>() noexcept</code></li>
<li><code>constexpr void [Class]::</code><strong><code>seed</code></strong><code>(result_type s = 0) noexcept</code></li>
<li><code>constexpr void [Class]::</code><strong><code>seed</code></strong><code>(result_type s, result_type t) noexcept</code></li>
<li><code>constexpr void [Xoshiro]::</code><strong><code>seed</code></strong><code>(result_type s, result_type t, result_type u, result_type v) noexcept</code></li>
<li><code>static constexpr result_type [Class]::</code><strong><code>min</code></strong><code>() noexcept</code></li>
<li><code>static constexpr result_type [Class]::</code><strong><code>max</code></strong><code>() noexcept</code></li>
</ul>
</li>
<li><code>using</code> <strong><code>Xoshiro</code></strong> <code>= Xoshiro256ss</code></li>
</ul>
<p>Xoshiro and related algorithms by <a href="http://xoshiro.di.unimi.it/">David Blackman and Sebastiano Vigna</a>.</p>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Result</th>
<th>State</th>
<th>Seeds</th>
<th>Recommendation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SplitMix64</code></td>
<td><code>uint64_t</code></td>
<td>8 bytes</td>
<td>1 <code>uint64_t</code></td>
<td>Used internally in <code>Xoshiro/Xoroshiro</code>; not recommended for general purpose</td>
</tr>
<tr>
<td><code>Xoroshiro64s</code></td>
<td><code>uint32_t</code></td>
<td>8 bytes</td>
<td>1 or 2 <code>uint32_t</code></td>
<td>Substitute for <code>Xoshiro128p</code> when small state is important</td>
</tr>
<tr>
<td><code>Xoroshiro64ss</code></td>
<td><code>uint32_t</code></td>
<td>8 bytes</td>
<td>1 or 2 <code>uint32_t</code></td>
<td>Substitute for <code>Xoshiro128ss</code> when small state is important</td>
</tr>
<tr>
<td><code>Xoroshiro128p</code></td>
<td><code>uint64_t</code></td>
<td>16 bytes</td>
<td>1 or 2 <code>uint64_t</code></td>
<td>Substitute for <code>Xoshiro256p</code> when small state is important</td>
</tr>
<tr>
<td><code>Xoroshiro128ss</code></td>
<td><code>uint64_t</code></td>
<td>16 bytes</td>
<td>1 or 2 <code>uint64_t</code></td>
<td>Substitute for <code>Xoshiro256ss</code> when small state is important</td>
</tr>
<tr>
<td><code>Xoshiro128p</code></td>
<td><code>uint32_t</code></td>
<td>16 bytes</td>
<td>1, 2, or 4 <code>uint32_t</code></td>
<td>Faster than <code>Xoshiro128ss</code>, but low bits are poor</td>
</tr>
<tr>
<td><code>Xoshiro128ss</code></td>
<td><code>uint32_t</code></td>
<td>16 bytes</td>
<td>1, 2, or 4 <code>uint32_t</code></td>
<td>Best general purpose 32-bit</td>
</tr>
<tr>
<td><code>Xoshiro256p</code></td>
<td><code>uint64_t</code></td>
<td>32 bytes</td>
<td>1, 2, or 4 <code>uint64_t</code></td>
<td>Faster than <code>Xoshiro256ss</code>, but low bits are poor</td>
</tr>
<tr>
<td><code>Xoshiro256ss</code></td>
<td><code>uint64_t</code></td>
<td>32 bytes</td>
<td>1, 2, or 4 <code>uint64_t</code></td>
<td>Best general purpose</td>
</tr>
<tr>
<td><code>Xoshiro</code></td>
<td><code>uint64_t</code></td>
<td>32 bytes</td>
<td>1, 2, or 4 <code>uint64_t</code></td>
<td>Synonym for <code>Xoshiro256ss</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="generic-random-number-engine-wrappers">Generic random number engine wrappers</h3>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>GenRng32</code></strong><ul>
<li><code>using GenRng32::</code><strong><code>result_type</code></strong> <code>= uint32_t</code></li>
<li><code>GenRng32::</code><strong><code>GenRng32</code></strong><code>() noexcept</code></li>
<li><code>template &lt;typename RNG&gt; GenRng32::</code><strong><code>GenRng32</code></strong><code>(RNG&amp; rng)</code></li>
<li><code>uint32_t GenRng32::</code><strong><code>operator()</code></strong><code>()</code></li>
<li><code>static constexpr uint32_t GenRng32::</code><strong><code>min</code></strong><code>() noexcept</code> <em>(min = 0)</em></li>
<li><code>static constexpr uint32_t GenRng32::</code><strong><code>max</code></strong><code>() noexcept</code> <em>(max = 2<sup>32</sup>-1)</em></li>
</ul>
</li>
<li><code>class</code> <strong><code>GenRng64</code></strong><ul>
<li><code>using GenRng64::</code><strong><code>result_type</code></strong> <code>= uint64_t</code></li>
<li><code>GenRng64::</code><strong><code>GenRng64</code></strong><code>() noexcept</code></li>
<li><code>template &lt;typename RNG&gt; GenRng64::</code><strong><code>GenRng64</code></strong><code>(RNG&amp; rng)</code></li>
<li><code>uint64_t GenRng64::</code><strong><code>operator()</code></strong><code>()</code></li>
<li><code>static constexpr uint64_t GenRng64::</code><strong><code>min</code></strong><code>() noexcept</code> <em>(min = 0)</em></li>
<li><code>static constexpr uint64_t GenRng64::</code><strong><code>max</code></strong><code>() noexcept</code> <em>(max = 2<sup>64</sup>-1)</em></li>
</ul>
</li>
</ul>
<p>Wrapper function objects that call an arbitrary random number engine and
return a uniformly distributed value, from zero to 2<sup>32</sup>-1 or
2<sup>64</sup>-1. A single call to <code>GenRng*::operator()</code> may call the
underlying RNG more than once. A default constructed <code>GenRng*</code> will always
return zero</p>
<p>The <code>GenRng*</code> object holds a reference to the generator that was passed to the
constructor, which is expected to remain valid. Behaviour is undefined if the
underlying generator is destroyed while a <code>GenRng*</code> object still has a
reference to it.</p>
</div>
<h2 id="random-distributions">Random distributions</h2>
<h3 id="basic-random-distributions">Basic random distributions</h3>
<p>These are similar to the standard distribution classes, but provide portable
deterministic behaviour: given the same pseudo-random number engine (the <code>RNG</code>
type), these can be relied on to return the same values on different systems
and compilers (apart from small differences due to rounding errors in the
floating point distributions).</p>
<p>Each distribution (apart from the boolean distribution) is provided both as a
class template, which requires the result type to be supplied explicitly, and
as one or more functions that deduce the result type and return an instance of
the class.</p>
<p>Most of these also provide statistical functions that return properties of the
distribution:</p>
<p>The <code>pdf()</code>, <code>cdf()</code>, and <code>ccdf()</code> functions represent the probability
distribution function, cumulative distribution function, and complementary
cumulative distribution function. For discrete distributions, <code>pdf(x)</code> is the
probably of a result exactly equal to <code>x</code>, <code>cdf(x)</code> is the probability of a
result less than or equal to <code>x</code>, and <code>ccdf(x)</code> is the probability of a result
greater than or equal to <code>x</code> (<code>cdf+ccdf-pdf=1</code>). For continuous distributions,
<code>pdf(x)</code> is the probably density at <code>x</code>, <code>cdf(x)</code> is the probability of a
result less than <code>x</code>, and <code>ccdf(x)</code> is the probability of a result greater
than <code>x</code> (<code>cdf+ccdf=1</code>).</p>
<p>The <code>quantile()</code> and <code>cquantile()</code> (complementary quantile) functions are only
defined for continuous distributions, and are the inverse of <code>cdf()</code> and
<code>ccdf()</code> respectively. Behaviour is undefined if the argument to one of the
quantile functions is less than 0 or greater than 1; it may or may not be
defined for exactly 0 or 1, depending on how the distribution is bounded.</p>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>UniformInteger</code></strong><ul>
<li><code>using UniformInteger::</code><strong><code>result_type</code></strong> <code>= T</code></li>
<li><code>UniformInteger::</code><strong><code>UniformInteger</code></strong><code>() noexcept</code></li>
<li><code>UniformInteger::</code><strong><code>UniformInteger</code></strong><code>(T a, T b) noexcept</code></li>
<li><code>template &lt;typename RNG&gt; T UniformInteger::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>T UniformInteger::</code><strong><code>min</code></strong><code>() const noexcept</code></li>
<li><code>T UniformInteger::</code><strong><code>max</code></strong><code>() const noexcept</code></li>
<li><code>Rational&lt;T&gt; UniformInteger::</code><strong><code>mean</code></strong><code>() const noexcept</code></li>
<li><code>Rational&lt;T&gt; UniformInteger::</code><strong><code>variance</code></strong><code>() const noexcept</code></li>
<li><code>double UniformInteger::</code><strong><code>sd</code></strong><code>() const noexcept</code></li>
<li><code>double UniformInteger::</code><strong><code>pdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>double UniformInteger::</code><strong><code>cdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>double UniformInteger::</code><strong><code>ccdf</code></strong><code>(T x) const noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T&gt; UniformInteger&lt;T&gt;</code> <strong><code>random_integer</code></strong><code>(T t)</code></li>
<li><code>template &lt;typename T&gt; UniformInteger&lt;T&gt;</code> <strong><code>random_integer</code></strong><code>(T a, T b)</code></li>
</ul>
<p>Uniform random integer distribution. This returns an integer from <code>a</code> to <code>b</code>
inclusive; the bounds can be supplied in either order. If a single argument is
supplied, it returns an integer from 0 to <code>t-1</code> inclusive (always 0 if <code>t&lt;2</code>).
A default constructed distribution always returns zero.</p>
</div>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Bernoulli</code></strong><ul>
<li><code>using Bernoulli::</code><strong><code>result_type</code></strong> <code>= bool</code></li>
<li><code>Bernoulli::</code><strong><code>Bernoulli</code></strong><code>() noexcept</code></li>
<li><code>explicit Bernoulli::</code><strong><code>Bernoulli</code></strong><code>(Rat p) noexcept</code></li>
<li><code>template &lt;typename RNG&gt; bool Bernoulli::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>Rat Bernoulli::</code><strong><code>prob</code></strong><code>() const noexcept</code></li>
</ul>
</li>
<li><code>Bernoulli</code> <strong><code>random_boolean</code></strong><code>()</code></li>
<li><code>Bernoulli</code> <strong><code>random_boolean</code></strong><code>(Rat p)</code></li>
<li><code>Bernoulli</code> <strong><code>random_boolean</code></strong><code>(int a, int b)</code></li>
<li><code>Bernoulli</code> <strong><code>random_boolean</code></strong><code>(double p)</code></li>
</ul>
<p>Random boolean (Bernoulli) distribution. The probability of success defaults
to 1/2; it can be supplied as a rational, a pair of integers (representing a
ratio), or a floating point number. Probabilities outside the 0-1 range are
clamped to the nearest end of the range.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>Binomial</code></strong><ul>
<li><code>using Binomial::</code><strong><code>result_type</code></strong> <code>= T</code></li>
<li><code>Binomial::</code><strong><code>Binomial</code></strong><code>() noexcept</code></li>
<li><code>Binomial::</code><strong><code>Binomial</code></strong><code>(const Rational&lt;T&gt;&amp; p, T n) noexcept</code></li>
<li><code>template &lt;typename RNG&gt; bool Binomial::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>Rational&lt;T&gt; Binomial::</code><strong><code>prob</code></strong><code>() const noexcept</code></li>
<li><code>T Binomial::</code><strong><code>number</code></strong><code>() const noexcept</code></li>
<li><code>T Binomial::</code><strong><code>min</code></strong><code>() const  noexcept</code></li>
<li><code>T Binomial::</code><strong><code>max</code></strong><code>() const  noexcept</code></li>
<li><code>Rational&lt;T&gt; Binomial::</code><strong><code>mean</code></strong><code>() const noexcept</code></li>
<li><code>Rational&lt;T&gt; Binomial::</code><strong><code>variance</code></strong><code>() const noexcept</code></li>
<li><code>double Binomial::</code><strong><code>sd</code></strong><code>() const  noexcept</code></li>
<li><code>double Binomial::</code><strong><code>pdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>double Binomial::</code><strong><code>cdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>double Binomial::</code><strong><code>ccdf</code></strong><code>(T x) const noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T&gt; Binomial</code> <strong><code>random_boolean</code></strong><code>(const Rational&lt;T&gt;&amp; p, T n) noexcept</code></li>
</ul>
<p>Binomial distribution, reporting the number of successes after <code>n</code> tests each
with probability <code>p</code>. The argument <code>p</code> is clamped to the 0-1 range; the result
is always zero if <code>n&lt;1</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>Dice</code></strong><ul>
<li><code>using Dice::</code><strong><code>result_type</code></strong> <code>= T</code></li>
<li><code>Dice::</code><strong><code>Dice</code></strong><code>() noexcept</code></li>
<li><code>Dice::</code><strong><code>Dice</code></strong><code>(T n, T faces) noexcept</code></li>
<li><code>template &lt;typename RNG&gt; T Dice::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>T Dice::</code><strong><code>number</code></strong><code>() const noexcept</code></li>
<li><code>T Dice::</code><strong><code>faces</code></strong><code>() const noexcept</code></li>
<li><code>T Dice::</code><strong><code>min</code></strong><code>() const noexcept</code></li>
<li><code>T Dice::</code><strong><code>max</code></strong><code>() const noexcept</code></li>
<li><code>Rational&lt;T&gt; Dice::</code><strong><code>mean</code></strong><code>() const noexcept</code></li>
<li><code>Rational&lt;T&gt; Dice::</code><strong><code>variance</code></strong><code>() const noexcept</code></li>
<li><code>double Dice::</code><strong><code>sd</code></strong><code>() const noexcept</code></li>
<li><code>double Dice::</code><strong><code>pdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>double Dice::</code><strong><code>cdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>double Dice::</code><strong><code>ccdf</code></strong><code>(T x) const noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T&gt; Dice&lt;T&gt;</code> <strong><code>random_dice</code></strong><code>(T n = 1, T faces = 6)</code></li>
</ul>
<p>This generates the result of rolling <code>n</code> dice, each numbered from <code>1</code> to
<code>faces</code>. The default constructor sets <code>n=1</code> and <code>faces=6</code>. This will always
return zero if either argument is less than 1.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>TriangleInteger</code></strong><ul>
<li><code>using TriangleInteger::</code><strong><code>result_type</code></strong> <code>= T</code></li>
<li><code>TriangleInteger::</code><strong><code>TriangleInteger</code></strong><code>() noexcept</code></li>
<li><code>TriangleInteger::</code><strong><code>TriangleInteger</code></strong><code>(T hi, T lo) noexcept</code></li>
<li><code>template &lt;typename RNG&gt; T TriangleInteger::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>T TriangleInteger::</code><strong><code>high_end</code></strong><code>() const noexcept</code></li>
<li><code>T TriangleInteger::</code><strong><code>low_end</code></strong><code>() const noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T&gt; TriangleInteger&lt;T&gt;</code> <strong><code>random_triangle_integer</code></strong><code>(T hi, T lo)</code></li>
</ul>
<p>This returns an integer with a triangular distribution, with the highest
probability at <code>hi</code> and the lowest at <code>lo</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>UniformReal</code></strong><ul>
<li><code>using UniformReal::</code><strong><code>result_type</code></strong> <code>= T</code></li>
<li><code>UniformReal::</code><strong><code>UniformReal</code></strong><code>() noexcept</code></li>
<li><code>UniformReal::</code><strong><code>UniformReal</code></strong><code>(T a, T b) noexcept</code></li>
<li><code>template &lt;typename RNG&gt; T UniformReal::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>T UniformReal::</code><strong><code>min</code></strong><code>() const noexcept</code></li>
<li><code>T UniformReal::</code><strong><code>max</code></strong><code>() const noexcept</code></li>
<li><code>T UniformReal::</code><strong><code>mean</code></strong><code>() const noexcept</code></li>
<li><code>T UniformReal::</code><strong><code>sd</code></strong><code>() const noexcept</code></li>
<li><code>T UniformReal::</code><strong><code>variance</code></strong><code>() const noexcept</code></li>
<li><code>T UniformReal::</code><strong><code>pdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T UniformReal::</code><strong><code>cdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T UniformReal::</code><strong><code>ccdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T UniformReal::</code><strong><code>quantile</code></strong><code>(T p) const noexcept</code></li>
<li><code>T UniformReal::</code><strong><code>cquantile</code></strong><code>(T q) const noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T&gt; UniformReal&lt;T&gt;</code> <strong><code>random_real</code></strong><code>()</code></li>
<li><code>template &lt;typename T&gt; UniformReal&lt;T&gt;</code> <strong><code>random_real</code></strong><code>(T max)</code></li>
<li><code>template &lt;typename T&gt; UniformReal&lt;T&gt;</code> <strong><code>random_real</code></strong><code>(T a, T b)</code></li>
</ul>
<p>Uniform random floating point distribution. This returns a number from <code>a</code> to
<code>b</code>; the bounds can be supplied in either order. If a single argument is
supplied, it returns a number from 0 to <code>t</code> ('t' may be negative). A default
constructed distribution return a value in the unit range.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>Normal</code></strong><ul>
<li><code>using Normal::</code><strong><code>result_type</code></strong> <code>= T</code></li>
<li><code>Normal::</code><strong><code>Normal</code></strong><code>() noexcept</code></li>
<li><code>Normal::</code><strong><code>Normal</code></strong><code>(T mean, T sd) noexcept</code></li>
<li><code>template &lt;typename RNG&gt; T Normal::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>T Normal::</code><strong><code>mean</code></strong><code>() const noexcept</code></li>
<li><code>T Normal::</code><strong><code>sd</code></strong><code>() const noexcept</code></li>
<li><code>T Normal::</code><strong><code>variance</code></strong><code>() const noexcept</code></li>
<li><code>T Normal::</code><strong><code>pdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T Normal::</code><strong><code>cdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T Normal::</code><strong><code>ccdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T Normal::</code><strong><code>quantile</code></strong><code>(T p) const noexcept</code></li>
<li><code>T Normal::</code><strong><code>cquantile</code></strong><code>(T q) const noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T&gt; Normal&lt;T&gt;</code> <strong><code>random_normal</code></strong><code>()</code></li>
<li><code>template &lt;typename T&gt; Normal&lt;T&gt;</code> <strong><code>random_normal</code></strong><code>(T mean, T sd)</code></li>
</ul>
<p>Normal (Gaussian) distribution, with the given mean and standard deviation.
The absolute value of the standard deviation is used. The default constructor
sets <code>mean=0</code> and <code>sd=1</code>. The quantile functions use the Beasley-Springer
approximation: for <code>|z|&lt;3.75</code>, absolute error is less than <code>1e-6</code>, relative
error is less than <code>2.5e-7</code>; for <code>|z|&lt;7.5</code>, absolute error is less than
<code>5e-4</code>, relative error is less than <code>5e-5</code>. Behaviour is undefined if the
distribution property functions are called when the standard deviation is
zero.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>DiscreteNormal</code></strong><ul>
<li><code>using DiscreteNormal::</code><strong><code>result_type</code></strong> <code>= T</code></li>
<li><code>DiscreteNormal::</code><strong><code>DiscreteNormal</code></strong><code>()</code></li>
<li><code>DiscreteNormal::</code><strong><code>DiscreteNormal</code></strong><code>(const Rational&lt;T&gt;&amp; mean, const Rational&lt;T&gt;&amp; sd)</code></li>
<li><code>template &lt;typename RNG&gt; T DiscreteNormal::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>Rational&lt;T&gt; DiscreteNormal::</code><strong><code>mean</code></strong><code>() const noexcept</code></li>
<li><code>Rational&lt;T&gt; DiscreteNormal::</code><strong><code>sd</code></strong><code>() const noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T&gt; DiscreteNormal&lt;T&gt;</code> <strong><code>random_discrete_normal</code></strong><code>(const Rational&lt;T&gt;&amp; mean, const Rational&lt;T&gt;&amp; sd)</code></li>
</ul>
<p>Generates an integer that follows a good deterministic approximation to the
result of generating a normally distributed real value and then rounding it to
an integer.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, typename S = double&gt; class</code> <strong><code>Poisson</code></strong><ul>
<li><code>using Poisson::</code><strong><code>result_type</code></strong> <code>= T</code></li>
<li><code>using Poisson::</code><strong><code>scalar_type</code></strong> <code>= S</code></li>
<li><code>Poisson::</code><strong><code>Poisson</code></strong><code>()</code></li>
<li><code>explicit Poisson::</code><strong><code>Poisson</code></strong><code>(S lambda) noexcept</code></li>
<li><code>template &lt;typename RNG&gt; T Poisson::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>S Poisson::</code><strong><code>lambda</code></strong><code>() const noexcept</code></li>
<li><code>S Poisson::</code><strong><code>mean</code></strong><code>() const noexcept</code></li>
<li><code>S Poisson::</code><strong><code>variance</code></strong><code>() const noexcept</code></li>
<li><code>S Poisson::</code><strong><code>sd</code></strong><code>() const noexcept</code></li>
<li><code>S Poisson::</code><strong><code>pdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>S Poisson::</code><strong><code>cdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>S Poisson::</code><strong><code>ccdf</code></strong><code>(T x) const noexcept</code></li>
</ul>
</li>
</ul>
<p>Poisson distribution. <code>T</code> and <code>S</code> must be integer and floating point types
respectively. The default constructor sets <code>lambda=1</code>. Behaviour is undefined
if <code>lambda&lt;=0</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>Beta</code></strong><ul>
<li><code>using Beta::</code><strong><code>result_type</code></strong> <code>= T</code></li>
<li><code>Beta::</code><strong><code>Beta</code></strong><code>() noexcept</code></li>
<li><code>Beta::</code><strong><code>Beta</code></strong><code>(T a, T b) noexcept</code></li>
<li><code>template &lt;typename RNG&gt; T Beta::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>T Beta::</code><strong><code>alpha</code></strong><code>() const noexcept</code></li>
<li><code>T Beta::</code><strong><code>beta</code></strong><code>() const noexcept</code></li>
<li><code>T Beta::</code><strong><code>mean</code></strong><code>() const noexcept</code></li>
<li><code>T Beta::</code><strong><code>variance</code></strong><code>() const noexcept</code></li>
<li><code>T Beta::</code><strong><code>sd</code></strong><code>() const noexcept</code></li>
<li><code>T Beta::</code><strong><code>pdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T Beta::</code><strong><code>cdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T Beta::</code><strong><code>ccdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T Beta::</code><strong><code>quantile</code></strong><code>(T p) const noexcept</code></li>
<li><code>T Beta::</code><strong><code>cquantile</code></strong><code>(T q) const noexcept</code></li>
</ul>
</li>
</ul>
<p>Beta distribution. The default constructor sets <code>a=b=1</code>, which produces a
uniform distribution. Behaviour is undefined if <code>a&lt;=0</code> or <code>b&lt;=0</code>.</p>
</div>
<h3 id="random-choice-distributions">Random choice distributions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>Choice</code></strong><ul>
<li><code>using Choice::</code><strong><code>result_type</code></strong> <code>= T</code></li>
<li><code>using Choice::</code><strong><code>value_type</code></strong> <code>= T</code></li>
<li><code>Choice::</code><strong><code>Choice</code></strong><code>() noexcept</code></li>
<li><code>template &lt;typename InputIterator&gt; Choice::</code><strong><code>Choice</code></strong><code>(InputIterator i, InputIterator j)</code></li>
<li><code>template &lt;typename InputRange&gt; explicit Choice::</code><strong><code>Choice</code></strong><code>(const InputRange&amp; list)</code></li>
<li><code>Choice::</code><strong><code>Choice</code></strong><code>(std::initializer_list&lt;T&gt; list)</code></li>
<li><code>template &lt;typename RNG&gt; const T&amp; Choice::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>void Choice::</code><strong><code>add</code></strong><code>(const T&amp; t)</code></li>
<li><code>void Choice::</code><strong><code>push_back</code></strong><code>(const T&amp; t)</code></li>
<li><code>void Choice::</code><strong><code>append</code></strong><code>(initializer_list&lt;T&gt; list)</code></li>
<li><code>template &lt;typename InputRange&gt; void Choice::</code><strong><code>append</code></strong><code>(const InputRange&amp; list)</code></li>
<li><code>void Choice::</code><strong><code>clear</code></strong><code>() noexcept</code></li>
<li><code>bool Choice::</code><strong><code>empty</code></strong><code>() const noexcept</code></li>
<li><code>size_t Choice::</code><strong><code>size</code></strong><code>() const noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename InputIterator&gt; Choice&lt;[value type]&gt;</code> <strong><code>random_choice</code></strong><code>(InputIterator i, InputIterator j)</code></li>
<li><code>template &lt;typename InputRange&gt; Choice&lt;[value type]&gt;</code> <strong><code>random_choice</code></strong><code>(const InputRange&amp; list)</code></li>
<li><code>template &lt;typename T&gt; Choice&lt;T&gt;</code> <strong><code>random_choice</code></strong><code>(std::initializer_list&lt;T&gt; list)</code></li>
<li><code>template &lt;typename ForwardIterator, typename RNG&gt; const [value type]&amp;</code> <strong><code>random_choice_from</code></strong><code>(ForwardIterator i, ForwardIterator j, RNG&amp; rng)</code></li>
<li><code>template &lt;typename ForwardRange, typename RNG&gt; const [value type]&amp;</code> <strong><code>random_choice_from</code></strong><code>(const ForwardRange&amp; list, RNG&amp; rng)</code></li>
<li><code>template &lt;typename T, typename RNG&gt; const T&amp;</code> <strong><code>random_choice_from</code></strong><code>(std::initializer_list&lt;T&gt; list, RNG&amp; rng)</code></li>
</ul>
<p>Selects an element at random from the input list. The <code>add()</code> and
<code>push_back()</code> functions are synonyms. The <code>random_choice_from()</code> functions are
shortcuts that can be used to avoid the overhead of copying the list in
one-time calls. Behaviour is undefined if the list is empty.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, typename F = double&gt; class</code> <strong><code>WeightedChoice</code></strong><ul>
<li><code>using WeightedChoice::</code><strong><code>frequency_type</code></strong> <code>= F</code></li>
<li><code>using WeightedChoice::</code><strong><code>result_type</code></strong> <code>= T</code></li>
<li><code>using WeightedChoice::</code><strong><code>value_type</code></strong> <code>= std::pair&lt;T, F&gt;</code></li>
<li><code>WeightedChoice::</code><strong><code>WeightedChoice</code></strong><code>() noexcept</code></li>
<li><code>WeightedChoice::</code><strong><code>WeightedChoice</code></strong><code>(initializer_list&lt;std::pair&lt;T, F&gt;&gt; pairs)</code></li>
<li><code>template &lt;typename InputRange&gt; explicit WeightedChoice::</code><strong><code>WeightedChoice</code></strong><code>(const InputRange&amp; pairs)</code></li>
<li><code>template &lt;typename RNG&gt; const T&amp; WeightedChoice::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>void WeightedChoice::</code><strong><code>add</code></strong><code>(const T&amp; t, F f)</code></li>
<li><code>void WeightedChoice::</code><strong><code>add</code></strong><code>(const value_type&amp; pair)</code></li>
<li><code>void WeightedChoice::</code><strong><code>push_back</code></strong><code>(const value_type&amp; pair)</code></li>
<li><code>void WeightedChoice::</code><strong><code>append</code></strong><code>(initializer_list&lt;std::pair&lt;T, F&gt;&gt; pairs)</code></li>
<li><code>template &lt;typename InputRange&gt; void WeightedChoice::</code><strong><code>append</code></strong><code>(const InputRange&amp; pairs)</code></li>
<li><code>void WeightedChoice::</code><strong><code>clear</code></strong><code>() noexcept</code></li>
<li><code>bool WeightedChoice::</code><strong><code>empty</code></strong><code>() const noexcept</code></li>
</ul>
</li>
</ul>
<p>Selects items at random from a weighted list. The frequency type (<code>F</code>) must be
an arithmetic type; it can be an integer or floating point type. The default
constructor creates an empty list; the other constructors copy a list of
<code>(value,frequency)</code> pairs. The <code>add()</code> and <code>append()</code> functions can be used to
add <code>(value,frequency)</code> pairs, one at a time or in bulk (<code>push_back()</code> is a
synonym for <code>add()</code>). Entries with a frequency less than or equal to zero are
ignored. Behaviour is undefined if the function call operator is called on an
empty set.</p>
</div>
<h3 id="random-samples">Random samples</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename ForwardRange, typename RNG&gt; vector&lt;[value type]&gt;</code> <strong><code>random_sample_from</code></strong><code>(const ForwardRange&amp; range, size_t k, RNG&amp; rng)</code></li>
</ul>
<p>Returns a random sample of <code>k</code> elements from the input range. This will throw
<code>std::length_error</code> if <code>k</code> is larger than the size of the range.</p>
</div>
<h3 id="spatial-distributions">Spatial distributions</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T, size_t N&gt; class</code> <strong><code>RandomVector</code></strong><ul>
<li><code>using RandomVector::</code><strong><code>result_type</code></strong> <code>= Vector&lt;T, N&gt;</code></li>
<li><code>using RandomVector::</code><strong><code>scalar_type</code></strong> <code>= T</code></li>
<li><code>static constexpr size_t RandomVector::</code><strong><code>dim</code></strong> <code>= N</code></li>
<li><code>RandomVector::</code><strong><code>RandomVector</code></strong><code>()</code></li>
<li><code>explicit RandomVector::</code><strong><code>RandomVector</code></strong><code>(T t)</code></li>
<li><code>explicit RandomVector::</code><strong><code>RandomVector</code></strong><code>(const Vector&lt;T, N&gt;&amp; v)</code></li>
<li><code>template &lt;typename RNG&gt; Vector&lt;T, N&gt; RandomVector::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>Vector&lt;T, N&gt; RandomVector::</code><strong><code>scale</code></strong><code>() const</code></li>
</ul>
</li>
<li><code>template &lt;typename T, size_t N&gt; class</code> <strong><code>SymmetricRandomVector</code></strong><ul>
<li><code>using SymmetricRandomVector::</code><strong><code>result_type</code></strong> <code>= Vector&lt;T, N&gt;</code></li>
<li><code>using SymmetricRandomVector::</code><strong><code>scalar_type</code></strong> <code>= T</code></li>
<li><code>static constexpr size_t SymmetricRandomVector::</code><strong><code>dim</code></strong> <code>= N</code></li>
<li><code>SymmetricRandomVector::</code><strong><code>SymmetricRandomVector</code></strong><code>()</code></li>
<li><code>explicit SymmetricRandomVector::</code><strong><code>SymmetricRandomVector</code></strong><code>(T t)</code></li>
<li><code>explicit SymmetricRandomVector::</code><strong><code>SymmetricRandomVector</code></strong><code>(const Vector&lt;T, N&gt;&amp; v)</code></li>
<li><code>template &lt;typename RNG&gt; Vector&lt;T, N&gt; SymmetricRandomVector::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>Vector&lt;T, N&gt; SymmetricRandomVector::</code><strong><code>scale</code></strong><code>() const</code></li>
</ul>
</li>
</ul>
<p><code>RandomVector</code> generates a random vector in the rectilinear volume between the
origin and the vector supplied to the constructor (the unit cube by default).
<code>SymmetricRandomVector</code> generates a vector in a volume symmetrical about the
origin, between <code>v</code> and <code>-v</code>. The <code>scale()</code> function returns the vector
supplied to the constructor.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, size_t N&gt; class</code> <strong><code>RandomInSphere</code></strong><ul>
<li><code>using RandomInSphere::</code><strong><code>result_type</code></strong> <code>= Vector&lt;T, N&gt;</code></li>
<li><code>using RandomInSphere::</code><strong><code>scalar_type</code></strong> <code>= T</code></li>
<li><code>static constexpr size_t RandomInSphere::</code><strong><code>dim</code></strong> <code>= N</code></li>
<li><code>RandomInSphere::</code><strong><code>RandomInSphere</code></strong><code>()</code></li>
<li><code>explicit RandomInSphere::</code><strong><code>RandomInSphere</code></strong><code>(T r)</code></li>
<li><code>template &lt;typename RNG&gt; Vector&lt;T, N&gt; RandomInSphere::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>T RandomInSphere::</code><strong><code>radius</code></strong><code>() const noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T, size_t N&gt; class</code> <strong><code>RandomOnSphere</code></strong><ul>
<li><code>using RandomOnSphere::</code><strong><code>result_type</code></strong> <code>= Vector&lt;T, N&gt;</code></li>
<li><code>using RandomOnSphere::</code><strong><code>scalar_type</code></strong> <code>= T</code></li>
<li><code>static constexpr size_t RandomOnSphere::</code><strong><code>dim</code></strong> <code>= N</code></li>
<li><code>RandomOnSphere::</code><strong><code>RandomOnSphere</code></strong><code>()</code></li>
<li><code>explicit RandomOnSphere::</code><strong><code>RandomOnSphere</code></strong><code>(T r)</code></li>
<li><code>template &lt;typename RNG&gt; Vector&lt;T, N&gt; RandomOnSphere::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng) const</code></li>
<li><code>T RandomOnSphere::</code><strong><code>radius</code></strong><code>() const noexcept</code></li>
</ul>
</li>
</ul>
<p>These generate a random point inside or on the surface of a sphere in
<code>N</code>-dimensional space. <code>T</code> must be a floating point arithmetic type; <code>N</code> must
be a positive integer. The radius of the sphere defaults to 1; the absolute
value of the radius is used if it is negative. Note that, because of the
limitations of floating point arithmetic, the point generated by
<code>RandomOnSphere</code> cannot be guaranteed to be exactly on the surface.</p>
</div>
<h3 id="unique-distribution">Unique distribution</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; struct</code> <strong><code>UniqueGenerator</code></strong><ul>
<li><code>using UniqueGenerator::</code><strong><code>distribution_type</code></strong> <code>= T</code></li>
<li><code>using UniqueGenerator::</code><strong><code>result_type</code></strong> <code>= [result type of T]</code></li>
<li><code>explicit UniqueGenerator::</code><strong><code>UniqueGenerator</code></strong><code>(T&amp; t)</code></li>
<li><code>template &lt;typename RNG&gt; result_type UniqueGenerator::</code><strong><code>operator()</code></strong><code>(RNG&amp; rng)</code></li>
<li><code>void UniqueGenerator::</code><strong><code>clear</code></strong><code>() noexcept</code></li>
<li><code>bool UniqueGenerator::</code><strong><code>empty</code></strong><code>() const noexcept</code></li>
<li><code>result_type UniqueGenerator::</code><strong><code>min</code></strong><code>() const</code></li>
<li><code>result_type UniqueGenerator::</code><strong><code>max</code></strong><code>() const</code></li>
<li><code>size_t UniqueGenerator::</code><strong><code>size</code></strong><code>() const noexcept</code></li>
</ul>
</li>
<li><code>template &lt;typename T&gt; UniqueGenerator&lt;T&gt;</code> <strong><code>unique_distribution</code></strong><code>(T&amp; t)</code></li>
</ul>
<p>This is a wrapper for another random distribution. It keeps an internal cache
of all values generated to date, and will repeatedly call the underlying
distribution until a new value is generated. The <code>clear()</code> function resets the
cache.</p>
<p>The underlying distribution only needs to have a function call operator that
can take a reference to a random number engine, unless the <code>min()</code> or <code>max()</code>
functions are called, which require the corresponding functions on the
underlying distribution.</p>
<p>The <code>UniqueGenerator</code> object contains a reference to the underlying
distribution, which is expected to remain valid. Behaviour is undefined if the
underlying distribution is destroyed while a <code>UniqueGenerator</code> object still
has a reference to it, or if <code>UniqueGenerator::operator()</code> is called when the
cache already contains every possible value of the result type.</p>
</div>
<h3 id="special-distribution-properties">Special distribution properties</h3>
<p>Distributions in this section are designed for use in statistical testing and
do not contain generator functions.</p>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>ChiSquared</code></strong><ul>
<li><code>ChiSquared::</code><strong><code>ChiSquared</code></strong><code>() noexcept</code></li>
<li><code>explicit ChiSquared::</code><strong><code>ChiSquared</code></strong><code>(int k) noexcept</code></li>
<li><code>int ChiSquared::</code><strong><code>k</code></strong><code>() const noexcept</code></li>
<li><code>T ChiSquared::</code><strong><code>mean</code></strong><code>() const noexcept</code></li>
<li><code>T ChiSquared::</code><strong><code>sd</code></strong><code>() const noexcept</code></li>
<li><code>T ChiSquared::</code><strong><code>variance</code></strong><code>() const noexcept</code></li>
<li><code>T ChiSquared::</code><strong><code>pdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T ChiSquared::</code><strong><code>cdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T ChiSquared::</code><strong><code>ccdf</code></strong><code>(T x) const noexcept</code></li>
<li><code>T ChiSquared::</code><strong><code>quantile</code></strong><code>(T p) const noexcept</code></li>
<li><code>T ChiSquared::</code><strong><code>cquantile</code></strong><code>(T q) const noexcept</code></li>
</ul>
</li>
</ul>
<p>Chi-squared distribution. The number of degrees of freedom (<code>k</code>) defaults to
1. Behaviour is undefined if <code>k&lt;1</code>. The cumulative distribution functions use
the Abdel-Aty approximation, except for the special case <code>k=2</code> where a simple
closed form exists. The quantile functions use numerical root finding and can
be expected to be slow (apart from <code>k=2</code> again).</p>
</div>
<h2 id="other-random-algorithms">Other random algorithms</h2>
<div class="defns">
<ul>
<li><code>template &lt;typename RNG&gt; void</code> <strong><code>random_bytes</code></strong><code>(RNG&amp; rng, void* ptr, size_t n)</code></li>
</ul>
<p>Fills a block of memory with random bits generated by the RNG. This will do
nothing if <code>ptr</code> is null or <code>n=0</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename RNG1, typename RNG2&gt; void</code> <strong><code>seed_from</code></strong><code>(RNG1&amp; src, RNG2&amp; dst)</code></li>
</ul>
<p>Seed one standard random engine from another, by constructing an intermediate
<code>seed_seq</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename RNG, typename RandomAccessRange&gt; void</code> <strong><code>shuffle</code></strong><code>(RNG&amp; rng, RandomAccessRange&amp; range)</code></li>
<li><code>template &lt;typename RNG, typename RandomAccessIterator&gt; void</code> <strong><code>shuffle</code></strong><code>(RNG&amp; rng, RandomAccessIterator i, RandomAccessIterator j)</code></li>
</ul>
<p>Shuffle the elements of a random access range into random order. This is
functionally the same as <code>std::shuffle()</code>, duplicated here to provide a
version with reproducible behaviour on all systems.</p>
</div>
<h2 id="text-generators">Text generators</h2>
<div class="defns">
<ul>
<li><code>Ustring</code> <strong><code>lorem_ipsum</code></strong><code>(uint64_t seed, size_t bytes, bool paras = true)</code></li>
</ul>
<p>Generates random <em>Lorem Ipsum</em> text with approximately the specified number of
bytes (the length will be between <code>bytes</code> and <code>bytes+15</code> inclusive). Normally
it will be broken into paragraphs, delimited by two line feeds; if <code>paras</code> is
false, there will be no paragraph breaks, and no trailing LF.</p></body>
</html>
