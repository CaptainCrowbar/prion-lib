<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Core Time and Date Algorithms</title>
<link type="text/css" rel="stylesheet" href="style.css"/>
</head>
<body>
<h1 id="core-time-and-date-algorithms">Core Time and Date Algorithms</h1>
<p>By Ross Smith</p>
<ul>
<li><code>#include "rs-core/time.hpp"</code></li>
</ul>
<p>In this documentation, the <code>std::chrono::</code> prefix on the standard date and
time types is left out for brevity. For all functions here that accept or
return a broken down date, results are unspecified if the date is outside the
range of a <code>time_t</code> (1970-2038 on 32-bit systems), or if the fields are set to
values that do not represent a valid date.</p>
<h2 id="contents">Contents</h2>
<div class="toc">
<ul>
<li><a href="#core-time-and-date-algorithms">Core Time and Date Algorithms</a><ul>
<li><a href="#contents">Contents</a></li>
<li><a href="#time-and-date-types">Time and date types</a></li>
<li><a href="#constants">Constants</a></li>
<li><a href="#general-time-and-date-operations">General time and date operations</a></li>
<li><a href="#time-and-date-formatting">Time and date formatting</a></li>
<li><a href="#time-and-date-parsing">Time and date parsing</a></li>
<li><a href="#timing-utilities">Timing utilities</a></li>
<li><a href="#system-specific-time-and-date-conversions">System specific time and date conversions</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="time-and-date-types">Time and date types</h2>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>Dseconds</code></strong> <code>= duration&lt;double&gt;</code></li>
<li><code>using</code> <strong><code>Ddays</code></strong> <code>= duration&lt;double, ratio&lt;86400&gt;&gt;</code></li>
<li><code>using</code> <strong><code>Dyears</code></strong> <code>= duration&lt;double, ratio&lt;31557600&gt;&gt;</code></li>
</ul>
<p>Floating point duration types.</p>
</div>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>ReliableClock</code></strong> <code>= [high_resolution_clock or steady_clock]</code></li>
</ul>
<p>This is the highest resolution clock that can be trusted to be steady. It will
be <code>high_resolution_clock</code> if <code>high_resolution_clock::is_steady</code> is true,
otherwise <code>steady_clock</code>.</p>
</div>
<h2 id="constants">Constants</h2>
<div class="defns">
<ul>
<li><code>constexpr uint32_t</code> <strong><code>utc_zone</code></strong></li>
<li><code>constexpr uint32_t</code> <strong><code>local_zone</code></strong></li>
</ul>
<p>One of these is passed to some of the time and date functions to indicate
whether a broken down date is expressed in UTC or the local time zone. If none
of these are present, the default is <code>utc_zone</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr uint32_t</code> <strong><code>ymd_order</code></strong></li>
<li><code>constexpr uint32_t</code> <strong><code>dmy_order</code></strong></li>
<li><code>constexpr uint32_t</code> <strong><code>mdy_order</code></strong></li>
</ul>
<p>One of these is passed to the <code>parse_date()</code> function to indicate which order
the date elements are in. If none of these are present, the default is
<code>ymd_order</code>.</p>
</div>
<h2 id="general-time-and-date-operations">General time and date operations</h2>
<div class="defns">
<ul>
<li><code>template &lt;typename C1, typename D1, typename C2, typename D2&gt; void</code> <strong><code>convert_time_point</code></strong><code>(time_point&lt;C1, D1&gt; src, time_point&lt;C2, D2&gt;&amp; dst)</code></li>
<li><code>template &lt;typename TP2, typename C1, typename D1&gt; TP2</code> <strong><code>convert_time_point</code></strong><code>(time_point&lt;C1, D1&gt; src)</code></li>
</ul>
<p>Convert a time point from one representation to another, possibly on a
different clock. This will call <code>time_point_cast()</code> if possible; otherwise, it
will check the current times on both clocks and use that to convert from one
clock to the other.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename R, typename P&gt; void</code> <strong><code>from_seconds</code></strong><code>(double s, duration&lt;R, P&gt;&amp; d) noexcept</code></li>
<li><code>template &lt;typename R, typename P&gt; double</code> <strong><code>to_seconds</code></strong><code>(const duration&lt;R, P&gt;&amp; d) noexcept</code></li>
</ul>
<p>Convenience functions to convert between a <code>duration</code> and a floating point
number of seconds.</p>
</div>
<div class="defns">
<ul>
<li><code>system_clock::time_point</code> <strong><code>make_date</code></strong><code>(int year, int month, int day, int hour = 0, int min = 0, double sec = 0, uint32_t flags = utc_zone)</code></li>
</ul>
<p>Converts a broken down date into a time point. Behaviour if any of the date
arguments are invalid follows the same rules as <code>mktime()</code>. This will throw
<code>std::invalid_argument</code> if an invalid combination of flags is passed.</p>
</div>
<h2 id="time-and-date-formatting">Time and date formatting</h2>
<div class="defns">
<ul>
<li><code>Ustring</code> <strong><code>format_date</code></strong><code>(system_clock::time_point tp, int prec = 0, uint32_t flags = utc_zone)</code></li>
<li><code>Ustring</code> <strong><code>format_date</code></strong><code>(system_clock::time_point tp, Uview format, uint32_t flags = utc_zone)</code></li>
</ul>
<p>These convert a time point into a broken down date and format it. The first
version writes the date in ISO 8601 format (<code>"yyyy-mm-dd hh:mm:ss"</code>). If
<code>prec</code> is greater than zero, the specified number of decimal places will be
added to the seconds field.</p>
<p>The second version writes the date using the conventions of <code>strftime()</code>. This
will return an empty string if anything goes wrong (there is no way to
distinguish between a conversion error and a legitimately empty result; this
is a limitation of <code>strftime()</code>).</p>
<p>Both of these will throw <code>std::invalid_argument</code> if an invalid combination of
flags is passed.</p>
<p>For reference, the portable subset of the <code>strftime()</code> formatting codes are:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Date elements</strong></td>
<td></td>
<td><strong>Weekday elements</strong></td>
<td></td>
</tr>
<tr>
<td><code>%Y</code></td>
<td>Year number</td>
<td><code>%a</code></td>
<td>Local weekday abbreviation</td>
</tr>
<tr>
<td><code>%y</code></td>
<td>Last 2 digits of the year (<code>00-99</code>)</td>
<td><code>%w</code></td>
<td>Sunday-based weekday number (<code>0-6</code>)</td>
</tr>
<tr>
<td><code>%m</code></td>
<td>Month number (<code>00-12</code>)</td>
<td><code>%A</code></td>
<td>Local weekday name</td>
</tr>
<tr>
<td><code>%B</code></td>
<td>Local month name</td>
<td><code>%U</code></td>
<td>Sunday-based week number (<code>00-53</code>)</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>Local month abbreviation</td>
<td><code>%W</code></td>
<td>Monday-based week number (<code>00-53</code>)</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>Day of the month (<code>01-31</code>)</td>
<td><strong>Other elements</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Time of day elements</strong></td>
<td></td>
<td><code>%c</code></td>
<td>Local standard date/time format</td>
</tr>
<tr>
<td><code>%H</code></td>
<td>Hour on 24-hour clock (<code>00-23</code>)</td>
<td><code>%x</code></td>
<td>Local standard date format</td>
</tr>
<tr>
<td><code>%I</code></td>
<td>Hour on 12-hour clock (<code>01-12</code>)</td>
<td><code>%X</code></td>
<td>Local standard time format</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>Local equivalent of a.m./p.m.</td>
<td><code>%j</code></td>
<td>Day of the year (<code>001-366</code>)</td>
</tr>
<tr>
<td><code>%M</code></td>
<td>Minute (<code>00-59</code>)</td>
<td><code>%Z</code></td>
<td>Time zone name</td>
</tr>
<tr>
<td><code>%S</code></td>
<td>Second (<code>00-60</code>)</td>
<td><code>%z</code></td>
<td>Time zone offset</td>
</tr>
</tbody>
</table>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename R, typename P&gt; Ustring</code> <strong><code>format_time</code></strong><code>(const duration&lt;R, P&gt;&amp; time, int prec = 0)</code></li>
</ul>
<p>Formats a time duration in days, hours, minutes, seconds, and (if <code>prec&gt;0</code>)
fractions of a second.</p>
</div>
<h2 id="time-and-date-parsing">Time and date parsing</h2>
<div class="defns">
<ul>
<li><code>system_clock::time_point</code> <strong><code>parse_date</code></strong><code>(Uview str, uint32_t flags = utc_zone | ymd_order)</code></li>
</ul>
<p>Parse a date expressed in broken down format (e.g. <code>"2017-11-04 11:53:00"</code>).
Year, month, and day are required, in the order specified by the <code>flags</code>
argument; the month can be a number, an abbreviation, or a full English name
(case insensitive). Hours, minutes, seconds, and fractions of a second are
optional. Fields can be separated with spaces or any ASCII punctuation marks;
following ISO convention, a <code>"T"</code> can also be used between the date and time.
This function does not make any attempt to interpret a time zone in the
string. It will throw <code>std::invalid_argument</code> if the format is invalid or an
invalid combination of flags is supplied; behaviour is unspecified if the
format is correct but the string does not represent a valid date; behaviour is
undefined if the date is outside the representable range of the system clock.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename R, typename P&gt; void</code> <strong><code>parse_time</code></strong><code>(Uview str, duration&lt;R, P&gt;&amp; t)</code></li>
<li><code>template &lt;typename D&gt; D</code> <strong><code>parse_time</code></strong><code>(Uview str)</code></li>
</ul>
<p>Parse a time expressed in Julian years, days, hours, minutes, and seconds
(e.g. <code>"12y 345d 12h 34m 56s"</code>). Spaces are ignored; a leading sign is
allowed; any number can be a floating point number with decimals and
exponents; units can be abbreviations or full words; years can have any SI
prefix with a positive exponent (e.g. <code>"65 My"</code>); seconds can have any SI
prefix with a negative exponent (e.g. <code>"100 µs"</code>); either <code>"u"</code> or <code>"µ"</code> can
be used for "micro". These will throw <code>std::invalid_argument</code> if the format is
invalid; behaviour is undefined if the format is correct but the resulting
time cannot be represented by the duration type, or if the second version of
<code>parse_time()</code> is called with a return type that is not an instantiation of
<code>std::chrono::duration</code>.</p>
</div>
<h2 id="timing-utilities">Timing utilities</h2>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Backoff</code></strong><ul>
<li><code>Backoff::</code><strong><code>Backoff</code></strong><code>() noexcept</code></li>
<li><code>template &lt;typename R1, typename P1, typename R2, typename P2&gt; Backoff::</code><strong><code>Backoff</code></strong><code>(duration&lt;R1, P1&gt; min_interval, duration&lt;R2, P2&gt; max_interval) noexcept</code></li>
<li><code>Backoff::</code><strong><code>~Backoff</code></strong><code>() noexcept</code></li>
<li><code>Backoff::</code><strong><code>Backoff</code></strong><code>(const Backoff&amp; b) noexcept</code></li>
<li><code>Backoff::</code><strong><code>Backoff</code></strong><code>(Backoff&amp;&amp; b) noexcept</code></li>
<li><code>Backoff&amp; Backoff::</code><strong><code>operator=</code></strong><code>(const Backoff&amp; b) noexcept</code></li>
<li><code>Backoff&amp; Backoff::</code><strong><code>operator=</code></strong><code>(Backoff&amp;&amp; b) noexcept</code></li>
<li><code>[duration type] Backoff::</code><strong><code>min</code></strong><code>() const noexcept</code></li>
<li><code>[duration type] Backoff::</code><strong><code>max</code></strong><code>() const noexcept</code></li>
<li><code>template &lt;typename Predicate&gt; void Backoff::</code><strong><code>wait</code></strong><code>(Predicate pred) const</code></li>
<li><code>template &lt;typename Predicate, typename R, typename P&gt; bool Backoff::</code><strong><code>wait_for</code></strong><code>(Predicate pred, duration&lt;R, P&gt; timeout) const</code></li>
<li><code>template &lt;typename Predicate, typename C, typename D&gt; bool Backoff::</code><strong><code>wait_until</code></strong><code>(Predicate pred, time_point&lt;C, D&gt; timeout) const</code></li>
</ul>
</li>
</ul>
<p>This implements a backoff wait algorithm. The constructor takes a minimum and
maximum poll interval, defaulting to 10 microseconds and 10 milliseconds
respectively. The <code>min()</code> and <code>max()</code> query functions return the intervals
expressed in an unspecified duration type (the same type for both functions).
When one of the wait functions is called, after testing the predicate, it will
wait for the minimum interval before testing again, doubling the interval
after each test until the maximum interval is reached, after which it will
continue testing at that interval. The <code>wait()</code> function will return when the
predicate is true; the other wait functions will return true when the
predicate is true, or false when the timeout expires, whichever comes first.
All of the wait functions will propagate any exceptions thrown by the
predicate.</p>
</div>
<div class="defns">
<ul>
<li><code>class</code> <strong><code>Stopwatch</code></strong><ul>
<li><code>explicit Stopwatch::</code><strong><code>Stopwatch</code></strong><code>(Uview name, int precision = 3) noexcept</code></li>
<li><code>Stopwatch::</code><strong><code>~Stopwatch</code></strong><code>() noexcept</code></li>
</ul>
</li>
</ul>
<p>This is a simple timer specialized for debugging. The destructor will write
(using <code>logx()</code>) the name and the elapsed time since construction.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename D&gt; class</code> <strong><code>Timer</code></strong><ul>
<li><code>using Timer::</code><strong><code>duration</code></strong> <code>= D</code></li>
<li><code>Timer::</code><strong><code>Timer</code></strong><code>()</code></li>
<li><code>Timer::</code><strong><code>~Timer</code></strong><code>() noexcept</code></li>
<li><code>Timer::</code><strong><code>operator duration</code></strong><code>() const</code></li>
<li><code>duration Timer::</code><strong><code>get</code></strong><code>() const</code></li>
<li><code>void Timer::</code><strong><code>reset</code></strong><code>()</code></li>
</ul>
</li>
</ul>
<p>Another simple timer (not specialized for debugging). The template argument
must be an instantiation of <code>std::chrono::duration</code>. The timer is started on
construction, and restarted when <code>reset()</code> is called; <code>get()</code> or the
conversion operator return the time since the last start.</p>
</div>
<h2 id="system-specific-time-and-date-conversions">System specific time and date conversions</h2>
<div class="defns">
<ul>
<li><em>Unix</em><ul>
<li><code>template &lt;typename R, typename P&gt; timespec</code> <strong><code>duration_to_timespec</code></strong><code>(const duration&lt;R, P&gt;&amp; d) noexcept</code></li>
<li><code>template &lt;typename R, typename P&gt; timeval</code> <strong><code>duration_to_timeval</code></strong><code>(const duration&lt;R, P&gt;&amp; d) noexcept</code></li>
<li><code>timespec</code> <strong><code>timepoint_to_timespec</code></strong><code>(const system_clock::time_point&amp; tp) noexcept</code></li>
<li><code>timeval</code> <strong><code>timepoint_to_timeval</code></strong><code>(const system_clock::time_point&amp; tp) noexcept</code></li>
<li><code>template &lt;typename R, typename P&gt; void</code> <strong><code>timespec_to_duration</code></strong><code>(const timespec&amp; ts, duration&lt;R, P&gt;&amp; d) noexcept</code></li>
<li><code>system_clock::time_point</code> <strong><code>timespec_to_timepoint</code></strong><code>(const timespec&amp; ts) noexcept</code></li>
<li><code>template &lt;typename R, typename P&gt; void</code> <strong><code>timeval_to_duration</code></strong><code>(const timeval&amp; tv, duration&lt;R, P&gt;&amp; d) noexcept</code></li>
<li><code>system_clock::time_point</code> <strong><code>timeval_to_timepoint</code></strong><code>(const timeval&amp; tv) noexcept</code></li>
</ul>
</li>
<li><em>Windows</em><ul>
<li><code>system_clock::time_point</code> <strong><code>filetime_to_timepoint</code></strong><code>(const FILETIME&amp; ft) noexcept</code></li>
<li><code>FILETIME</code> <strong><code>timepoint_to_filetime</code></strong><code>(const system_clock::time_point&amp; tp) noexcept</code></li>
</ul>
</li>
</ul>
<p>Conversion functions between C++ chrono types and system API types. Some of
these return their result through a reference argument to avoid having to
explicitly specify the duration type. Behaviour is undefined if the value
being represented is out of range for either the source or destination type.</p>
<p>The Windows functions are only defined on Win32 builds; the Unix functions are
always defined (since the relevant time structures are defined in the Windows
API).</p>
<p>For reference, the system time types are:</p>
<ul>
<li><em>Unix</em><ul>
<li><code>#include &lt;time.h&gt;</code><ul>
<li><code>struct</code> <strong><code>timespec</code></strong><ul>
<li><code>time_t timespec::</code><strong><code>tv_sec</code></strong> <code>// seconds</code></li>
<li><code>long timespec::</code><strong><code>tv_nsec</code></strong> <code>// nanoseconds</code></li>
</ul>
</li>
</ul>
</li>
<li><code>#include &lt;sys/time.h&gt;</code><ul>
<li><code>struct</code> <strong><code>timeval</code></strong><ul>
<li><code>time_t timeval::</code><strong><code>tv_sec</code></strong> <code>// seconds</code></li>
<li><code>suseconds_t timeval::</code><strong><code>tv_usec</code></strong> <code>// microseconds</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><em>Windows</em><ul>
<li><code>#include &lt;windows.h&gt;</code><ul>
<li><code>struct</code> <strong><code>FILETIME</code></strong><ul>
<li><code>DWORD FILETIME::</code><strong><code>dwLowDateTime</code></strong> <code>// low 32 bits</code></li>
<li><code>DWORD FILETIME::</code><strong><code>dwHighDateTime</code></strong> <code>// high 32 bits</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul></body>
</html>
