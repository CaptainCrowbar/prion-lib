<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Vectors, Matrices, and Quaternnions</title>
<link type="text/css" rel="stylesheet" href="style.css"/>
</head>
<body>
<h1 id="vectors-matrices-and-quaternnions">Vectors, Matrices, and Quaternnions</h1>
<p>By Ross Smith</p>
<ul>
<li><code>#include "rs-core/vector.hpp"</code></li>
</ul>
<h2 id="contents">Contents</h2>
<div class="toc">
<ul>
<li><a href="#vectors-matrices-and-quaternnions">Vectors, Matrices, and Quaternnions</a><ul>
<li><a href="#contents">Contents</a></li>
<li><a href="#vector">Vector</a></li>
<li><a href="#matrix">Matrix</a></li>
<li><a href="#quaternion">Quaternion</a></li>
<li><a href="#transformations">Transformations</a><ul>
<li><a href="#coordinate-transformations">Coordinate transformations</a></li>
<li><a href="#projective-geometry">Projective geometry</a></li>
<li><a href="#primitive-transformations">Primitive transformations</a></li>
<li><a href="#quaternion-transformations">Quaternion transformations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="vector">Vector</h2>
<div class="defns">
<ul>
<li><code>template &lt;typename T, size_t N&gt; class</code> <strong><code>Vector</code></strong></li>
</ul>
<p>An <code>N</code>-dimensional vector type. <code>T</code> must be an arithmetic type; <code>N</code> must be a
positive integer.</p>
</div>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>Int[1-4]</code></strong> <code>= Vector&lt;int, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Int8_[1-4]</code></strong> <code>= Vector&lt;int8_t, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Int16_[1-4]</code></strong> <code>= Vector&lt;int16_t, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Int32_[1-4]</code></strong> <code>= Vector&lt;int32_t, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Int64_[1-4]</code></strong> <code>= Vector&lt;int64_t, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Uint8_[1-4]</code></strong> <code>= Vector&lt;uint8_t, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Uint16_[1-4]</code></strong> <code>= Vector&lt;uint16_t, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Uint32_[1-4]</code></strong> <code>= Vector&lt;uint32_t, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Uint64_[1-4]</code></strong> <code>= Vector&lt;uint64_t, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Ptrdiff[1-4]</code></strong> <code>= Vector&lt;ptrdiff_t, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Size[1-4]</code></strong> <code>= Vector&lt;size_t, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Float[1-4]</code></strong> <code>= Vector&lt;float, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Double[1-4]</code></strong> <code>= Vector&lt;double, [1-4]&gt;</code></li>
<li><code>using</code> <strong><code>Ldouble[1-4]</code></strong> <code>= Vector&lt;long double, [1-4]&gt;</code></li>
</ul>
<p>Named instantiations (the shorthand used here indicates instantiations for 1
to 4 dimensions).</p>
</div>
<div class="defns">
<ul>
<li><code>using Vector::</code><strong><code>value_type</code></strong> <code>= T</code></li>
</ul>
<p>Member types.</p>
</div>
<div class="defns">
<ul>
<li><code>static constexpr size_t Vector::</code><strong><code>dim</code></strong> <code>= N</code></li>
</ul>
<p>Member constants.</p>
</div>
<div class="defns">
<ul>
<li><code>Vector::</code><strong><code>Vector</code></strong><code>() noexcept</code></li>
<li><code>template &lt;typename T2&gt; explicit Vector::</code><strong><code>Vector</code></strong><code>(T2 t) noexcept</code></li>
<li><code>template &lt;typename... Args&gt; Vector::</code><strong><code>Vector</code></strong><code>(Args... args) noexcept</code></li>
<li><code>template &lt;typename T2&gt; explicit Vector::</code><strong><code>Vector</code></strong><code>(const T2* ptr) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Vector::</code><strong><code>Vector</code></strong><code>(const Vector&lt;T2, N&gt;&amp; v) noexcept</code></li>
<li><code>Vector::</code><strong><code>~Vector</code></strong><code>() noexcept</code></li>
<li><code>Vector::</code><strong><code>Vector</code></strong><code>(const Vector&amp; v) noexcept</code></li>
<li><code>Vector::</code><strong><code>Vector</code></strong><code>(Vector&amp;&amp; v) noexcept</code></li>
<li><code>Vector&amp; Vector::</code><strong><code>operator=</code></strong><code>(const Vector&amp; v) noexcept</code></li>
<li><code>Vector&amp; Vector::</code><strong><code>operator=</code></strong><code>(Vector&amp;&amp; v) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Vector&amp; Vector::</code><strong><code>operator=</code></strong><code>(const Vector&lt;T2, N&gt;&amp; v) noexcept</code></li>
</ul>
<p>Life cycle functions. The default constructor sets all elements to zero (the
same value as the static <code>zero()</code> function); the second constructor sets all
elements to the given value; the third takes an explicit list of elements; the
fourth copies <code>N</code> elements starting from the source pointer (behaviour is
undefined if the pointer is null); the fifth copies the elements of the
argument vector. The constructors that take a different type depend on the
existence of an implicit conversion from <code>T2</code> to <code>T</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>T&amp; Vector::</code><strong><code>operator[]</code></strong><code>(size_t i) noexcept</code></li>
<li><code>const T&amp; Vector::</code><strong><code>operator[]</code></strong><code>(size_t i) const noexcept</code></li>
<li><code>T&amp; Vector::</code><strong><code>at</code></strong><code>(size_t i)</code></li>
<li><code>const T&amp; Vector::</code><strong><code>at</code></strong><code>(size_t i) const</code></li>
<li><code>T&amp; Vector::</code><strong><code>x</code></strong><code>() noexcept</code></li>
<li><code>const T&amp; Vector::</code><strong><code>x</code></strong><code>() const noexcept</code></li>
<li><code>T&amp; Vector::</code><strong><code>y</code></strong><code>() noexcept</code></li>
<li><code>const T&amp; Vector::</code><strong><code>y</code></strong><code>() const noexcept</code></li>
<li><code>T&amp; Vector::</code><strong><code>z</code></strong><code>() noexcept</code></li>
<li><code>const T&amp; Vector::</code><strong><code>z</code></strong><code>() const noexcept</code></li>
<li><code>T&amp; Vector::</code><strong><code>w</code></strong><code>() noexcept</code></li>
<li><code>const T&amp; Vector::</code><strong><code>w</code></strong><code>() const noexcept</code></li>
<li><code>T* Vector::</code><strong><code>begin</code></strong><code>() noexcept</code></li>
<li><code>const T* Vector::</code><strong><code>begin</code></strong><code>() const noexcept</code></li>
<li><code>T* Vector::</code><strong><code>end</code></strong><code>() noexcept</code></li>
<li><code>const T* Vector::</code><strong><code>end</code></strong><code>() const noexcept</code></li>
</ul>
<p>Data access functions. If the index is out of range, behaviour is undefined
for <code>operator[]</code>; <code>at()</code> throws <code>std::out_of_range</code>. The <code>x()</code>, <code>y()</code>, <code>z()</code>,
and <code>w()</code> methods yield the first four elements. Behaviour is undefined if
<code>y()</code>, <code>z()</code>, or <code>w()</code> is called on a vector with too few elements.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;size_t N2&gt; Vector&lt;T, N2 - 1&gt; Vector::</code><strong><code>operator[]</code></strong><code>(const char (&amp;str)[N2]) const</code></li>
</ul>
<p>Swizzle operator. This returns a vector made from the components of the
original vector indicated by letters in the string literal argument; for
example, <code>v["zyx"]</code> will return <code>{v.z(),v.y(),v.x()}</code>. Behaviour is undefined
if the string contains any characters other than <code>'x'</code>, <code>'y'</code>, <code>'z'</code>, or
<code>'w'</code>, or refers to nonexistent components if the original vector had less
than four components. The output vector has the same number of components as
there are letters in the string (the length is <code>N-1</code> to remove the implicit
null terminator).</p>
</div>
<div class="defns">
<ul>
<li><code>Vector Vector::</code><strong><code>operator+</code></strong><code>() const noexcept</code></li>
<li><code>Vector Vector::</code><strong><code>operator-</code></strong><code>() const noexcept</code></li>
</ul>
<p>Unary arithmetic operators.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T1, typename T2&gt; Vector&lt;T1, 3&gt;</code> <strong><code>operator^</code></strong><code>(const Vector&lt;T1, 3&gt;&amp; lhs, const Vector&lt;T2, 3&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; T1</code> <strong><code>operator%</code></strong><code>(const Vector&lt;T1, N&gt;&amp; lhs, const Vector&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
</ul>
<p>Vector cross (<code>^</code>) and dot (<code>%</code>) product operators. Multiplication between
<code>T1</code> and <code>T2</code> must be defined.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T2&gt; Vector&amp; Vector::</code><strong><code>operator+=</code></strong><code>(const Vector&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Vector&amp; Vector::</code><strong><code>operator-=</code></strong><code>(const Vector&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Vector&amp; Vector::</code><strong><code>operator*=</code></strong><code>(const Vector&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Vector&amp; Vector::</code><strong><code>operator/=</code></strong><code>(const Vector&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Vector&lt;T1, N&gt;</code> <strong><code>operator+</code></strong><code>(const Vector&lt;T1, N&gt;&amp; lhs, const Vector&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Vector&lt;T1, N&gt;</code> <strong><code>operator-</code></strong><code>(const Vector&lt;T1, N&gt;&amp; lhs, const Vector&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Vector&lt;T1, N&gt;</code> <strong><code>operator*</code></strong><code>(const Vector&lt;T1, N&gt;&amp; lhs, const Vector&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Vector&lt;T1, N&gt;</code> <strong><code>operator/</code></strong><code>(const Vector&lt;T1, N&gt;&amp; lhs, const Vector&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
</ul>
<p>Element-wise arithmetic operators. In each case the corresponding operation
between <code>T1</code> and <code>T2</code> must be defined. Behaviour is undefined on division by
zero.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T2&gt; Vector&amp; Vector::</code><strong><code>operator*=</code></strong><code>(T2 rhs) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Vector&amp; Vector::</code><strong><code>operator/=</code></strong><code>(T2 rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Vector&lt;T1, N&gt;</code> <strong><code>operator*</code></strong><code>(const Vector&lt;T1, N&gt;&amp; lhs, T2 rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Vector&lt;T2, N&gt;</code> <strong><code>operator*</code></strong><code>(T1 lhs, const Vector&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Vector&lt;T1, N&gt;</code> <strong><code>operator/</code></strong><code>(const Vector&lt;T1, N&gt;&amp; lhs, T2 rhs) noexcept</code></li>
</ul>
<p>Vector-scalar arithmetic operators. In each case the corresponding operation
between <code>T1</code> and <code>T2</code> must be defined. Behaviour is undefined on division by
zero.</p>
</div>
<div class="defns">
<ul>
<li><code>T Vector::</code><strong><code>angle</code></strong><code>(const Vector&amp; v) const noexcept</code></li>
</ul>
<p>Returns the angle between two vectors (in the range <em>[0,&pi;]</em>). This will
return zero if either vector is null. Requires <code>T</code> to be a floating point
type.</p>
</div>
<div class="defns">
<ul>
<li><code>Vector Vector::</code><strong><code>dir</code></strong><code>() const noexcept</code></li>
</ul>
<p>Returns a unit vector parallel to this vector (or an approximation to it,
given the limits of floating point arithmetic). This requires <code>T</code> to be a
floating point type.</p>
</div>
<div class="defns">
<ul>
<li><code>bool Vector::</code><strong><code>is_null</code></strong><code>() const noexcept</code></li>
</ul>
<p>True if the vector is null.</p>
</div>
<div class="defns">
<ul>
<li><code>Vector Vector::</code><strong><code>project</code></strong><code>(const Vector&amp; v) const noexcept</code></li>
<li><code>Vector Vector::</code><strong><code>reject</code></strong><code>(const Vector&amp; v) const noexcept</code></li>
</ul>
<p>These return the projection and rejection of <code>*this</code> onto <code>v</code> (the components
of <code>*this</code> parallel and orthogonal to <code>v</code>). If <code>v</code> is null, <code>project()</code>
returns null and <code>reject()</code> returns <code>*this</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>T Vector::</code><strong><code>r</code></strong><code>() const noexcept</code></li>
<li><code>T Vector::</code><strong><code>r2</code></strong><code>() const noexcept</code></li>
</ul>
<p>These return the length of the vector, or its square. The <code>r()</code> function
requires <code>T</code> to be a floating point type.</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr size_t Vector::</code><strong><code>size</code></strong><code>() const noexcept</code></li>
</ul>
<p>Returns <code>N</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>static Vector Vector::</code><strong><code>unit</code></strong><code>(size_t i) noexcept</code></li>
</ul>
<p>Returns a unit vector along the given axis. Behaviour is undefined if the
index is out of range.</p>
</div>
<div class="defns">
<ul>
<li><code>static Vector Vector::</code><strong><code>zero</code></strong><code>() noexcept</code></li>
</ul>
<p>Returns the zero vector (the same value as the default constructor).</p>
</div>
<div class="defns">
<ul>
<li><code>bool</code> <strong><code>operator==</code></strong><code>(const Vector&amp; lhs, const Vector&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator!=</code></strong><code>(const Vector&amp; lhs, const Vector&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&lt;</code></strong><code>(const Vector&amp; lhs, const Vector&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&gt;</code></strong><code>(const Vector&amp; lhs, const Vector&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&lt;=</code></strong><code>(const Vector&amp; lhs, const Vector&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator&gt;=</code></strong><code>(const Vector&amp; lhs, const Vector&amp; rhs) noexcept</code></li>
</ul>
<p>Comparison operators. These perform simple lexicographical comparison on the
vector elements.</p>
</div>
<div class="defns">
<ul>
<li><code>std::ostream&amp;</code> <strong><code>operator&lt;&lt;</code></strong><code>(std::ostream&amp; out, const Vector&amp; v)</code></li>
<li><code>Ustring</code> <strong><code>to_str</code></strong><code>(const Vector&amp; v)</code></li>
</ul>
<p>Simple string formatting; this simply writes the vector's elements in their
default format, enclosed in square brackets.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, size_t N&gt; struct std::</code><strong><code>hash</code></strong><code>&lt;Vector&lt;T, N&gt;&gt;</code></li>
</ul>
<p>Hash function.</p>
</div>
<h2 id="matrix">Matrix</h2>
<div class="defns">
<ul>
<li><code>enum class</code> <strong><code>MatrixLayout</code></strong><ul>
<li><strong><code>column</code></strong> <code>= 'C'</code></li>
<li><strong><code>row</code></strong> <code>= 'R'</code></li>
</ul>
</li>
</ul>
<p>Flags indicating the internal layout of a matrix.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, size_t N, MatrixLayout L = MatrixLayout::column&gt; class</code> <strong><code>Matrix</code></strong></li>
</ul>
<p>An <code>N</code>&times;<code>N</code> square matrix type. <code>T</code> must be an arithmetic type; <code>N</code> must
be a positive integer; <code>L</code> must be one of the <code>MatrixLayout</code> enumeration.</p>
<p>For simplicity of presentation, most of the matrix operations described below
are documented as though there were only two matrix parameters, the element
type and the size; the layout is left out to avoid complicating the
documentation with too many multiple overloads. Except where the documentation
explicitly says otherwise, all matrix operations work the same for both
layouts. Operations that take two matrices will work on pairs of different
layout. When a dissimilar pair is passed to an operation that returns another
matrix (e.g. adding or multiplying a column matrix with a row matrix), the
returned matrix has the same layout as the first argument.</p>
</div>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>Float[2-4]x[2-4]</code></strong> <code>= Matrix&lt;float, [2-4]&gt;</code></li>
<li><code>using</code> <strong><code>Float[2-4]x[2-4]c</code></strong> <code>= Matrix&lt;float, [2-4], MatrixLayout::column&gt;</code></li>
<li><code>using</code> <strong><code>Float[2-4]x[2-4]r</code></strong> <code>= Matrix&lt;float, [2-4], MatrixLayout::row&gt;</code></li>
<li><code>using</code> <strong><code>Double[2-4]x[2-4]</code></strong> <code>= Matrix&lt;double, [2-4]&gt;</code></li>
<li><code>using</code> <strong><code>Double[2-4]x[2-4]c</code></strong> <code>= Matrix&lt;double, [2-4], MatrixLayout::column&gt;</code></li>
<li><code>using</code> <strong><code>Double[2-4]x[2-4]r</code></strong> <code>= Matrix&lt;double, [2-4], MatrixLayout::row&gt;</code></li>
<li><code>using</code> <strong><code>Ldouble[2-4]x[2-4]</code></strong> <code>= Matrix&lt;long double, [2-4]&gt;</code></li>
<li><code>using</code> <strong><code>Ldouble[2-4]x[2-4]c</code></strong> <code>= Matrix&lt;long double, [2-4], MatrixLayout::column&gt;</code></li>
<li><code>using</code> <strong><code>Ldouble[2-4]x[2-4]r</code></strong> <code>= Matrix&lt;long double, [2-4], MatrixLayout::row&gt;</code></li>
</ul>
<p>Named instantiations.</p>
</div>
<div class="defns">
<ul>
<li><code>using Matrix::</code><strong><code>value_type</code></strong> <code>= T</code></li>
<li><code>using Matrix::</code><strong><code>vector_type</code></strong> <code>= Vector&lt;T, N&gt;</code></li>
</ul>
<p>Member types.</p>
</div>
<div class="defns">
<ul>
<li><code>static constexpr size_t Matrix::</code><strong><code>dim</code></strong> <code>= N</code></li>
<li><code>static constexpr size_t Matrix::</code><strong><code>cells</code></strong> <code>= N * N</code></li>
<li><code>static constexpr MatrixLayout Matrix::</code><strong><code>layout</code></strong> <code>= L</code></li>
</ul>
<p>Member constants.</p>
</div>
<div class="defns">
<ul>
<li><code>Matrix::</code><strong><code>Matrix</code></strong><code>() noexcept</code></li>
<li><code>template &lt;typename T2&gt; explicit Matrix::</code><strong><code>Matrix</code></strong><code>(T2 t) noexcept</code></li>
<li><code>template &lt;typename T2, typename T3&gt; Matrix::</code><strong><code>Matrix</code></strong><code>(T2 lead, T3 other) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Matrix::</code><strong><code>Matrix</code></strong><code>(std::initializer_list&lt;T2&gt; ts) noexcept</code></li>
<li><code>Matrix::</code><strong><code>Matrix</code></strong><code>(const Matrix&amp; m) noexcept</code></li>
<li><code>Matrix::</code><strong><code>Matrix</code></strong><code>(Matrix&amp;&amp; m) noexcept</code></li>
<li><code>Matrix::</code><strong><code>~Matrix</code></strong><code>() noexcept</code></li>
<li><code>Matrix&amp; Matrix::</code><strong><code>operator=</code></strong><code>(const Matrix&amp; m) noexcept</code></li>
<li><code>Matrix&amp; Matrix::</code><strong><code>operator=</code></strong><code>(Matrix&amp;&amp; m) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Matrix&amp; Matrix::</code><strong><code>operator=</code></strong><code>(std::initializer_list&lt;T2&gt; ts) noexcept</code></li>
</ul>
<p>Life cycle functions. The default constructor sets all elements to zero (the
same result as the static <code>zero()</code> function); the second constructor sets all
elements to the given value (performing implicit conversion if necessary); the
third constructor sets the leading diagonal to one value and the remaining
elements to another; the fourth takes an explicit list of elements.</p>
<p>The constructors and assignment operators that take a list of elements will
assign elements in the order implied by the matrix's layout flag. If an
initializer list contains too few elements, the missing elements will be set
to zero; if it contains too many, the excess elements are ignored.</p>
<p>A matrix can be constructed or assigned from one of the opposite layout.</p>
</div>
<div class="defns">
<ul>
<li><code>T&amp; Matrix::</code><strong><code>operator()</code></strong><code>(size_t r, size_t c) noexcept</code></li>
<li><code>T Matrix::</code><strong><code>operator()</code></strong><code>(size_t r, size_t c) const noexcept</code></li>
<li><code>T&amp; Matrix::</code><strong><code>at</code></strong><code>(size_t r, size_t c)</code></li>
<li><code>T Matrix::</code><strong><code>at</code></strong><code>(size_t r, size_t c) const</code></li>
<li><code>T* Matrix::</code><strong><code>begin</code></strong><code>() noexcept</code></li>
<li><code>const T* Matrix::</code><strong><code>begin</code></strong><code>() const noexcept</code></li>
<li><code>T* Matrix::</code><strong><code>end</code></strong><code>() noexcept</code></li>
<li><code>const T* Matrix::</code><strong><code>end</code></strong><code>() const noexcept</code></li>
</ul>
<p>Element reference functions. If the row or column is out of range, behaviour
is undefined for <code>operator()</code>; <code>at()</code> throws <code>std::out_of_range</code>. Iterating
over the elements will visit them in the order implied by the matrix's layout
flag.</p>
</div>
<div class="defns">
<ul>
<li><code>Matrix Matrix::</code><strong><code>operator+</code></strong><code>() const noexcept</code></li>
<li><code>Matrix Matrix::</code><strong><code>operator-</code></strong><code>() const noexcept</code></li>
</ul>
<p>Unary arithmetic operators.</p>
</div>
<div class="defns">
<ul>
<li><code>Matrix&amp; Matrix::</code><strong><code>operator+=</code></strong><code>(const Matrix&amp; rhs) noexcept</code></li>
<li><code>Matrix&amp; Matrix::</code><strong><code>operator-=</code></strong><code>(const Matrix&amp; rhs) noexcept</code></li>
<li><code>Matrix</code> <strong><code>operator+</code></strong><code>(const Matrix&amp; lhs, const Matrix&amp; rhs) noexcept</code></li>
<li><code>Matrix</code> <strong><code>operator-</code></strong><code>(const Matrix&amp; lhs, const Matrix&amp; rhs) noexcept</code></li>
<li><code>Matrix</code> <strong><code>operator*</code></strong><code>(const Matrix&amp; lhs, const Matrix&amp; rhs) noexcept</code></li>
</ul>
<p>Matrix arithmetic operators. No <code>operator*=</code> is provided because matrices are
normally pre-multiplied.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Vector&lt;T2, N&gt;</code> <strong><code>operator*</code></strong><code>(const Matrix&lt;T1, N&gt;&amp; lhs, const Vector&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Vector&lt;T1, N&gt;</code> <strong><code>operator*</code></strong><code>(const Vector&lt;T1, N&gt;&amp; lhs, const Matrix&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
</ul>
<p>Matrix-vector arithmetic operators.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T2&gt; Matrix&amp; Matrix::</code><strong><code>operator*=</code></strong><code>(T2 rhs) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Matrix&amp; Matrix::</code><strong><code>operator/=</code></strong><code>(T2 rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Matrix&lt;T1, N&gt;</code> <strong><code>operator*</code></strong><code>(const Matrix&lt;T1, N&gt;&amp; lhs, T2 rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Matrix&lt;T2, N&gt;</code> <strong><code>operator*</code></strong><code>(T1 lhs, const Matrix&lt;T2, N&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2, size_t N&gt; Matrix&lt;T1, N&gt;</code> <strong><code>operator/</code></strong><code>(const Matrix&lt;T1, N&gt;&amp; lhs, T2 rhs) noexcept</code></li>
</ul>
<p>Matrix-scalar arithmetic operators.</p>
</div>
<div class="defns">
<ul>
<li><code>vector_type Matrix::</code><strong><code>column</code></strong><code>(size_t c) const noexcept</code></li>
<li><code>vector_type Matrix::</code><strong><code>row</code></strong><code>(size_t r) const noexcept</code></li>
</ul>
<p>Return the selected column or row as a vector. Behaviour is undefined if the
index is out of bounds.</p>
</div>
<div class="defns">
<ul>
<li><code>T Matrix::</code><strong><code>det</code></strong><code>() const noexcept</code></li>
</ul>
<p>Returns the determinant of the matrix. This is currently only implemented for
<code>N&lt;=4</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>Matrix Matrix::</code><strong><code>inverse</code></strong><code>() const noexcept</code></li>
</ul>
<p>Calculate the inverse of a matrix. This requires <code>T</code> to be a floating point
type. Behaviour is undefined if the matrix is singular. This is currently only
implemented for <code>N&lt;=4</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>constexpr size_t Matrix::</code><strong><code>size</code></strong><code>() const noexcept</code></li>
</ul>
<p>Returns <code>N*N</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>Matrix Matrix::</code><strong><code>swap_columns</code></strong><code>(size_t c1, size_t c2) const noexcept</code></li>
<li><code>Matrix Matrix::</code><strong><code>swap_rows</code></strong><code>(size_t r1, size_t r2) const noexcept</code></li>
</ul>
<p>Returns a matrix with two columns or rows swapped. A copy of the original
matrix is returned if the two arguments are the same. Behaviour is undefined
if either index is out of range.</p>
</div>
<div class="defns">
<ul>
<li><code>Matrix Matrix::</code><strong><code>transpose</code></strong><code>() const noexcept</code></li>
</ul>
<p>Calculate the transpose of a matrix.</p>
</div>
<div class="defns">
<ul>
<li><code>static Matrix Matrix::</code><strong><code>from_array</code></strong><code>(const T* ptr) noexcept</code></li>
</ul>
<p>Builds a matrix by copying elements from the array supplied. Cells are filled
in the order implied by the matrix layout. Behaviour is undefined if the
pointer is null or the array does not have enough elements to fill the matrix.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename... Args&gt; static Matrix Matrix::</code><strong><code>from_columns</code></strong><code>(Args... args) noexcept</code></li>
<li><code>template &lt;typename... Args&gt; static Matrix Matrix::</code><strong><code>from_rows</code></strong><code>(Args... args) noexcept</code></li>
</ul>
<p>Builds a matrix from an explicitly supplied list of elements. These are
similar to the initializer list constructor, except that the elements are
filled in column or row order regardless of the matrix layout. The same rules
are followed if the length of the argument list does not match the size of the
matrix.</p>
</div>
<div class="defns">
<ul>
<li><code>static Matrix Matrix::</code><strong><code>identity</code></strong><code>() noexcept</code></li>
<li><code>static Matrix Matrix::</code><strong><code>zero</code></strong><code>() noexcept</code></li>
</ul>
<p>Return the identity or zero matrix.</p>
</div>
<div class="defns">
<ul>
<li><code>bool</code> <strong><code>operator==</code></strong><code>(const Matrix&amp; lhs, const Matrix&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator!=</code></strong><code>(const Matrix&amp; lhs, const Matrix&amp; rhs) noexcept</code></li>
</ul>
<p>Comparison operators.</p>
</div>
<div class="defns">
<ul>
<li><code>std::ostream&amp;</code> <strong><code>operator&lt;&lt;</code></strong><code>(std::ostream&amp; out, const Matrix&amp; m)</code></li>
<li><code>Ustring</code> <strong><code>to_str</code></strong><code>(const Matrix&amp; m)</code></li>
</ul>
<p>Simple string formatting; this writes the matrix by row in nested array form.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, size_t N, RS::MatrixLayout L&gt; struct std::</code><strong><code>hash</code></strong><code>&lt;Matrix&lt;T, N, L&gt;&gt;</code></li>
</ul>
<p>Hash function.</p>
</div>
<h2 id="quaternion">Quaternion</h2>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; class</code> <strong><code>Quaternion</code></strong></li>
</ul>
<p>A quaternion type based on the scalar type <code>T</code>, which must be a floating point
arithmetic type.</p>
</div>
<div class="defns">
<ul>
<li><code>using</code> <strong><code>Qfloat</code></strong> <code>= Quaternion&lt;float&gt;</code></li>
<li><code>using</code> <strong><code>Qdouble</code></strong> <code>= Quaternion&lt;double&gt;</code></li>
<li><code>using</code> <strong><code>Qldouble</code></strong> <code>= Quaternion&lt;long double&gt;</code></li>
</ul>
<p>Named instantiations.</p>
</div>
<div class="defns">
<ul>
<li><code>using Quaternion::</code><strong><code>value_type</code></strong> <code>= T</code></li>
</ul>
<p>Member types.</p>
</div>
<div class="defns">
<ul>
<li><code>Quaternion::</code><strong><code>Quaternion</code></strong><code>() noexcept</code></li>
<li><code>Quaternion::</code><strong><code>Quaternion</code></strong><code>(T a) noexcept</code></li>
<li><code>Quaternion::</code><strong><code>Quaternion</code></strong><code>(T a, T b, T c, T d) noexcept</code></li>
<li><code>Quaternion::</code><strong><code>Quaternion</code></strong><code>(T a, const Vector&lt;T, 3&gt;&amp; bcd) noexcept</code></li>
<li><code>Quaternion::</code><strong><code>Quaternion</code></strong><code>(const Quaternion&amp; q) noexcept</code></li>
<li><code>Quaternion::</code><strong><code>Quaternion</code></strong><code>(Quaternion&amp;&amp; q) noexcept</code></li>
<li><code>Quaternion::</code><strong><code>~Quaternion</code></strong><code>() noexcept</code></li>
<li><code>Quaternion&amp; Quaternion::</code><strong><code>operator=</code></strong><code>(const Quaternion&amp; q) noexcept</code></li>
<li><code>Quaternion&amp; Quaternion::</code><strong><code>operator=</code></strong><code>(Quaternion&amp;&amp; q) noexcept</code></li>
</ul>
<p>Life cycle functions. The default constructor sets all components to zero; the
second constructor creates a scalar quaternion; the third and fourth
constructors assemble a quaternion from four components supplied explicitly or
as scalar and vector parts.</p>
</div>
<div class="defns">
<ul>
<li><code>T&amp; Quaternion::</code><strong><code>a</code></strong><code>() noexcept</code></li>
<li><code>const T&amp; Quaternion::</code><strong><code>a</code></strong><code>() const noexcept</code></li>
<li><code>T&amp; Quaternion::</code><strong><code>b</code></strong><code>() noexcept</code></li>
<li><code>const T&amp; Quaternion::</code><strong><code>b</code></strong><code>() const noexcept</code></li>
<li><code>T&amp; Quaternion::</code><strong><code>c</code></strong><code>() noexcept</code></li>
<li><code>const T&amp; Quaternion::</code><strong><code>c</code></strong><code>() const noexcept</code></li>
<li><code>T&amp; Quaternion::</code><strong><code>d</code></strong><code>() noexcept</code></li>
<li><code>const T&amp; Quaternion::</code><strong><code>d</code></strong><code>() const noexcept</code></li>
<li><code>T* Quaternion::</code><strong><code>begin</code></strong><code>() noexcept</code></li>
<li><code>const T* Quaternion::</code><strong><code>begin</code></strong><code>() const noexcept</code></li>
<li><code>T* Quaternion::</code><strong><code>end</code></strong><code>() noexcept</code></li>
<li><code>const T* Quaternion::</code><strong><code>end</code></strong><code>() const noexcept</code></li>
<li><code>T&amp; Quaternion::</code><strong><code>operator[]</code></strong><code>(size_t i) noexcept</code></li>
<li><code>const T&amp; Quaternion::</code><strong><code>operator[]</code></strong><code>(size_t i) const noexcept</code></li>
</ul>
<p>Element access functions. Behaviour is undefined if the index in <code>operator[]</code>
is out of range (greater than 3).</p>
</div>
<div class="defns">
<ul>
<li><code>Quaternion Quaternion::</code><strong><code>operator+</code></strong><code>() const noexcept</code></li>
<li><code>Quaternion Quaternion::</code><strong><code>operator-</code></strong><code>() const noexcept</code></li>
</ul>
<p>Unary arithmetic operators.</p>
</div>
<div class="defns">
<ul>
<li><code>Quaternion&amp; Quaternion::</code><strong><code>operator+=</code></strong><code>(const Quaternion&amp; rhs) noexcept</code></li>
<li><code>Quaternion&amp; Quaternion::</code><strong><code>operator-=</code></strong><code>(const Quaternion&amp; rhs) noexcept</code></li>
<li><code>Quaternion&amp; Quaternion::</code><strong><code>operator*=</code></strong><code>(const Quaternion&amp; rhs) noexcept</code></li>
<li><code>Quaternion</code> <strong><code>operator+</code></strong><code>(const Quaternion&amp; lhs, const Quaternion&amp; rhs) noexcept</code></li>
<li><code>Quaternion</code> <strong><code>operator-</code></strong><code>(const Quaternion&amp; lhs, const Quaternion&amp; rhs) noexcept</code></li>
<li><code>Quaternion</code> <strong><code>operator*</code></strong><code>(const Quaternion&amp; lhs, const Quaternion&amp; rhs) noexcept</code></li>
</ul>
<p>Quaternion arithmetic operators.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T2&gt; Quaternion&amp; Quaternion::</code><strong><code>operator*=</code></strong><code>(T2 rhs) noexcept</code></li>
<li><code>template &lt;typename T2&gt; Quaternion&amp; Quaternion::</code><strong><code>operator/=</code></strong><code>(T2 rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2&gt; Quaternion&lt;T1&gt;</code> <strong><code>operator*</code></strong><code>(const Quaternion&lt;T1&gt;&amp; lhs, T2 rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2&gt; Quaternion&lt;T2&gt;</code> <strong><code>operator*</code></strong><code>(T1 lhs, const Quaternion&lt;T2&gt;&amp; rhs) noexcept</code></li>
<li><code>template &lt;typename T1, typename T2&gt; Quaternion&lt;T1&gt;</code> <strong><code>operator/</code></strong><code>(const Quaternion&lt;T1&gt;&amp; lhs, T2 rhs) noexcept</code></li>
</ul>
<p>Quaternion-scalar arithmetic operators.</p>
</div>
<div class="defns">
<ul>
<li><code>bool</code> <strong><code>operator==</code></strong><code>(const Quaternion&amp; lhs, const Quaternion&amp; rhs) noexcept</code></li>
<li><code>bool</code> <strong><code>operator!=</code></strong><code>(const Quaternion&amp; lhs, const Quaternion&amp; rhs) noexcept</code></li>
</ul>
<p>Comparison operators.</p>
</div>
<div class="defns">
<ul>
<li><code>Quaternion Quaternion::</code><strong><code>conj</code></strong><code>() const noexcept</code></li>
<li><code>Quaternion Quaternion::</code><strong><code>conj</code></strong><code>(const Quaternion&amp; p) const noexcept</code></li>
</ul>
<p>The first version returns the conjugate quaternion. The second version
performs the conjugation of <code>p</code> by <code>*this</code>, returning
<code>qpq<sup>-1</sup></code> (where <code>q=*this</code>).</p>
</div>
<div class="defns">
<ul>
<li><code>T Quaternion::</code><strong><code>norm</code></strong><code>() const noexcept</code></li>
<li><code>T Quaternion::</code><strong><code>norm2</code></strong><code>() const noexcept</code></li>
</ul>
<p>Returns the quaternion's norm, or its square.</p>
</div>
<div class="defns">
<ul>
<li><code>Quaternion Quaternion::</code><strong><code>recip</code></strong><code>() const noexcept</code></li>
</ul>
<p>Returns the reciprocal of the quaternion. Behaviour is undefined if the
quaternion is zero.</p>
</div>
<div class="defns">
<ul>
<li><code>T Quaternion::</code><strong><code>s_part</code></strong><code>() const noexcept</code></li>
<li><code>Vector&lt;T, 3&gt; Quaternion::</code><strong><code>v_part</code></strong><code>() const noexcept</code></li>
</ul>
<p>Return the scalar and vector parts of the quaternion.</p>
</div>
<div class="defns">
<ul>
<li><code>Quaternion Quaternion::</code><strong><code>versor</code></strong><code>() const noexcept</code></li>
</ul>
<p>Returns the quaternion's versor (unit quaternion). Behaviour is undefined if
the quaternion is zero.</p>
</div>
<div class="defns">
<ul>
<li><code>Vector&lt;T, 4&gt; Quaternion::</code><strong><code>to_vector</code></strong><code>() const noexcept</code></li>
<li><code>static Quaternion</code> <strong><code>from_vector</code></strong><code>(const Vector&lt;T, 4&gt;&amp; v) noexcept</code></li>
</ul>
<p>Component-wise conversions between a quaternion and a 4-vector,</p>
</div>
<div class="defns">
<ul>
<li><code>std::ostream&amp;</code> <strong><code>operator&lt;&lt;</code></strong><code>(std::ostream&amp; out, const Quaternion&amp; q)</code></li>
<li><code>Ustring</code> <strong><code>to_str</code></strong><code>(const Quaternion&amp; q)</code></li>
</ul>
<p>Simple string formatting; this simply writes the quaternion in the same format
as a 4-vector.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; struct std::</code><strong><code>hash</code></strong><code>&lt;Quaternion&lt;T&gt;&gt;</code></li>
</ul>
<p>Hash function.</p>
</div>
<h2 id="transformations">Transformations</h2>
<h3 id="coordinate-transformations">Coordinate transformations</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Vector&lt;T, 2&gt;</code> <strong><code>cartesian_to_polar</code></strong><code>(const Vector&lt;T, 2&gt;&amp; xy) noexcept</code></li>
<li><code>template &lt;typename T&gt; Vector&lt;T, 2&gt;</code> <strong><code>polar_to_cartesian</code></strong><code>(const Vector&lt;T, 2&gt;&amp; rt) noexcept</code></li>
<li><code>template &lt;typename T&gt; Vector&lt;T, 3&gt;</code> <strong><code>cartesian_to_cylindrical</code></strong><code>(const Vector&lt;T, 3&gt;&amp; xyz) noexcept</code></li>
<li><code>template &lt;typename T&gt; Vector&lt;T, 3&gt;</code> <strong><code>cartesian_to_spherical</code></strong><code>(const Vector&lt;T, 3&gt;&amp; xyz) noexcept</code></li>
<li><code>template &lt;typename T&gt; Vector&lt;T, 3&gt;</code> <strong><code>cylindrical_to_cartesian</code></strong><code>(const Vector&lt;T, 3&gt;&amp; rpz) noexcept</code></li>
<li><code>template &lt;typename T&gt; Vector&lt;T, 3&gt;</code> <strong><code>cylindrical_to_spherical</code></strong><code>(const Vector&lt;T, 3&gt;&amp; rpz) noexcept</code></li>
<li><code>template &lt;typename T&gt; Vector&lt;T, 3&gt;</code> <strong><code>spherical_to_cartesian</code></strong><code>(const Vector&lt;T, 3&gt;&amp; rpt) noexcept</code></li>
<li><code>template &lt;typename T&gt; Vector&lt;T, 3&gt;</code> <strong><code>spherical_to_cylindrical</code></strong><code>(const Vector&lt;T, 3&gt;&amp; rpt) noexcept</code></li>
</ul>
<p>Transformations between coordinate systems in two or three dimensions. These
require <code>T</code> to be a floating point type.</p>
</div>
<h3 id="projective-geometry">Projective geometry</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Vector&lt;T, 4&gt;</code> <strong><code>make4</code></strong><code>(const Vector&lt;T, 3&gt;&amp; v, T w) noexcept</code></li>
<li><code>template &lt;typename T&gt; Vector&lt;T, 4&gt;</code> <strong><code>point4</code></strong><code>(const Vector&lt;T, 3&gt;&amp; v) noexcept</code></li>
<li><code>template &lt;typename T&gt; Vector&lt;T, 4&gt;</code> <strong><code>norm4</code></strong><code>(const Vector&lt;T, 3&gt;&amp; v) noexcept</code></li>
</ul>
<p>Convert a 3-vector to a 4-vector. The <code>point4()</code> function sets <code>w</code> to 1;
<code>norm4()</code> sets it to zero.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Vector&lt;T, 3&gt;</code> <strong><code>point3</code></strong><code>(const Vector&lt;T, 4&gt;&amp; v) noexcept</code></li>
<li><code>template &lt;typename T&gt; Vector&lt;T, 3&gt;</code> <strong><code>norm3</code></strong><code>(const Vector&lt;T, 4&gt;&amp; v) noexcept</code></li>
</ul>
<p>Convert a 4-vector to a 3-vector. The <code>point3()</code> function divides the
3-coordinates by <code>w</code> (unless <code>w</code> is zero); <code>norm3()</code> just discards <code>w</code> and
returns the truncated vector.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, int L&gt; Matrix&lt;T, 4, L&gt;</code> <strong><code>make_transform</code></strong><code>(const Matrix&lt;T, 3, L&gt;&amp; m, const Vector&lt;T, 3&gt;&amp; v) noexcept</code></li>
</ul>
<p>Composes a 4&times;4 projective transformation matrix from a 3&times;3 matrix
and a translation vector.</p>
<pre><code>(a b c)             (a b c x)
(d e f), (x y z) =&gt; (d e f y)
(g h i)             (g h i z)
                    (0 0 0 1)
</code></pre>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T, int L&gt; Matrix&lt;T, 4, L&gt;</code> <strong><code>normal_transform</code></strong><code>(const Matrix&lt;T, 4, L&gt;&amp; m) noexcept</code></li>
</ul>
<p>Converts a point transform to a normal transform (returns the transpose of the
inverse of the matrix).</p>
</div>
<h3 id="primitive-transformations">Primitive transformations</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Matrix&lt;T, 3&gt;</code> <strong><code>rotate3</code></strong><code>(T angle, size_t index) noexcept</code></li>
<li><code>template &lt;typename T&gt; Matrix&lt;T, 4&gt;</code> <strong><code>rotate4</code></strong><code>(T angle, size_t index) noexcept</code></li>
</ul>
<p>Generate a rotation by the given angle as a 3D or projective matrix. The index
indicates the axis of rotation (0-2); behaviour is undefined if this is out of
range.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Matrix&lt;T, 3&gt;</code> <strong><code>rotate3</code></strong><code>(T angle, const Vector&lt;T, 3&gt;&amp; axis) noexcept</code></li>
<li><code>template &lt;typename T&gt; Matrix&lt;T, 4&gt;</code> <strong><code>rotate4</code></strong><code>(T angle, const Vector&lt;T, 3&gt;&amp; axis) noexcept</code></li>
</ul>
<p>Generate a rotation by the given angle, about the given axis, as a 3D or
projective matrix. They will return an identity matrix if either argument is
null.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Matrix&lt;T, 3&gt;</code> <strong><code>scale3</code></strong><code>(T t) noexcept</code></li>
<li><code>template &lt;typename T&gt; Matrix&lt;T, 3&gt;</code> <strong><code>scale3</code></strong><code>(const Vector&lt;T, 3&gt;&amp; v) noexcept</code></li>
<li><code>template &lt;typename T&gt; Matrix&lt;T, 4&gt;</code> <strong><code>scale4</code></strong><code>(T t) noexcept</code></li>
<li><code>template &lt;typename T&gt; Matrix&lt;T, 4&gt;</code> <strong><code>scale4</code></strong><code>(const Vector&lt;T, 3&gt;&amp; v) noexcept</code></li>
</ul>
<p>Generate a proportional or triaxial scaling transformation as a 3D or
projective matrix.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Matrix&lt;T, 4&gt;</code> <strong><code>translate4</code></strong><code>(const Vector&lt;T, 3&gt;&amp; v) noexcept</code></li>
</ul>
<p>Generates a translation as a projective matrix (equivalent to
<code>make_transform(Matrix&lt;T,3&gt;::identity(),v)</code>).</p>
</div>
<h3 id="quaternion-transformations">Quaternion transformations</h3>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Vector&lt;T, 3&gt;</code> <strong><code>rotate</code></strong><code>(const Quaternion&lt;T&gt;&amp; q, const Vector&lt;T, 3&gt;&amp; v) noexcept</code></li>
</ul>
<p>Apply the rotation represented by <code>q</code> to the vector <code>v</code>.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Matrix&lt;T, 3&gt;</code> <strong><code>rotate3</code></strong><code>(const Quaternion&lt;T&gt;&amp; q) noexcept</code></li>
<li><code>template &lt;typename T&gt; Matrix&lt;T, 4&gt;</code> <strong><code>rotate4</code></strong><code>(const Quaternion&lt;T&gt;&amp; q) noexcept</code></li>
</ul>
<p>Convert a quaternion into a 3-matrix or projective matrix representing the
same rotation.</p>
</div>
<div class="defns">
<ul>
<li><code>template &lt;typename T&gt; Quaternion&lt;T&gt;</code> <strong><code>rotateq</code></strong><code>(T angle, const Vector&lt;T, 3&gt;&amp; axis) noexcept</code></li>
</ul>
<p>Generate the quaternion corresponding to a rotation by the given angle, about
the given axis.</p></body>
</html>
