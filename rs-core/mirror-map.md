# Two-Way Map #

By Ross Smith

* `#include "rs-core/mirror-map.hpp"`

## Contents ##

[TOC]

## Class MirrorMap ##

* `template <typename K1, typename K2, typename C1 = std::less<K1>, typename C2 = std::less<K2>> class` **`MirrorMap`**

An associative container that allows look-up using either of the two key types
that make up a value pair. Value pairs must be unique, but either of the two
key types can have duplicate entries.

* `using MirrorMap::`**`left_key`** `= K1`
* `using MirrorMap::`**`right_key`** `= K2`
* `using MirrorMap::`**`left_compare`** `= C1`
* `using MirrorMap::`**`right_compare`** `= C2`
* `using MirrorMap::`**`value_type`** `= std::pair<K1, K2>`
* `class MirrorMap::`**`left_iterator`** _- const bidirectional iterator_
* `class MirrorMap::`**`right_iterator`** _- const bidirectional iterator_
* `struct MirrorMap::`**`insert_result`**
    * `left_iterator insert_result::`**`left`**
    * `right_iterator insert_result::`**`right`**
    * `bool insert_result::`**`inserted`**
* `using MirrorMap::`**`left_range`** `= Irange<left_iterator>`
* `using MirrorMap::`**`right_range`** `= Irange<right_iterator>`

Member types. The left and right iterators traverse the map in the orders
generated by the left and right comparison functions; in each case the other
comparison function is used as a tie-breaker. The `insert_result` type is
returned from the single element insert operation.

* `MirrorMap::`**`MirrorMap`**`()`
* `explicit MirrorMap::`**`MirrorMap`**`(C1 c1, C2 c2 = {})`
* `MirrorMap::`**`MirrorMap`**`(std::initializer_list<value_type> list)`
* `template <typename Iterator> MirrorMap::`**`MirrorMap`**`(Iterator i, Iterator j, C1 c1 = {}, C2 c2 = {})`
* `MirrorMap::`**`MirrorMap`**`(const MirrorMap& mm)`
* `MirrorMap::`**`MirrorMap`**`(MirrorMap&& mm) noexcept`
* `MirrorMap::`**`~MirrorMap`**`() noexcept`
* `MirrorMap& MirrorMap::`**`operator=`**`(const MirrorMap& mm)`
* `MirrorMap& MirrorMap::`**`operator=`**`(MirrorMap&& mm) noexcept`

Life cycle functions. These all work in the same way as their equivalents in
`std::map`.

* `void MirrorMap::`**`clear`**`() noexcept`

Erase all elements.

* `size_t MirrorMap::`**`count_left`**`(const K1& key) const`
* `size_t MirrorMap::`**`count_right`**`(const K2& key) const`

Return the number of times a given key occurs.

* `bool MirrorMap::`**`empty`**`() const noexcept`

True if the container is empty.

* `left_range MirrorMap::`**`equal_left`**`(const K1& key) const`
* `right_range MirrorMap::`**`equal_right`**`(const K2& key) const`

Return matching ranges (following the usual meaning of `equal_range()`) for a
given left or right key.

* `void MirrorMap::`**`erase`**`(left_iterator i) noexcept`
* `void MirrorMap::`**`erase`**`(right_iterator i) noexcept`
* `bool MirrorMap::`**`erase`**`(const value_type& pair) noexcept`
* `size_t MirrorMap::`**`erase_left`**`(const K1& key) noexcept`
* `size_t MirrorMap::`**`erase_right`**`(const K2& key) noexcept`

Erase an element. The third version returns true if a matching element was
erased; the last two versions return the number of erased elements.

* `left_iterator MirrorMap::`**`find_left`**`(const K1& key) const`
* `left_iterator MirrorMap::`**`find_left`**`(const value_type& pair) const`
* `right_iterator MirrorMap::`**`find_right`**`(const K2& key) const`
* `right_iterator MirrorMap::`**`find_right`**`(const value_type& pair) const`

Return an iterator pointing to the first matching element, or the appropriate
end iterator if there is no match.

* `insert_result MirrorMap::`**`insert`**`(const value_type& pair)`
* `template <typename Iterator> void MirrorMap::`**`insert`**`(Iterator i, Iterator j)`

Insert one or more elements. The returned `insert_result` contains left and
right iterators pointing to the matching entry, and a boolean to indicate
whether a new element was inserted.

* `left_range MirrorMap::`**`left`**`() const`
* `left_iterator MirrorMap::`**`begin_left`**`() const`
* `left_iterator MirrorMap::`**`end_left`**`() const`
* `right_range MirrorMap::`**`right`**`() const`
* `right_iterator MirrorMap::`**`begin_right`**`() const`
* `right_iterator MirrorMap::`**`end_right`**`() const`

Iterators over the elements of the map, ordered by the left or right key.

* `C1 MirrorMap::`**`left_comp`**`() const`
* `C2 MirrorMap::`**`right_comp`**`() const`

Return copies of the comparison objects.

* `left_iterator MirrorMap::`**`mirror`**`(right_iterator i) const`
* `right_iterator MirrorMap::`**`mirror`**`(left_iterator i) const`

Given a left or right iterator, return the right or left iterator that points
to the same element (or an end iterator if the argument was an end iterator).

* `size_t MirrorMap::`**`size`**`() const noexcept`

Returns the number of elements in the container.

* `void MirrorMap::`**`swap`**`(MirrorMap& mm) noexcept`
* `void` **`swap`**`(MirrorMap& mm1, MirrorMap& mm2) noexcept`

Swap two container.
