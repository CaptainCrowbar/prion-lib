#pragma once

#include "rs-core/common.hpp"
#include "rs-core/float.hpp"

namespace RS {

    // Simple random generators

    template <typename T, typename RNG>
    T random_integer(RNG& rng, T min, T max) {
        static_assert(std::is_integral<T>::value, "Random integer type is not an integer");
        // We need an unsigned integer type big enough for both the RNG and
        // output ranges.
        using rng_type = typename RNG::result_type;
        using out_type = std::make_unsigned_t<T>;
        using larger_type = std::conditional_t<(sizeof(out_type) > sizeof(rng_type)), out_type, rng_type>;
        using work_type = std::conditional_t<(sizeof(larger_type) > sizeof(unsigned)), larger_type, unsigned>;
        // Compare the input range (max-min of the values generated by the
        // RNG) with the output range (max-min of the possible results).
        if (min > max)
            std::swap(min, max);
        work_type rng_min = work_type(rng.min());
        work_type rng_range = work_type(rng.max()) - rng_min;
        work_type out_range = work_type(out_type(max) - out_type(min));
        work_type result = 0;
        if (out_range < rng_range) {
            // The RNG range is larger than the output range. Divide the
            // output of the RNG by the rounded down quotient of the ranges.
            // If one range is not an exact multiple of the other, this may
            // yield a value too large; try again.
            work_type ratio = (rng_range - out_range) / (out_range + 1) + 1;
            work_type limit = ratio * (out_range + 1) - 1;
            do result = work_type(rng() - rng_min);
                while (result > limit);
            result /= ratio;
        } else if (out_range == rng_range) {
            // The trivial case where the two ranges are equal.
            result = work_type(rng() - rng_min);
        } else {
            // The output range is larger than the RNG range. Split the output
            // range into a quotient and remainder modulo the RNG range +1;
            // call this function recursively for the quotient, then call the
            // RNG directly for the remainder. Try again if the result is too
            // large.
            work_type high = 0, low = 0;
            work_type ratio = (out_range - rng_range) / (rng_range + 1);
            do {
                high = random_integer(rng, work_type(0), ratio) * (rng_range + 1);
                low = work_type(rng() - rng_min);
            } while (low > out_range - high);
            result = high + low;
        }
        return min + T(result);
    }

    template <typename T, typename RNG>
    T random_integer(RNG& rng, T t) {
        static_assert(std::is_integral<T>::value, "Random integer type is not an integer");
        if (t <= T(1))
            return T(0);
        else
            return random_integer(rng, T(0), t - T(1));
    }

    template <typename T, typename RNG>
    T random_dice(RNG& rng, T n = T(1), T faces = T(6)) {
        static_assert(std::is_integral<T>::value, "Random dice type is not an integer");
        if (n < T(1) || faces < T(1))
            return T(0);
        T sum = T(0);
        for (T i = T(0); i < n; ++i)
            sum += random_integer(rng, T(1), faces);
        return sum;
    }

    template <typename T, typename RNG>
    T random_float(RNG& rng, T a = T(1), T b = T(0)) {
        static_assert(std::is_floating_point<T>::value, "Random float type is not floating point");
        return a + (b - a) * (T(rng() - rng.min()) / (T(rng.max() - rng.min()) + T(1)));
    }

    template <typename T, typename RNG>
    T random_normal(RNG& rng) {
        static_assert(std::is_floating_point<T>::value, "Random normal type is not floating point");
        T u1 = random_float<T>(rng);
        T u2 = random_float<T>(rng);
        return std::sqrt(T(-2) * std::log(u1)) * std::cos(T(2) * pi_c<T> * u2);
    }

    template <typename T, typename RNG>
    T random_normal(RNG& rng, T m, T s) {
        static_assert(std::is_floating_point<T>::value, "Random float type is not floating point");
        return m + s * random_normal<T>(rng);
    }

    template <typename RNG>
    bool random_bool(RNG& rng) {
        using R = typename RNG::result_type;
        R min = rng.min();
        R range = rng.max() - min;
        R cutoff = min + range / R(2);
        // Test for odd range is reversed because range is one less than the number of values
        bool odd = range % R(1) == R(0);
        R x = R();
        do x = rng();
            while (odd && x == min);
        return x > cutoff;
    }

    template <typename RNG>
    bool random_bool(RNG& rng, double p) {
        return random_float<double>(rng) <= p;
    }

    template <typename RNG, typename T>
    bool random_bool(RNG& rng, T num, T den) {
        RS_STATIC_ASSERT(std::is_integral<T>::value);
        return random_integer(rng, den) < num;
    }

    template <typename ForwardRange, typename RNG>
    RangeValue<ForwardRange> random_choice(RNG& rng, const ForwardRange& range) {
        using T = RangeValue<ForwardRange>;
        using std::begin;
        using std::end;
        auto i = begin(range), j = end(range);
        if (i == j)
            return T();
        size_t n = std::distance(i, j);
        std::advance(i, random_integer(rng, n));
        return *i;
    }

    template <typename T, typename RNG>
    T random_choice(RNG& rng, std::initializer_list<T> list) {
        if (list.size() == 0)
            return T();
        else
            return list.begin()[random_integer(rng, list.size())];
    }

    template <typename ForwardRange, typename RNG>
    std::vector<RangeValue<ForwardRange>> random_sample(RNG& rng, const ForwardRange& range, size_t k) {
        using T = RangeValue<ForwardRange>;
        using std::begin;
        using std::end;
        auto b = begin(range), e = end(range);
        size_t n = std::distance(b, e);
        if (k > n)
            throw std::length_error("Sample size requested is larger than the population");
        auto p = b;
        std::advance(p, k);
        std::vector<T> sample(b, p);
        for (size_t i = k; i < n; ++i, ++p) {
            auto j = random_integer(rng, i);
            if (j < k)
                sample[j] = *p;
        }
        return sample;
    }

    // Other random functions

    template <typename RNG>
    void random_bytes(RNG& rng, void* ptr, size_t n) {
        static constexpr auto max64 = ~ uint64_t(0);
        if (! ptr || ! n)
            return;
        auto range_m1 = uint64_t(std::min(uintmax_t(RNG::max()) - uintmax_t(RNG::min()), uintmax_t(max64)));
        size_t block;
        if (range_m1 == max64)
            block = 8;
        else
            block = (ilog2p1(range_m1) - 1) / 8;
        auto bp = static_cast<uint8_t*>(ptr);
        if (block) {
            while (n >= block) {
                auto x = rng() - RNG::min();
                memcpy(bp, &x, block);
                bp += block;
                n -= block;
            }
            if (n) {
                auto x = rng() - RNG::min();
                memcpy(bp, &x, n);
            }
        } else {
            for (size_t i = 0; i < n; ++i)
                bp[i] = uint8_t(random_integer(rng, 256));
        }
    }

    template <typename RNG, typename RandomAccessIterator>
    void shuffle(RNG& rng, RandomAccessIterator i, RandomAccessIterator j) {
        size_t n = std::distance(i, j);
        for (size_t a = 0; a + 1 < n; ++a) {
            size_t b = random_integer(rng, a, n - 1);
            if (a != b)
                std::swap(i[a], i[b]);
        }
    }

    template <typename RNG, typename RandomAccessRange>
    void shuffle(RNG& rng, RandomAccessRange& range) {
        using std::begin;
        using std::end;
        shuffle(begin(range), end(range), rng);
    }

}
