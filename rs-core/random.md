# Random Numbers #

By Ross Smith

* `#include "rs-core/random.hpp"`

## Contents ##

[TOC]

## Random device sources ##

* `template <typename T> class` **`Urandom`**
    * `using Urandom::`**`result_type`** `= T`
    * `T Urandom::`**`operator()`**`() noexcept`
    * `static constexpr T Urandom::`**`min`**`() noexcept`
    * `static constexpr T Urandom::`**`max`**`() noexcept`
* `using` **`Urandom32`** `= Urandom<uint32_t>`
* `using` **`Urandom64`** `= Urandom<uint64_t>`

Generate random numbers from the system's standard random device. On Unix this
reads from `/dev/urandom`. The result type `T` must be a primitive integer
type. (This is similar to `std::random_device`, which is not implemented on
all of my target systems.)

* `void` **`urandom_bytes`**`(void* ptr, size_t n) noexcept`

Copies random bytes from the system's standard random device. This will do
nothing if either argument is null.

## Xoroshiro generator ##

* `class` **`Xoroshiro`**
    * `using Xoroshiro::`**`result_type`** `= uint64_t`
    * `Xoroshiro::`**`Xoroshiro`**`() noexcept`
    * `explicit Xoroshiro::`**`Xoroshiro`**`(uint64_t s) noexcept`
    * `Xoroshiro::`**`Xoroshiro`**`(uint64_t s1, uint64_t s2) noexcept`
    * `uint64_t Xoroshiro::`**`operator()`**`() noexcept`
    * `bool Xoroshiro::`**`operator==`**`(const Xoroshiro& rhs) const noexcept`
    * `bool Xoroshiro::`**`operator!=`**`(const Xoroshiro& rhs) const noexcept`
    * `void Xoroshiro::`**`seed`**`(uint64_t s) noexcept`
    * `void Xoroshiro::`**`seed`**`(uint64_t s1, uint64_t s2) noexcept`
    * `static constexpr uint64_t Xoroshiro::`**`min`**`() noexcept` _= 0_
    * `static constexpr uint64_t Xoroshiro::`**`max`**`() noexcept` _= 2<sup>64</sup>-1_

Xoroshiro128+ algorithm by [David Blackman and Sebastiano
Vigna](http://xoroshiro.di.unimi.it).

## Simple random distributions ##

* `template <typename RNG> bool` **`random_bool`**`(RNG& rng)` _- True with probability 1/2_
* `template <typename RNG> bool` **`random_bool`**`(RNG& rng, double p)` _- True with probability p (clamped to 0-1)_
* `template <typename RNG, typename T> bool` **`random_bool`**`(RNG& rng, T num, T den)` _- True with probability num/den (clamped to 0-1)_
* `template <typename T, typename RNG> T` **`random_integer`**`(RNG& rng, T t)` _- Random integer from 0 to t-1 (always 0 if t<2)_
* `template <typename T, typename RNG> T` **`random_integer`**`(RNG& rng, T a, T b)` _- Random integer from a to b inclusive (limits may be in either order)_
* `template <typename T, typename RNG> T` **`random_dice`**`(RNG& rng, T n = 1, T faces = 6)` _- Roll n dice numbered from 1 to faces (0 if either argument is <1)_
* `template <typename T, typename RNG> T` **`random_float`**`(RNG& rng, T a = 1, T b = 0)` _- Random number between a and b (limits may be in either order)_
* `template <typename T, typename RNG> T` **`random_normal`**`(RNG& rng)` _- Normal distribution with mean 0, sd 1_
* `template <typename T, typename RNG> T` **`random_normal`**`(RNG& rng, T m, T s)` _- Normal distribution with given mean and sd_
* `template <typename ForwardRange, typename RNG> [value type]` **`random_choice`**`(RNG& rng, const ForwardRange& range)` _- Random element from range (default constructed value if range is empty)_
* `template <typename T, typename RNG> T` **`random_choice`**`(RNG& rng, initializer_list<T> list)` _- Random element from explicit list_
* `template <typename ForwardRange, typename RNG> vector<[value type]>` **`random_sample`**`(RNG& rng, const ForwardRange& range, size_t k)` _- Random sample from range (throws length_error if k>n)_

Simple random number functions. These do not call the standard distribution
classes; given the same underlying deterministic pseudo-random number engine
(the `RNG` type), these can be relied on to return the same values on
different systems and compilers (apart from small differences due to rounding
errors in the floating point functions).

## Other random functions ##

* `template <typename RNG> void` **`random_bytes`**`(RNG& rng, void* ptr, size_t n)`

Fills a block of memory with random bits generated by the RNG. This will do
nothing if `ptr` is null or `n=0`.

* `template <typename RNG, typename RandomAccessRange> void` **`shuffle`**`(RNG& rng, RandomAccessRange& range)`
* `template <typename RNG, typename RandomAccessIterator> void` **`shuffle`**`(RNG& rng, RandomAccessIterator i, RandomAccessIterator j)`

Shuffle the elements of a random access range into random order. This is
functionally the same as `std::shuffle()`, duplicated here to provide a
version with reproducible behaviour on all systems.
